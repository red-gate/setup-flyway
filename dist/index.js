import { createRequire as ZI } from "node:module";
import { dirname as KI } from "node:path";
import { fileURLToPath as jI } from "node:url";
import * as Zt from "os";
import cl from "os";
import * as Js from "crypto";
import * as tt from "fs";
import { promises as ry, writeFileSync as ny, existsSync as sy } from "fs";
import * as De from "path";
import * as zo from "http";
import ll from "http";
import * as Qd from "https";
import dl from "https";
import ul from "net";
import ml from "tls";
import * as Vg from "events";
import _g, { EventEmitter as Wg } from "events";
import yt, { ok as Ps } from "assert";
import * as hl from "util";
import iy from "util";
import lt from "node:assert";
import Xi from "node:net";
import Bn from "node:http";
import dr, { Transform as oy, Readable as gl } from "node:stream";
import ur from "node:buffer";
import _t, { inspect as ay } from "node:util";
import Ay from "node:querystring";
import Vs from "node:events";
import cy from "node:diagnostics_channel";
import ly from "node:tls";
import Hs from "node:zlib";
import dy from "node:perf_hooks";
import $g from "node:util/types";
import Xg from "node:worker_threads";
import uy from "node:url";
import _s from "node:async_hooks";
import my from "node:console";
import hy from "node:dns";
import gy from "string_decoder";
import * as fy from "child_process";
import { setTimeout as py } from "timers";
import * as Zg from "stream";
import { Readable as fl } from "stream";
import Kg, { URL as Ey } from "url";
import * as Cy from "buffer";
import { Buffer as By } from "buffer";
import qo, { EOL as Iy } from "node:os";
import ki from "node:process";
import Go from "node:https";
import { createHmac as pl } from "node:crypto";
import El from "node:fs";
const Wn = ZI(import.meta.url), ey = jI(import.meta.url), ty = KI(ey);
function $n(t) {
  return t == null ? "" : typeof t == "string" || t instanceof String ? t : JSON.stringify(t);
}
function jg(t) {
  return Object.keys(t).length ? {
    title: t.title,
    file: t.file,
    line: t.startLine,
    endLine: t.endLine,
    col: t.startColumn,
    endColumn: t.endColumn
  } : {};
}
function jr(t, e, r) {
  const n = new yy(t, e, r);
  process.stdout.write(n.toString() + Zt.EOL);
}
function ef(t, e = "") {
  jr(t, {}, e);
}
const Nd = "::";
class yy {
  constructor(e, r, n) {
    e || (e = "missing.command"), this.command = e, this.properties = r, this.message = n;
  }
  toString() {
    let e = Nd + this.command;
    if (this.properties && Object.keys(this.properties).length > 0) {
      e += " ";
      let r = !0;
      for (const n in this.properties)
        if (this.properties.hasOwnProperty(n)) {
          const s = this.properties[n];
          s && (r ? r = !1 : e += ",", e += `${n}=${Ny(s)}`);
        }
    }
    return e += `${Nd}${Qy(this.message)}`, e;
  }
}
function Qy(t) {
  return $n(t).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
}
function Ny(t) {
  return $n(t).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
}
function Cl(t, e) {
  const r = process.env[`GITHUB_${t}`];
  if (!r)
    throw new Error(`Unable to find environment variable for file command ${t}`);
  if (!tt.existsSync(r))
    throw new Error(`Missing file at path: ${r}`);
  tt.appendFileSync(r, `${$n(e)}${Zt.EOL}`, {
    encoding: "utf8"
  });
}
function tf(t, e) {
  const r = `ghadelimiter_${Js.randomUUID()}`, n = $n(e);
  if (t.includes(r))
    throw new Error(`Unexpected input: name should not contain the delimiter "${r}"`);
  if (n.includes(r))
    throw new Error(`Unexpected input: value should not contain the delimiter "${r}"`);
  return `${t}<<${r}${Zt.EOL}${n}${Zt.EOL}${r}`;
}
function wd(t) {
  const e = t.protocol === "https:";
  if (wy(t))
    return;
  const r = e ? process.env.https_proxy || process.env.HTTPS_PROXY : process.env.http_proxy || process.env.HTTP_PROXY;
  if (r)
    try {
      return new bd(r);
    } catch {
      if (!r.startsWith("http://") && !r.startsWith("https://"))
        return new bd(`http://${r}`);
    }
  else
    return;
}
function wy(t) {
  if (!t.hostname)
    return !1;
  const e = t.hostname;
  if (by(e))
    return !0;
  const r = process.env.no_proxy || process.env.NO_PROXY || "";
  if (!r)
    return !1;
  let n;
  t.port ? n = Number(t.port) : t.protocol === "http:" ? n = 80 : t.protocol === "https:" && (n = 443);
  const s = [t.hostname.toUpperCase()];
  typeof n == "number" && s.push(`${s[0]}:${n}`);
  for (const i of r.split(",").map((o) => o.trim().toUpperCase()).filter((o) => o))
    if (i === "*" || s.some((o) => o === i || o.endsWith(`.${i}`) || i.startsWith(".") && o.endsWith(`${i}`)))
      return !0;
  return !1;
}
function by(t) {
  const e = t.toLowerCase();
  return e === "localhost" || e.startsWith("127.") || e.startsWith("[::1]") || e.startsWith("[0:0:0:0:0:0:0:1]");
}
class bd extends URL {
  constructor(e, r) {
    super(e, r), this._decodedUsername = decodeURIComponent(super.username), this._decodedPassword = decodeURIComponent(super.password);
  }
  get username() {
    return this._decodedUsername;
  }
  get password() {
    return this._decodedPassword;
  }
}
var xd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xy(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ln = {}, Rd;
function Ry() {
  if (Rd) return ln;
  Rd = 1;
  var t = ml, e = ll, r = dl, n = _g, s = iy;
  ln.httpOverHttp = i, ln.httpsOverHttp = o, ln.httpOverHttps = a, ln.httpsOverHttps = A;
  function i(h) {
    var f = new c(h);
    return f.request = e.request, f;
  }
  function o(h) {
    var f = new c(h);
    return f.request = e.request, f.createSocket = l, f.defaultPort = 443, f;
  }
  function a(h) {
    var f = new c(h);
    return f.request = r.request, f;
  }
  function A(h) {
    var f = new c(h);
    return f.request = r.request, f.createSocket = l, f.defaultPort = 443, f;
  }
  function c(h) {
    var f = this;
    f.options = h || {}, f.proxyOptions = f.options.proxy || {}, f.maxSockets = f.options.maxSockets || e.Agent.defaultMaxSockets, f.requests = [], f.sockets = [], f.on("free", function(y, w, R, D) {
      for (var L = d(w, R, D), C = 0, I = f.requests.length; C < I; ++C) {
        var x = f.requests[C];
        if (x.host === L.host && x.port === L.port) {
          f.requests.splice(C, 1), x.request.onSocket(y);
          return;
        }
      }
      y.destroy(), f.removeSocket(y);
    });
  }
  s.inherits(c, n.EventEmitter), c.prototype.addRequest = function(f, p, y, w) {
    var R = this, D = u({ request: f }, R.options, d(p, y, w));
    if (R.sockets.length >= this.maxSockets) {
      R.requests.push(D);
      return;
    }
    R.createSocket(D, function(L) {
      L.on("free", C), L.on("close", I), L.on("agentRemove", I), f.onSocket(L);
      function C() {
        R.emit("free", L, D);
      }
      function I(x) {
        R.removeSocket(L), L.removeListener("free", C), L.removeListener("close", I), L.removeListener("agentRemove", I);
      }
    });
  }, c.prototype.createSocket = function(f, p) {
    var y = this, w = {};
    y.sockets.push(w);
    var R = u({}, y.proxyOptions, {
      method: "CONNECT",
      path: f.host + ":" + f.port,
      agent: !1,
      headers: {
        host: f.host + ":" + f.port
      }
    });
    f.localAddress && (R.localAddress = f.localAddress), R.proxyAuth && (R.headers = R.headers || {}, R.headers["Proxy-Authorization"] = "Basic " + new Buffer(R.proxyAuth).toString("base64")), m("making CONNECT request");
    var D = y.request(R);
    D.useChunkedEncodingByDefault = !1, D.once("response", L), D.once("upgrade", C), D.once("connect", I), D.once("error", x), D.end();
    function L(g) {
      g.upgrade = !0;
    }
    function C(g, B, Q) {
      process.nextTick(function() {
        I(g, B, Q);
      });
    }
    function I(g, B, Q) {
      if (D.removeAllListeners(), B.removeAllListeners(), g.statusCode !== 200) {
        m(
          "tunneling socket could not be established, statusCode=%d",
          g.statusCode
        ), B.destroy();
        var E = new Error("tunneling socket could not be established, statusCode=" + g.statusCode);
        E.code = "ECONNRESET", f.request.emit("error", E), y.removeSocket(w);
        return;
      }
      if (Q.length > 0) {
        m("got illegal response body from proxy"), B.destroy();
        var E = new Error("got illegal response body from proxy");
        E.code = "ECONNRESET", f.request.emit("error", E), y.removeSocket(w);
        return;
      }
      return m("tunneling connection has established"), y.sockets[y.sockets.indexOf(w)] = B, p(B);
    }
    function x(g) {
      D.removeAllListeners(), m(
        `tunneling socket could not be established, cause=%s
`,
        g.message,
        g.stack
      );
      var B = new Error("tunneling socket could not be established, cause=" + g.message);
      B.code = "ECONNRESET", f.request.emit("error", B), y.removeSocket(w);
    }
  }, c.prototype.removeSocket = function(f) {
    var p = this.sockets.indexOf(f);
    if (p !== -1) {
      this.sockets.splice(p, 1);
      var y = this.requests.shift();
      y && this.createSocket(y, function(w) {
        y.request.onSocket(w);
      });
    }
  };
  function l(h, f) {
    var p = this;
    c.prototype.createSocket.call(p, h, function(y) {
      var w = h.request.getHeader("host"), R = u({}, p.options, {
        socket: y,
        servername: w ? w.replace(/:.*$/, "") : h.host
      }), D = t.connect(0, R);
      p.sockets[p.sockets.indexOf(y)] = D, f(D);
    });
  }
  function d(h, f, p) {
    return typeof h == "string" ? {
      host: h,
      port: f,
      localAddress: p
    } : h;
  }
  function u(h) {
    for (var f = 1, p = arguments.length; f < p; ++f) {
      var y = arguments[f];
      if (typeof y == "object")
        for (var w = Object.keys(y), R = 0, D = w.length; R < D; ++R) {
          var L = w[R];
          y[L] !== void 0 && (h[L] = y[L]);
        }
    }
    return h;
  }
  var m;
  return process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? m = function() {
    var h = Array.prototype.slice.call(arguments);
    typeof h[0] == "string" ? h[0] = "TUNNEL: " + h[0] : h.unshift("TUNNEL:"), console.error.apply(console, h);
  } : m = function() {
  }, ln.debug = m, ln;
}
var Yo, Sd;
function Sy() {
  return Sd || (Sd = 1, Yo = Ry()), Yo;
}
var fi = Sy(), Fe = {}, Jo, Dd;
function gt() {
  return Dd || (Dd = 1, Jo = {
    kClose: /* @__PURE__ */ Symbol("close"),
    kDestroy: /* @__PURE__ */ Symbol("destroy"),
    kDispatch: /* @__PURE__ */ Symbol("dispatch"),
    kUrl: /* @__PURE__ */ Symbol("url"),
    kWriting: /* @__PURE__ */ Symbol("writing"),
    kResuming: /* @__PURE__ */ Symbol("resuming"),
    kQueue: /* @__PURE__ */ Symbol("queue"),
    kConnect: /* @__PURE__ */ Symbol("connect"),
    kConnecting: /* @__PURE__ */ Symbol("connecting"),
    kKeepAliveDefaultTimeout: /* @__PURE__ */ Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: /* @__PURE__ */ Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: /* @__PURE__ */ Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: /* @__PURE__ */ Symbol("keep alive timeout"),
    kKeepAlive: /* @__PURE__ */ Symbol("keep alive"),
    kHeadersTimeout: /* @__PURE__ */ Symbol("headers timeout"),
    kBodyTimeout: /* @__PURE__ */ Symbol("body timeout"),
    kServerName: /* @__PURE__ */ Symbol("server name"),
    kLocalAddress: /* @__PURE__ */ Symbol("local address"),
    kHost: /* @__PURE__ */ Symbol("host"),
    kNoRef: /* @__PURE__ */ Symbol("no ref"),
    kBodyUsed: /* @__PURE__ */ Symbol("used"),
    kBody: /* @__PURE__ */ Symbol("abstracted request body"),
    kRunning: /* @__PURE__ */ Symbol("running"),
    kBlocking: /* @__PURE__ */ Symbol("blocking"),
    kPending: /* @__PURE__ */ Symbol("pending"),
    kSize: /* @__PURE__ */ Symbol("size"),
    kBusy: /* @__PURE__ */ Symbol("busy"),
    kQueued: /* @__PURE__ */ Symbol("queued"),
    kFree: /* @__PURE__ */ Symbol("free"),
    kConnected: /* @__PURE__ */ Symbol("connected"),
    kClosed: /* @__PURE__ */ Symbol("closed"),
    kNeedDrain: /* @__PURE__ */ Symbol("need drain"),
    kReset: /* @__PURE__ */ Symbol("reset"),
    kDestroyed: /* @__PURE__ */ Symbol.for("nodejs.stream.destroyed"),
    kResume: /* @__PURE__ */ Symbol("resume"),
    kOnError: /* @__PURE__ */ Symbol("on error"),
    kMaxHeadersSize: /* @__PURE__ */ Symbol("max headers size"),
    kRunningIdx: /* @__PURE__ */ Symbol("running index"),
    kPendingIdx: /* @__PURE__ */ Symbol("pending index"),
    kError: /* @__PURE__ */ Symbol("error"),
    kClients: /* @__PURE__ */ Symbol("clients"),
    kClient: /* @__PURE__ */ Symbol("client"),
    kParser: /* @__PURE__ */ Symbol("parser"),
    kOnDestroyed: /* @__PURE__ */ Symbol("destroy callbacks"),
    kPipelining: /* @__PURE__ */ Symbol("pipelining"),
    kSocket: /* @__PURE__ */ Symbol("socket"),
    kHostHeader: /* @__PURE__ */ Symbol("host header"),
    kConnector: /* @__PURE__ */ Symbol("connector"),
    kStrictContentLength: /* @__PURE__ */ Symbol("strict content length"),
    kMaxRedirections: /* @__PURE__ */ Symbol("maxRedirections"),
    kMaxRequests: /* @__PURE__ */ Symbol("maxRequestsPerClient"),
    kProxy: /* @__PURE__ */ Symbol("proxy agent options"),
    kCounter: /* @__PURE__ */ Symbol("socket request counter"),
    kInterceptors: /* @__PURE__ */ Symbol("dispatch interceptors"),
    kMaxResponseSize: /* @__PURE__ */ Symbol("max response size"),
    kHTTP2Session: /* @__PURE__ */ Symbol("http2Session"),
    kHTTP2SessionState: /* @__PURE__ */ Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: /* @__PURE__ */ Symbol("retry agent default retry"),
    kConstruct: /* @__PURE__ */ Symbol("constructable"),
    kListeners: /* @__PURE__ */ Symbol("listeners"),
    kHTTPContext: /* @__PURE__ */ Symbol("http context"),
    kMaxConcurrentStreams: /* @__PURE__ */ Symbol("max concurrent streams"),
    kNoProxyAgent: /* @__PURE__ */ Symbol("no proxy agent"),
    kHttpProxyAgent: /* @__PURE__ */ Symbol("http proxy agent"),
    kHttpsProxyAgent: /* @__PURE__ */ Symbol("https proxy agent")
  }), Jo;
}
var Vo, kd;
function it() {
  if (kd) return Vo;
  kd = 1;
  const t = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR");
  class e extends Error {
    constructor(H) {
      super(H), this.name = "UndiciError", this.code = "UND_ERR";
    }
    static [Symbol.hasInstance](H) {
      return H && H[t] === !0;
    }
    [t] = !0;
  }
  const r = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_CONNECT_TIMEOUT");
  class n extends e {
    constructor(H) {
      super(H), this.name = "ConnectTimeoutError", this.message = H || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
    static [Symbol.hasInstance](H) {
      return H && H[r] === !0;
    }
    [r] = !0;
  }
  const s = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_HEADERS_TIMEOUT");
  class i extends e {
    constructor(H) {
      super(H), this.name = "HeadersTimeoutError", this.message = H || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
    static [Symbol.hasInstance](H) {
      return H && H[s] === !0;
    }
    [s] = !0;
  }
  const o = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_HEADERS_OVERFLOW");
  class a extends e {
    constructor(H) {
      super(H), this.name = "HeadersOverflowError", this.message = H || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
    static [Symbol.hasInstance](H) {
      return H && H[o] === !0;
    }
    [o] = !0;
  }
  const A = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_BODY_TIMEOUT");
  class c extends e {
    constructor(H) {
      super(H), this.name = "BodyTimeoutError", this.message = H || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
    }
    static [Symbol.hasInstance](H) {
      return H && H[A] === !0;
    }
    [A] = !0;
  }
  const l = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_RESPONSE_STATUS_CODE");
  class d extends e {
    constructor(H, W, z, $) {
      super(H), this.name = "ResponseStatusCodeError", this.message = H || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = $, this.status = W, this.statusCode = W, this.headers = z;
    }
    static [Symbol.hasInstance](H) {
      return H && H[l] === !0;
    }
    [l] = !0;
  }
  const u = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_INVALID_ARG");
  class m extends e {
    constructor(H) {
      super(H), this.name = "InvalidArgumentError", this.message = H || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
    }
    static [Symbol.hasInstance](H) {
      return H && H[u] === !0;
    }
    [u] = !0;
  }
  const h = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_INVALID_RETURN_VALUE");
  class f extends e {
    constructor(H) {
      super(H), this.name = "InvalidReturnValueError", this.message = H || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
    static [Symbol.hasInstance](H) {
      return H && H[h] === !0;
    }
    [h] = !0;
  }
  const p = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_ABORT");
  class y extends e {
    constructor(H) {
      super(H), this.name = "AbortError", this.message = H || "The operation was aborted", this.code = "UND_ERR_ABORT";
    }
    static [Symbol.hasInstance](H) {
      return H && H[p] === !0;
    }
    [p] = !0;
  }
  const w = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_ABORTED");
  class R extends y {
    constructor(H) {
      super(H), this.name = "AbortError", this.message = H || "Request aborted", this.code = "UND_ERR_ABORTED";
    }
    static [Symbol.hasInstance](H) {
      return H && H[w] === !0;
    }
    [w] = !0;
  }
  const D = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_INFO");
  class L extends e {
    constructor(H) {
      super(H), this.name = "InformationalError", this.message = H || "Request information", this.code = "UND_ERR_INFO";
    }
    static [Symbol.hasInstance](H) {
      return H && H[D] === !0;
    }
    [D] = !0;
  }
  const C = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_REQ_CONTENT_LENGTH_MISMATCH");
  class I extends e {
    constructor(H) {
      super(H), this.name = "RequestContentLengthMismatchError", this.message = H || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](H) {
      return H && H[C] === !0;
    }
    [C] = !0;
  }
  const x = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_RES_CONTENT_LENGTH_MISMATCH");
  class g extends e {
    constructor(H) {
      super(H), this.name = "ResponseContentLengthMismatchError", this.message = H || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](H) {
      return H && H[x] === !0;
    }
    [x] = !0;
  }
  const B = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_DESTROYED");
  class Q extends e {
    constructor(H) {
      super(H), this.name = "ClientDestroyedError", this.message = H || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
    }
    static [Symbol.hasInstance](H) {
      return H && H[B] === !0;
    }
    [B] = !0;
  }
  const E = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_CLOSED");
  class b extends e {
    constructor(H) {
      super(H), this.name = "ClientClosedError", this.message = H || "The client is closed", this.code = "UND_ERR_CLOSED";
    }
    static [Symbol.hasInstance](H) {
      return H && H[E] === !0;
    }
    [E] = !0;
  }
  const N = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_SOCKET");
  class S extends e {
    constructor(H, W) {
      super(H), this.name = "SocketError", this.message = H || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = W;
    }
    static [Symbol.hasInstance](H) {
      return H && H[N] === !0;
    }
    [N] = !0;
  }
  const M = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_NOT_SUPPORTED");
  class k extends e {
    constructor(H) {
      super(H), this.name = "NotSupportedError", this.message = H || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
    }
    static [Symbol.hasInstance](H) {
      return H && H[M] === !0;
    }
    [M] = !0;
  }
  const F = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_BPL_MISSING_UPSTREAM");
  class P extends e {
    constructor(H) {
      super(H), this.name = "MissingUpstreamError", this.message = H || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
    static [Symbol.hasInstance](H) {
      return H && H[F] === !0;
    }
    [F] = !0;
  }
  const J = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_HTTP_PARSER");
  class te extends Error {
    constructor(H, W, z) {
      super(H), this.name = "HTTPParserError", this.code = W ? `HPE_${W}` : void 0, this.data = z ? z.toString() : void 0;
    }
    static [Symbol.hasInstance](H) {
      return H && H[J] === !0;
    }
    [J] = !0;
  }
  const ee = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_RES_EXCEEDED_MAX_SIZE");
  class de extends e {
    constructor(H) {
      super(H), this.name = "ResponseExceededMaxSizeError", this.message = H || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
    static [Symbol.hasInstance](H) {
      return H && H[ee] === !0;
    }
    [ee] = !0;
  }
  const ue = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_REQ_RETRY");
  class ce extends e {
    constructor(H, W, { headers: z, data: $ }) {
      super(H), this.name = "RequestRetryError", this.message = H || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = W, this.data = $, this.headers = z;
    }
    static [Symbol.hasInstance](H) {
      return H && H[ue] === !0;
    }
    [ue] = !0;
  }
  const fe = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_RESPONSE");
  class Ce extends e {
    constructor(H, W, { headers: z, data: $ }) {
      super(H), this.name = "ResponseError", this.message = H || "Response error", this.code = "UND_ERR_RESPONSE", this.statusCode = W, this.data = $, this.headers = z;
    }
    static [Symbol.hasInstance](H) {
      return H && H[fe] === !0;
    }
    [fe] = !0;
  }
  const Z = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_PRX_TLS");
  class _ extends e {
    constructor(H, W, z) {
      super(W, { cause: H, ...z ?? {} }), this.name = "SecureProxyConnectionError", this.message = W || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = H;
    }
    static [Symbol.hasInstance](H) {
      return H && H[Z] === !0;
    }
    [Z] = !0;
  }
  return Vo = {
    AbortError: y,
    HTTPParserError: te,
    UndiciError: e,
    HeadersTimeoutError: i,
    HeadersOverflowError: a,
    BodyTimeoutError: c,
    RequestContentLengthMismatchError: I,
    ConnectTimeoutError: n,
    ResponseStatusCodeError: d,
    InvalidArgumentError: m,
    InvalidReturnValueError: f,
    RequestAbortedError: R,
    ClientDestroyedError: Q,
    ClientClosedError: b,
    InformationalError: L,
    SocketError: S,
    NotSupportedError: k,
    ResponseContentLengthMismatchError: g,
    BalancedPoolMissingUpstreamError: P,
    ResponseExceededMaxSizeError: de,
    RequestRetryError: ce,
    ResponseError: Ce,
    SecureProxyConnectionError: _
  }, Vo;
}
var _o, Md;
function Bl() {
  if (Md) return _o;
  Md = 1;
  const t = {}, e = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let r = 0; r < e.length; ++r) {
    const n = e[r], s = n.toLowerCase();
    t[n] = t[s] = s;
  }
  return Object.setPrototypeOf(t, null), _o = {
    wellknownHeaderNames: e,
    headerNameLowerCasedRecord: t
  }, _o;
}
var Wo, Td;
function Dy() {
  if (Td) return Wo;
  Td = 1;
  const {
    wellknownHeaderNames: t,
    headerNameLowerCasedRecord: e
  } = Bl();
  class r {
    /** @type {any} */
    value = null;
    /** @type {null | TstNode} */
    left = null;
    /** @type {null | TstNode} */
    middle = null;
    /** @type {null | TstNode} */
    right = null;
    /** @type {number} */
    code;
    /**
     * @param {string} key
     * @param {any} value
     * @param {number} index
     */
    constructor(o, a, A) {
      if (A === void 0 || A >= o.length)
        throw new TypeError("Unreachable");
      if ((this.code = o.charCodeAt(A)) > 127)
        throw new TypeError("key must be ascii string");
      o.length !== ++A ? this.middle = new r(o, a, A) : this.value = a;
    }
    /**
     * @param {string} key
     * @param {any} value
     */
    add(o, a) {
      const A = o.length;
      if (A === 0)
        throw new TypeError("Unreachable");
      let c = 0, l = this;
      for (; ; ) {
        const d = o.charCodeAt(c);
        if (d > 127)
          throw new TypeError("key must be ascii string");
        if (l.code === d)
          if (A === ++c) {
            l.value = a;
            break;
          } else if (l.middle !== null)
            l = l.middle;
          else {
            l.middle = new r(o, a, c);
            break;
          }
        else if (l.code < d)
          if (l.left !== null)
            l = l.left;
          else {
            l.left = new r(o, a, c);
            break;
          }
        else if (l.right !== null)
          l = l.right;
        else {
          l.right = new r(o, a, c);
          break;
        }
      }
    }
    /**
     * @param {Uint8Array} key
     * @return {TstNode | null}
     */
    search(o) {
      const a = o.length;
      let A = 0, c = this;
      for (; c !== null && A < a; ) {
        let l = o[A];
        for (l <= 90 && l >= 65 && (l |= 32); c !== null; ) {
          if (l === c.code) {
            if (a === ++A)
              return c;
            c = c.middle;
            break;
          }
          c = c.code < l ? c.left : c.right;
        }
      }
      return null;
    }
  }
  class n {
    /** @type {TstNode | null} */
    node = null;
    /**
     * @param {string} key
     * @param {any} value
     * */
    insert(o, a) {
      this.node === null ? this.node = new r(o, a, 0) : this.node.add(o, a);
    }
    /**
     * @param {Uint8Array} key
     * @return {any}
     */
    lookup(o) {
      return this.node?.search(o)?.value ?? null;
    }
  }
  const s = new n();
  for (let i = 0; i < t.length; ++i) {
    const o = e[t[i]];
    s.insert(o, o);
  }
  return Wo = {
    TernarySearchTree: n,
    tree: s
  }, Wo;
}
var $o, Fd;
function Xe() {
  if (Fd) return $o;
  Fd = 1;
  const t = lt, { kDestroyed: e, kBodyUsed: r, kListeners: n, kBody: s } = gt(), { IncomingMessage: i } = Bn, o = dr, a = Xi, { Blob: A } = ur, c = _t, { stringify: l } = Ay, { EventEmitter: d } = Vs, { InvalidArgumentError: u } = it(), { headerNameLowerCasedRecord: m } = Bl(), { tree: h } = Dy(), [f, p] = process.versions.node.split(".").map((T) => Number(T));
  class y {
    constructor(X) {
      this[s] = X, this[r] = !1;
    }
    async *[Symbol.asyncIterator]() {
      t(!this[r], "disturbed"), this[r] = !0, yield* this[s];
    }
  }
  function w(T) {
    return D(T) ? (M(T) === 0 && T.on("data", function() {
      t(!1);
    }), typeof T.readableDidRead != "boolean" && (T[r] = !1, d.prototype.on.call(T, "data", function() {
      this[r] = !0;
    })), T) : T && typeof T.pipeTo == "function" ? new y(T) : T && typeof T != "string" && !ArrayBuffer.isView(T) && S(T) ? new y(T) : T;
  }
  function R() {
  }
  function D(T) {
    return T && typeof T == "object" && typeof T.pipe == "function" && typeof T.on == "function";
  }
  function L(T) {
    if (T === null)
      return !1;
    if (T instanceof A)
      return !0;
    if (typeof T != "object")
      return !1;
    {
      const X = T[Symbol.toStringTag];
      return (X === "Blob" || X === "File") && ("stream" in T && typeof T.stream == "function" || "arrayBuffer" in T && typeof T.arrayBuffer == "function");
    }
  }
  function C(T, X) {
    if (T.includes("?") || T.includes("#"))
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    const he = l(X);
    return he && (T += "?" + he), T;
  }
  function I(T) {
    const X = parseInt(T, 10);
    return X === Number(T) && X >= 0 && X <= 65535;
  }
  function x(T) {
    return T != null && T[0] === "h" && T[1] === "t" && T[2] === "t" && T[3] === "p" && (T[4] === ":" || T[4] === "s" && T[5] === ":");
  }
  function g(T) {
    if (typeof T == "string") {
      if (T = new URL(T), !x(T.origin || T.protocol))
        throw new u("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      return T;
    }
    if (!T || typeof T != "object")
      throw new u("Invalid URL: The URL argument must be a non-null object.");
    if (!(T instanceof URL)) {
      if (T.port != null && T.port !== "" && I(T.port) === !1)
        throw new u("Invalid URL: port must be a valid integer or a string representation of an integer.");
      if (T.path != null && typeof T.path != "string")
        throw new u("Invalid URL path: the path must be a string or null/undefined.");
      if (T.pathname != null && typeof T.pathname != "string")
        throw new u("Invalid URL pathname: the pathname must be a string or null/undefined.");
      if (T.hostname != null && typeof T.hostname != "string")
        throw new u("Invalid URL hostname: the hostname must be a string or null/undefined.");
      if (T.origin != null && typeof T.origin != "string")
        throw new u("Invalid URL origin: the origin must be a string or null/undefined.");
      if (!x(T.origin || T.protocol))
        throw new u("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      const X = T.port != null ? T.port : T.protocol === "https:" ? 443 : 80;
      let he = T.origin != null ? T.origin : `${T.protocol || ""}//${T.hostname || ""}:${X}`, Ee = T.path != null ? T.path : `${T.pathname || ""}${T.search || ""}`;
      return he[he.length - 1] === "/" && (he = he.slice(0, he.length - 1)), Ee && Ee[0] !== "/" && (Ee = `/${Ee}`), new URL(`${he}${Ee}`);
    }
    if (!x(T.origin || T.protocol))
      throw new u("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    return T;
  }
  function B(T) {
    if (T = g(T), T.pathname !== "/" || T.search || T.hash)
      throw new u("invalid url");
    return T;
  }
  function Q(T) {
    if (T[0] === "[") {
      const he = T.indexOf("]");
      return t(he !== -1), T.substring(1, he);
    }
    const X = T.indexOf(":");
    return X === -1 ? T : T.substring(0, X);
  }
  function E(T) {
    if (!T)
      return null;
    t(typeof T == "string");
    const X = Q(T);
    return a.isIP(X) ? "" : X;
  }
  function b(T) {
    return JSON.parse(JSON.stringify(T));
  }
  function N(T) {
    return T != null && typeof T[Symbol.asyncIterator] == "function";
  }
  function S(T) {
    return T != null && (typeof T[Symbol.iterator] == "function" || typeof T[Symbol.asyncIterator] == "function");
  }
  function M(T) {
    if (T == null)
      return 0;
    if (D(T)) {
      const X = T._readableState;
      return X && X.objectMode === !1 && X.ended === !0 && Number.isFinite(X.length) ? X.length : null;
    } else {
      if (L(T))
        return T.size != null ? T.size : null;
      if (ce(T))
        return T.byteLength;
    }
    return null;
  }
  function k(T) {
    return T && !!(T.destroyed || T[e] || o.isDestroyed?.(T));
  }
  function F(T, X) {
    T == null || !D(T) || k(T) || (typeof T.destroy == "function" ? (Object.getPrototypeOf(T).constructor === i && (T.socket = null), T.destroy(X)) : X && queueMicrotask(() => {
      T.emit("error", X);
    }), T.destroyed !== !0 && (T[e] = !0));
  }
  const P = /timeout=(\d+)/;
  function J(T) {
    const X = T.toString().match(P);
    return X ? parseInt(X[1], 10) * 1e3 : null;
  }
  function te(T) {
    return typeof T == "string" ? m[T] ?? T.toLowerCase() : h.lookup(T) ?? T.toString("latin1").toLowerCase();
  }
  function ee(T) {
    return h.lookup(T) ?? T.toString("latin1").toLowerCase();
  }
  function de(T, X) {
    X === void 0 && (X = {});
    for (let he = 0; he < T.length; he += 2) {
      const Ee = te(T[he]);
      let be = X[Ee];
      if (be)
        typeof be == "string" && (be = [be], X[Ee] = be), be.push(T[he + 1].toString("utf8"));
      else {
        const Le = T[he + 1];
        typeof Le == "string" ? X[Ee] = Le : X[Ee] = Array.isArray(Le) ? Le.map((st) => st.toString("utf8")) : Le.toString("utf8");
      }
    }
    return "content-length" in X && "content-disposition" in X && (X["content-disposition"] = Buffer.from(X["content-disposition"]).toString("latin1")), X;
  }
  function ue(T) {
    const X = T.length, he = new Array(X);
    let Ee = !1, be = -1, Le, st, Bt = 0;
    for (let wt = 0; wt < T.length; wt += 2)
      Le = T[wt], st = T[wt + 1], typeof Le != "string" && (Le = Le.toString()), typeof st != "string" && (st = st.toString("utf8")), Bt = Le.length, Bt === 14 && Le[7] === "-" && (Le === "content-length" || Le.toLowerCase() === "content-length") ? Ee = !0 : Bt === 19 && Le[7] === "-" && (Le === "content-disposition" || Le.toLowerCase() === "content-disposition") && (be = wt + 1), he[wt] = Le, he[wt + 1] = st;
    return Ee && be !== -1 && (he[be] = Buffer.from(he[be]).toString("latin1")), he;
  }
  function ce(T) {
    return T instanceof Uint8Array || Buffer.isBuffer(T);
  }
  function fe(T, X, he) {
    if (!T || typeof T != "object")
      throw new u("handler must be an object");
    if (typeof T.onConnect != "function")
      throw new u("invalid onConnect method");
    if (typeof T.onError != "function")
      throw new u("invalid onError method");
    if (typeof T.onBodySent != "function" && T.onBodySent !== void 0)
      throw new u("invalid onBodySent method");
    if (he || X === "CONNECT") {
      if (typeof T.onUpgrade != "function")
        throw new u("invalid onUpgrade method");
    } else {
      if (typeof T.onHeaders != "function")
        throw new u("invalid onHeaders method");
      if (typeof T.onData != "function")
        throw new u("invalid onData method");
      if (typeof T.onComplete != "function")
        throw new u("invalid onComplete method");
    }
  }
  function Ce(T) {
    return !!(T && (o.isDisturbed(T) || T[r]));
  }
  function Z(T) {
    return !!(T && o.isErrored(T));
  }
  function _(T) {
    return !!(T && o.isReadable(T));
  }
  function ne(T) {
    return {
      localAddress: T.localAddress,
      localPort: T.localPort,
      remoteAddress: T.remoteAddress,
      remotePort: T.remotePort,
      remoteFamily: T.remoteFamily,
      timeout: T.timeout,
      bytesWritten: T.bytesWritten,
      bytesRead: T.bytesRead
    };
  }
  function H(T) {
    let X;
    return new ReadableStream(
      {
        async start() {
          X = T[Symbol.asyncIterator]();
        },
        async pull(he) {
          const { done: Ee, value: be } = await X.next();
          if (Ee)
            queueMicrotask(() => {
              he.close(), he.byobRequest?.respond(0);
            });
          else {
            const Le = Buffer.isBuffer(be) ? be : Buffer.from(be);
            Le.byteLength && he.enqueue(new Uint8Array(Le));
          }
          return he.desiredSize > 0;
        },
        async cancel(he) {
          await X.return();
        },
        type: "bytes"
      }
    );
  }
  function W(T) {
    return T && typeof T == "object" && typeof T.append == "function" && typeof T.delete == "function" && typeof T.get == "function" && typeof T.getAll == "function" && typeof T.has == "function" && typeof T.set == "function" && T[Symbol.toStringTag] === "FormData";
  }
  function z(T, X) {
    return "addEventListener" in T ? (T.addEventListener("abort", X, { once: !0 }), () => T.removeEventListener("abort", X)) : (T.addListener("abort", X), () => T.removeListener("abort", X));
  }
  const $ = typeof String.prototype.toWellFormed == "function", Ae = typeof String.prototype.isWellFormed == "function";
  function pe(T) {
    return $ ? `${T}`.toWellFormed() : c.toUSVString(T);
  }
  function me(T) {
    return Ae ? `${T}`.isWellFormed() : pe(T) === `${T}`;
  }
  function xe(T) {
    switch (T) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return !1;
      default:
        return T >= 33 && T <= 126;
    }
  }
  function _e(T) {
    if (T.length === 0)
      return !1;
    for (let X = 0; X < T.length; ++X)
      if (!xe(T.charCodeAt(X)))
        return !1;
    return !0;
  }
  const ke = /[^\t\x20-\x7e\x80-\xff]/;
  function We(T) {
    return !ke.test(T);
  }
  function ve(T) {
    if (T == null || T === "") return { start: 0, end: null, size: null };
    const X = T ? T.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return X ? {
      start: parseInt(X[1]),
      end: X[2] ? parseInt(X[2]) : null,
      size: X[3] ? parseInt(X[3]) : null
    } : null;
  }
  function He(T, X, he) {
    return (T[n] ??= []).push([X, he]), T.on(X, he), T;
  }
  function Re(T) {
    for (const [X, he] of T[n] ?? [])
      T.removeListener(X, he);
    T[n] = null;
  }
  function ut(T, X, he) {
    try {
      X.onError(he), t(X.aborted);
    } catch (Ee) {
      T.emit("error", Ee);
    }
  }
  const At = /* @__PURE__ */ Object.create(null);
  At.enumerable = !0;
  const rt = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  }, re = {
    ...rt,
    patch: "patch",
    PATCH: "PATCH"
  };
  return Object.setPrototypeOf(rt, null), Object.setPrototypeOf(re, null), $o = {
    kEnumerableProperty: At,
    nop: R,
    isDisturbed: Ce,
    isErrored: Z,
    isReadable: _,
    toUSVString: pe,
    isUSVString: me,
    isBlobLike: L,
    parseOrigin: B,
    parseURL: g,
    getServerName: E,
    isStream: D,
    isIterable: S,
    isAsyncIterable: N,
    isDestroyed: k,
    headerNameToString: te,
    bufferToLowerCasedHeaderName: ee,
    addListener: He,
    removeAllListeners: Re,
    errorRequest: ut,
    parseRawHeaders: ue,
    parseHeaders: de,
    parseKeepAliveTimeout: J,
    destroy: F,
    bodyLength: M,
    deepClone: b,
    ReadableStreamFrom: H,
    isBuffer: ce,
    validateHandler: fe,
    getSocketInfo: ne,
    isFormDataLike: W,
    buildURL: C,
    addAbortListener: z,
    isValidHTTPToken: _e,
    isValidHeaderValue: We,
    isTokenCharCode: xe,
    parseRangeHeader: ve,
    normalizedMethodRecordsBase: rt,
    normalizedMethodRecords: re,
    isValidPort: I,
    isHttpOrHttpsPrefixed: x,
    nodeMajor: f,
    nodeMinor: p,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    wrapRequestBody: w
  }, $o;
}
var Xo, vd;
function Ws() {
  if (vd) return Xo;
  vd = 1;
  const t = cy, e = _t, r = e.debuglog("undici"), n = e.debuglog("fetch"), s = e.debuglog("websocket");
  let i = !1;
  const o = {
    // Client
    beforeConnect: t.channel("undici:client:beforeConnect"),
    connected: t.channel("undici:client:connected"),
    connectError: t.channel("undici:client:connectError"),
    sendHeaders: t.channel("undici:client:sendHeaders"),
    // Request
    create: t.channel("undici:request:create"),
    bodySent: t.channel("undici:request:bodySent"),
    headers: t.channel("undici:request:headers"),
    trailers: t.channel("undici:request:trailers"),
    error: t.channel("undici:request:error"),
    // WebSocket
    open: t.channel("undici:websocket:open"),
    close: t.channel("undici:websocket:close"),
    socketError: t.channel("undici:websocket:socket_error"),
    ping: t.channel("undici:websocket:ping"),
    pong: t.channel("undici:websocket:pong")
  };
  if (r.enabled || n.enabled) {
    const a = n.enabled ? n : r;
    t.channel("undici:client:beforeConnect").subscribe((A) => {
      const {
        connectParams: { version: c, protocol: l, port: d, host: u }
      } = A;
      a(
        "connecting to %s using %s%s",
        `${u}${d ? `:${d}` : ""}`,
        l,
        c
      );
    }), t.channel("undici:client:connected").subscribe((A) => {
      const {
        connectParams: { version: c, protocol: l, port: d, host: u }
      } = A;
      a(
        "connected to %s using %s%s",
        `${u}${d ? `:${d}` : ""}`,
        l,
        c
      );
    }), t.channel("undici:client:connectError").subscribe((A) => {
      const {
        connectParams: { version: c, protocol: l, port: d, host: u },
        error: m
      } = A;
      a(
        "connection to %s using %s%s errored - %s",
        `${u}${d ? `:${d}` : ""}`,
        l,
        c,
        m.message
      );
    }), t.channel("undici:client:sendHeaders").subscribe((A) => {
      const {
        request: { method: c, path: l, origin: d }
      } = A;
      a("sending request to %s %s/%s", c, d, l);
    }), t.channel("undici:request:headers").subscribe((A) => {
      const {
        request: { method: c, path: l, origin: d },
        response: { statusCode: u }
      } = A;
      a(
        "received response to %s %s/%s - HTTP %d",
        c,
        d,
        l,
        u
      );
    }), t.channel("undici:request:trailers").subscribe((A) => {
      const {
        request: { method: c, path: l, origin: d }
      } = A;
      a("trailers received from %s %s/%s", c, d, l);
    }), t.channel("undici:request:error").subscribe((A) => {
      const {
        request: { method: c, path: l, origin: d },
        error: u
      } = A;
      a(
        "request to %s %s/%s errored - %s",
        c,
        d,
        l,
        u.message
      );
    }), i = !0;
  }
  if (s.enabled) {
    if (!i) {
      const a = r.enabled ? r : s;
      t.channel("undici:client:beforeConnect").subscribe((A) => {
        const {
          connectParams: { version: c, protocol: l, port: d, host: u }
        } = A;
        a(
          "connecting to %s%s using %s%s",
          u,
          d ? `:${d}` : "",
          l,
          c
        );
      }), t.channel("undici:client:connected").subscribe((A) => {
        const {
          connectParams: { version: c, protocol: l, port: d, host: u }
        } = A;
        a(
          "connected to %s%s using %s%s",
          u,
          d ? `:${d}` : "",
          l,
          c
        );
      }), t.channel("undici:client:connectError").subscribe((A) => {
        const {
          connectParams: { version: c, protocol: l, port: d, host: u },
          error: m
        } = A;
        a(
          "connection to %s%s using %s%s errored - %s",
          u,
          d ? `:${d}` : "",
          l,
          c,
          m.message
        );
      }), t.channel("undici:client:sendHeaders").subscribe((A) => {
        const {
          request: { method: c, path: l, origin: d }
        } = A;
        a("sending request to %s %s/%s", c, d, l);
      });
    }
    t.channel("undici:websocket:open").subscribe((a) => {
      const {
        address: { address: A, port: c }
      } = a;
      s("connection opened %s%s", A, c ? `:${c}` : "");
    }), t.channel("undici:websocket:close").subscribe((a) => {
      const { websocket: A, code: c, reason: l } = a;
      s(
        "closed connection to %s - %s %s",
        A.url,
        c,
        l
      );
    }), t.channel("undici:websocket:socket_error").subscribe((a) => {
      s("connection errored - %s", a.message);
    }), t.channel("undici:websocket:ping").subscribe((a) => {
      s("ping received");
    }), t.channel("undici:websocket:pong").subscribe((a) => {
      s("pong received");
    });
  }
  return Xo = {
    channels: o
  }, Xo;
}
var Zo, Ld;
function ky() {
  if (Ld) return Zo;
  Ld = 1;
  const {
    InvalidArgumentError: t,
    NotSupportedError: e
  } = it(), r = lt, {
    isValidHTTPToken: n,
    isValidHeaderValue: s,
    isStream: i,
    destroy: o,
    isBuffer: a,
    isFormDataLike: A,
    isIterable: c,
    isBlobLike: l,
    buildURL: d,
    validateHandler: u,
    getServerName: m,
    normalizedMethodRecords: h
  } = Xe(), { channels: f } = Ws(), { headerNameLowerCasedRecord: p } = Bl(), y = /[^\u0021-\u00ff]/, w = /* @__PURE__ */ Symbol("handler");
  class R {
    constructor(C, {
      path: I,
      method: x,
      body: g,
      headers: B,
      query: Q,
      idempotent: E,
      blocking: b,
      upgrade: N,
      headersTimeout: S,
      bodyTimeout: M,
      reset: k,
      throwOnError: F,
      expectContinue: P,
      servername: J
    }, te) {
      if (typeof I != "string")
        throw new t("path must be a string");
      if (I[0] !== "/" && !(I.startsWith("http://") || I.startsWith("https://")) && x !== "CONNECT")
        throw new t("path must be an absolute URL or start with a slash");
      if (y.test(I))
        throw new t("invalid request path");
      if (typeof x != "string")
        throw new t("method must be a string");
      if (h[x] === void 0 && !n(x))
        throw new t("invalid request method");
      if (N && typeof N != "string")
        throw new t("upgrade must be a string");
      if (S != null && (!Number.isFinite(S) || S < 0))
        throw new t("invalid headersTimeout");
      if (M != null && (!Number.isFinite(M) || M < 0))
        throw new t("invalid bodyTimeout");
      if (k != null && typeof k != "boolean")
        throw new t("invalid reset");
      if (P != null && typeof P != "boolean")
        throw new t("invalid expectContinue");
      if (this.headersTimeout = S, this.bodyTimeout = M, this.throwOnError = F === !0, this.method = x, this.abort = null, g == null)
        this.body = null;
      else if (i(g)) {
        this.body = g;
        const ee = this.body._readableState;
        (!ee || !ee.autoDestroy) && (this.endHandler = function() {
          o(this);
        }, this.body.on("end", this.endHandler)), this.errorHandler = (de) => {
          this.abort ? this.abort(de) : this.error = de;
        }, this.body.on("error", this.errorHandler);
      } else if (a(g))
        this.body = g.byteLength ? g : null;
      else if (ArrayBuffer.isView(g))
        this.body = g.buffer.byteLength ? Buffer.from(g.buffer, g.byteOffset, g.byteLength) : null;
      else if (g instanceof ArrayBuffer)
        this.body = g.byteLength ? Buffer.from(g) : null;
      else if (typeof g == "string")
        this.body = g.length ? Buffer.from(g) : null;
      else if (A(g) || c(g) || l(g))
        this.body = g;
      else
        throw new t("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      if (this.completed = !1, this.aborted = !1, this.upgrade = N || null, this.path = Q ? d(I, Q) : I, this.origin = C, this.idempotent = E ?? (x === "HEAD" || x === "GET"), this.blocking = b ?? !1, this.reset = k ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = P ?? !1, Array.isArray(B)) {
        if (B.length % 2 !== 0)
          throw new t("headers array must be even");
        for (let ee = 0; ee < B.length; ee += 2)
          D(this, B[ee], B[ee + 1]);
      } else if (B && typeof B == "object")
        if (B[Symbol.iterator])
          for (const ee of B) {
            if (!Array.isArray(ee) || ee.length !== 2)
              throw new t("headers must be in key-value pair format");
            D(this, ee[0], ee[1]);
          }
        else {
          const ee = Object.keys(B);
          for (let de = 0; de < ee.length; ++de)
            D(this, ee[de], B[ee[de]]);
        }
      else if (B != null)
        throw new t("headers must be an object or an array");
      u(te, x, N), this.servername = J || m(this.host), this[w] = te, f.create.hasSubscribers && f.create.publish({ request: this });
    }
    onBodySent(C) {
      if (this[w].onBodySent)
        try {
          return this[w].onBodySent(C);
        } catch (I) {
          this.abort(I);
        }
    }
    onRequestSent() {
      if (f.bodySent.hasSubscribers && f.bodySent.publish({ request: this }), this[w].onRequestSent)
        try {
          return this[w].onRequestSent();
        } catch (C) {
          this.abort(C);
        }
    }
    onConnect(C) {
      if (r(!this.aborted), r(!this.completed), this.error)
        C(this.error);
      else
        return this.abort = C, this[w].onConnect(C);
    }
    onResponseStarted() {
      return this[w].onResponseStarted?.();
    }
    onHeaders(C, I, x, g) {
      r(!this.aborted), r(!this.completed), f.headers.hasSubscribers && f.headers.publish({ request: this, response: { statusCode: C, headers: I, statusText: g } });
      try {
        return this[w].onHeaders(C, I, x, g);
      } catch (B) {
        this.abort(B);
      }
    }
    onData(C) {
      r(!this.aborted), r(!this.completed);
      try {
        return this[w].onData(C);
      } catch (I) {
        return this.abort(I), !1;
      }
    }
    onUpgrade(C, I, x) {
      return r(!this.aborted), r(!this.completed), this[w].onUpgrade(C, I, x);
    }
    onComplete(C) {
      this.onFinally(), r(!this.aborted), this.completed = !0, f.trailers.hasSubscribers && f.trailers.publish({ request: this, trailers: C });
      try {
        return this[w].onComplete(C);
      } catch (I) {
        this.onError(I);
      }
    }
    onError(C) {
      if (this.onFinally(), f.error.hasSubscribers && f.error.publish({ request: this, error: C }), !this.aborted)
        return this.aborted = !0, this[w].onError(C);
    }
    onFinally() {
      this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
    }
    addHeader(C, I) {
      return D(this, C, I), this;
    }
  }
  function D(L, C, I) {
    if (I && typeof I == "object" && !Array.isArray(I))
      throw new t(`invalid ${C} header`);
    if (I === void 0)
      return;
    let x = p[C];
    if (x === void 0 && (x = C.toLowerCase(), p[x] === void 0 && !n(x)))
      throw new t("invalid header key");
    if (Array.isArray(I)) {
      const g = [];
      for (let B = 0; B < I.length; B++)
        if (typeof I[B] == "string") {
          if (!s(I[B]))
            throw new t(`invalid ${C} header`);
          g.push(I[B]);
        } else if (I[B] === null)
          g.push("");
        else {
          if (typeof I[B] == "object")
            throw new t(`invalid ${C} header`);
          g.push(`${I[B]}`);
        }
      I = g;
    } else if (typeof I == "string") {
      if (!s(I))
        throw new t(`invalid ${C} header`);
    } else I === null ? I = "" : I = `${I}`;
    if (L.host === null && x === "host") {
      if (typeof I != "string")
        throw new t("invalid host header");
      L.host = I;
    } else if (L.contentLength === null && x === "content-length") {
      if (L.contentLength = parseInt(I, 10), !Number.isFinite(L.contentLength))
        throw new t("invalid content-length header");
    } else if (L.contentType === null && x === "content-type")
      L.contentType = I, L.headers.push(C, I);
    else {
      if (x === "transfer-encoding" || x === "keep-alive" || x === "upgrade")
        throw new t(`invalid ${x} header`);
      if (x === "connection") {
        const g = typeof I == "string" ? I.toLowerCase() : null;
        if (g !== "close" && g !== "keep-alive")
          throw new t("invalid connection header");
        g === "close" && (L.reset = !0);
      } else {
        if (x === "expect")
          throw new e("expect header not supported");
        L.headers.push(C, I);
      }
    }
  }
  return Zo = R, Zo;
}
var Ko, Ud;
function Zi() {
  if (Ud) return Ko;
  Ud = 1;
  const t = Vs;
  class e extends t {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...s) {
      const i = Array.isArray(s[0]) ? s[0] : s;
      let o = this.dispatch.bind(this);
      for (const a of i)
        if (a != null) {
          if (typeof a != "function")
            throw new TypeError(`invalid interceptor, expected function received ${typeof a}`);
          if (o = a(o), o == null || typeof o != "function" || o.length !== 2)
            throw new TypeError("invalid interceptor");
        }
      return new r(this, o);
    }
  }
  class r extends e {
    #e = null;
    #t = null;
    constructor(s, i) {
      super(), this.#e = s, this.#t = i;
    }
    dispatch(...s) {
      this.#t(...s);
    }
    close(...s) {
      return this.#e.close(...s);
    }
    destroy(...s) {
      return this.#e.destroy(...s);
    }
  }
  return Ko = e, Ko;
}
var jo, Pd;
function $s() {
  if (Pd) return jo;
  Pd = 1;
  const t = Zi(), {
    ClientDestroyedError: e,
    ClientClosedError: r,
    InvalidArgumentError: n
  } = it(), { kDestroy: s, kClose: i, kClosed: o, kDestroyed: a, kDispatch: A, kInterceptors: c } = gt(), l = /* @__PURE__ */ Symbol("onDestroyed"), d = /* @__PURE__ */ Symbol("onClosed"), u = /* @__PURE__ */ Symbol("Intercepted Dispatch");
  class m extends t {
    constructor() {
      super(), this[a] = !1, this[l] = null, this[o] = !1, this[d] = [];
    }
    get destroyed() {
      return this[a];
    }
    get closed() {
      return this[o];
    }
    get interceptors() {
      return this[c];
    }
    set interceptors(f) {
      if (f) {
        for (let p = f.length - 1; p >= 0; p--)
          if (typeof this[c][p] != "function")
            throw new n("interceptor must be an function");
      }
      this[c] = f;
    }
    close(f) {
      if (f === void 0)
        return new Promise((y, w) => {
          this.close((R, D) => R ? w(R) : y(D));
        });
      if (typeof f != "function")
        throw new n("invalid callback");
      if (this[a]) {
        queueMicrotask(() => f(new e(), null));
        return;
      }
      if (this[o]) {
        this[d] ? this[d].push(f) : queueMicrotask(() => f(null, null));
        return;
      }
      this[o] = !0, this[d].push(f);
      const p = () => {
        const y = this[d];
        this[d] = null;
        for (let w = 0; w < y.length; w++)
          y[w](null, null);
      };
      this[i]().then(() => this.destroy()).then(() => {
        queueMicrotask(p);
      });
    }
    destroy(f, p) {
      if (typeof f == "function" && (p = f, f = null), p === void 0)
        return new Promise((w, R) => {
          this.destroy(f, (D, L) => D ? (
            /* istanbul ignore next: should never error */
            R(D)
          ) : w(L));
        });
      if (typeof p != "function")
        throw new n("invalid callback");
      if (this[a]) {
        this[l] ? this[l].push(p) : queueMicrotask(() => p(null, null));
        return;
      }
      f || (f = new e()), this[a] = !0, this[l] = this[l] || [], this[l].push(p);
      const y = () => {
        const w = this[l];
        this[l] = null;
        for (let R = 0; R < w.length; R++)
          w[R](null, null);
      };
      this[s](f).then(() => {
        queueMicrotask(y);
      });
    }
    [u](f, p) {
      if (!this[c] || this[c].length === 0)
        return this[u] = this[A], this[A](f, p);
      let y = this[A].bind(this);
      for (let w = this[c].length - 1; w >= 0; w--)
        y = this[c][w](y);
      return this[u] = y, y(f, p);
    }
    dispatch(f, p) {
      if (!p || typeof p != "object")
        throw new n("handler must be an object");
      try {
        if (!f || typeof f != "object")
          throw new n("opts must be an object.");
        if (this[a] || this[l])
          throw new e();
        if (this[o])
          throw new r();
        return this[u](f, p);
      } catch (y) {
        if (typeof p.onError != "function")
          throw new n("invalid onError method");
        return p.onError(y), !1;
      }
    }
  }
  return jo = m, jo;
}
var ea, Hd;
function rf() {
  if (Hd) return ea;
  Hd = 1;
  let t = 0;
  const e = 1e3, r = (e >> 1) - 1;
  let n;
  const s = /* @__PURE__ */ Symbol("kFastTimer"), i = [], o = -2, a = -1, A = 0, c = 1;
  function l() {
    t += r;
    let m = 0, h = i.length;
    for (; m < h; ) {
      const f = i[m];
      f._state === A ? (f._idleStart = t - r, f._state = c) : f._state === c && t >= f._idleStart + f._idleTimeout && (f._state = a, f._idleStart = -1, f._onTimeout(f._timerArg)), f._state === a ? (f._state = o, --h !== 0 && (i[m] = i[h])) : ++m;
    }
    i.length = h, i.length !== 0 && d();
  }
  function d() {
    n ? n.refresh() : (clearTimeout(n), n = setTimeout(l, r), n.unref && n.unref());
  }
  class u {
    [s] = !0;
    /**
     * The state of the timer, which can be one of the following:
     * - NOT_IN_LIST (-2)
     * - TO_BE_CLEARED (-1)
     * - PENDING (0)
     * - ACTIVE (1)
     *
     * @type {-2|-1|0|1}
     * @private
     */
    _state = o;
    /**
     * The number of milliseconds to wait before calling the callback.
     *
     * @type {number}
     * @private
     */
    _idleTimeout = -1;
    /**
     * The time in milliseconds when the timer was started. This value is used to
     * calculate when the timer should expire.
     *
     * @type {number}
     * @default -1
     * @private
     */
    _idleStart = -1;
    /**
     * The function to be executed when the timer expires.
     * @type {Function}
     * @private
     */
    _onTimeout;
    /**
     * The argument to be passed to the callback when the timer expires.
     *
     * @type {*}
     * @private
     */
    _timerArg;
    /**
     * @constructor
     * @param {Function} callback A function to be executed after the timer
     * expires.
     * @param {number} delay The time, in milliseconds that the timer should wait
     * before the specified function or code is executed.
     * @param {*} arg
     */
    constructor(h, f, p) {
      this._onTimeout = h, this._idleTimeout = f, this._timerArg = p, this.refresh();
    }
    /**
     * Sets the timer's start time to the current time, and reschedules the timer
     * to call its callback at the previously specified duration adjusted to the
     * current time.
     * Using this on a timer that has already called its callback will reactivate
     * the timer.
     *
     * @returns {void}
     */
    refresh() {
      this._state === o && i.push(this), (!n || i.length === 1) && d(), this._state = A;
    }
    /**
     * The `clear` method cancels the timer, preventing it from executing.
     *
     * @returns {void}
     * @private
     */
    clear() {
      this._state = a, this._idleStart = -1;
    }
  }
  return ea = {
    /**
     * The setTimeout() method sets a timer which executes a function once the
     * timer expires.
     * @param {Function} callback A function to be executed after the timer
     * expires.
     * @param {number} delay The time, in milliseconds that the timer should
     * wait before the specified function or code is executed.
     * @param {*} [arg] An optional argument to be passed to the callback function
     * when the timer expires.
     * @returns {NodeJS.Timeout|FastTimer}
     */
    setTimeout(m, h, f) {
      return h <= e ? setTimeout(m, h, f) : new u(m, h, f);
    },
    /**
     * The clearTimeout method cancels an instantiated Timer previously created
     * by calling setTimeout.
     *
     * @param {NodeJS.Timeout|FastTimer} timeout
     */
    clearTimeout(m) {
      m[s] ? m.clear() : clearTimeout(m);
    },
    /**
     * The setFastTimeout() method sets a fastTimer which executes a function once
     * the timer expires.
     * @param {Function} callback A function to be executed after the timer
     * expires.
     * @param {number} delay The time, in milliseconds that the timer should
     * wait before the specified function or code is executed.
     * @param {*} [arg] An optional argument to be passed to the callback function
     * when the timer expires.
     * @returns {FastTimer}
     */
    setFastTimeout(m, h, f) {
      return new u(m, h, f);
    },
    /**
     * The clearTimeout method cancels an instantiated FastTimer previously
     * created by calling setFastTimeout.
     *
     * @param {FastTimer} timeout
     */
    clearFastTimeout(m) {
      m.clear();
    },
    /**
     * The now method returns the value of the internal fast timer clock.
     *
     * @returns {number}
     */
    now() {
      return t;
    },
    /**
     * Trigger the onTick function to process the fastTimers array.
     * Exported for testing purposes only.
     * Marking as deprecated to discourage any use outside of testing.
     * @deprecated
     * @param {number} [delay=0] The delay in milliseconds to add to the now value.
     */
    tick(m = 0) {
      t += m - e + 1, l(), l();
    },
    /**
     * Reset FastTimers.
     * Exported for testing purposes only.
     * Marking as deprecated to discourage any use outside of testing.
     * @deprecated
     */
    reset() {
      t = 0, i.length = 0, clearTimeout(n), n = null;
    },
    /**
     * Exporting for testing purposes only.
     * Marking as deprecated to discourage any use outside of testing.
     * @deprecated
     */
    kFastTimer: s
  }, ea;
}
var ta, Od;
function Ki() {
  if (Od) return ta;
  Od = 1;
  const t = Xi, e = lt, r = Xe(), { InvalidArgumentError: n, ConnectTimeoutError: s } = it(), i = rf();
  function o() {
  }
  let a, A;
  xd.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? A = class {
    constructor(m) {
      this._maxCachedSessions = m, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new xd.FinalizationRegistry((h) => {
        if (this._sessionCache.size < this._maxCachedSessions)
          return;
        const f = this._sessionCache.get(h);
        f !== void 0 && f.deref() === void 0 && this._sessionCache.delete(h);
      });
    }
    get(m) {
      const h = this._sessionCache.get(m);
      return h ? h.deref() : null;
    }
    set(m, h) {
      this._maxCachedSessions !== 0 && (this._sessionCache.set(m, new WeakRef(h)), this._sessionRegistry.register(h, m));
    }
  } : A = class {
    constructor(m) {
      this._maxCachedSessions = m, this._sessionCache = /* @__PURE__ */ new Map();
    }
    get(m) {
      return this._sessionCache.get(m);
    }
    set(m, h) {
      if (this._maxCachedSessions !== 0) {
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: f } = this._sessionCache.keys().next();
          this._sessionCache.delete(f);
        }
        this._sessionCache.set(m, h);
      }
    }
  };
  function c({ allowH2: u, maxCachedSessions: m, socketPath: h, timeout: f, session: p, ...y }) {
    if (m != null && (!Number.isInteger(m) || m < 0))
      throw new n("maxCachedSessions must be a positive integer or zero");
    const w = { path: h, ...y }, R = new A(m ?? 100);
    return f = f ?? 1e4, u = u ?? !1, function({ hostname: L, host: C, protocol: I, port: x, servername: g, localAddress: B, httpSocket: Q }, E) {
      let b;
      if (I === "https:") {
        a || (a = ly), g = g || w.servername || r.getServerName(C) || null;
        const S = g || L;
        e(S);
        const M = p || R.get(S) || null;
        x = x || 443, b = a.connect({
          highWaterMark: 16384,
          // TLS in node can't have bigger HWM anyway...
          ...w,
          servername: g,
          session: M,
          localAddress: B,
          // TODO(HTTP/2): Add support for h2c
          ALPNProtocols: u ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: Q,
          // upgrade socket connection
          port: x,
          host: L
        }), b.on("session", function(k) {
          R.set(S, k);
        });
      } else
        e(!Q, "httpSocket can only be sent on TLS update"), x = x || 80, b = t.connect({
          highWaterMark: 64 * 1024,
          // Same as nodejs fs streams.
          ...w,
          localAddress: B,
          port: x,
          host: L
        });
      if (w.keepAlive == null || w.keepAlive) {
        const S = w.keepAliveInitialDelay === void 0 ? 6e4 : w.keepAliveInitialDelay;
        b.setKeepAlive(!0, S);
      }
      const N = l(new WeakRef(b), { timeout: f, hostname: L, port: x });
      return b.setNoDelay(!0).once(I === "https:" ? "secureConnect" : "connect", function() {
        if (queueMicrotask(N), E) {
          const S = E;
          E = null, S(null, this);
        }
      }).on("error", function(S) {
        if (queueMicrotask(N), E) {
          const M = E;
          E = null, M(S);
        }
      }), b;
    };
  }
  const l = process.platform === "win32" ? (u, m) => {
    if (!m.timeout)
      return o;
    let h = null, f = null;
    const p = i.setFastTimeout(() => {
      h = setImmediate(() => {
        f = setImmediate(() => d(u.deref(), m));
      });
    }, m.timeout);
    return () => {
      i.clearFastTimeout(p), clearImmediate(h), clearImmediate(f);
    };
  } : (u, m) => {
    if (!m.timeout)
      return o;
    let h = null;
    const f = i.setFastTimeout(() => {
      h = setImmediate(() => {
        d(u.deref(), m);
      });
    }, m.timeout);
    return () => {
      i.clearFastTimeout(f), clearImmediate(h);
    };
  };
  function d(u, m) {
    if (u == null)
      return;
    let h = "Connect Timeout Error";
    Array.isArray(u.autoSelectFamilyAttemptedAddresses) ? h += ` (attempted addresses: ${u.autoSelectFamilyAttemptedAddresses.join(", ")},` : h += ` (attempted address: ${m.hostname}:${m.port},`, h += ` timeout: ${m.timeout}ms)`, r.destroy(u, new s(h));
  }
  return ta = c, ta;
}
var ra = {}, Ns = {}, zd;
function My() {
  if (zd) return Ns;
  zd = 1, Object.defineProperty(Ns, "__esModule", { value: !0 }), Ns.enumToMap = void 0;
  function t(e) {
    const r = {};
    return Object.keys(e).forEach((n) => {
      const s = e[n];
      typeof s == "number" && (r[n] = s);
    }), r;
  }
  return Ns.enumToMap = t, Ns;
}
var qd;
function Ty() {
  return qd || (qd = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SPECIAL_HEADERS = t.HEADER_STATE = t.MINOR = t.MAJOR = t.CONNECTION_TOKEN_CHARS = t.HEADER_CHARS = t.TOKEN = t.STRICT_TOKEN = t.HEX = t.URL_CHAR = t.STRICT_URL_CHAR = t.USERINFO_CHARS = t.MARK = t.ALPHANUM = t.NUM = t.HEX_MAP = t.NUM_MAP = t.ALPHA = t.FINISH = t.H_METHOD_MAP = t.METHOD_MAP = t.METHODS_RTSP = t.METHODS_ICE = t.METHODS_HTTP = t.METHODS = t.LENIENT_FLAGS = t.FLAGS = t.TYPE = t.ERROR = void 0;
    const e = My();
    (function(s) {
      s[s.OK = 0] = "OK", s[s.INTERNAL = 1] = "INTERNAL", s[s.STRICT = 2] = "STRICT", s[s.LF_EXPECTED = 3] = "LF_EXPECTED", s[s.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", s[s.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", s[s.INVALID_METHOD = 6] = "INVALID_METHOD", s[s.INVALID_URL = 7] = "INVALID_URL", s[s.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", s[s.INVALID_VERSION = 9] = "INVALID_VERSION", s[s.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", s[s.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", s[s.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", s[s.INVALID_STATUS = 13] = "INVALID_STATUS", s[s.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", s[s.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", s[s.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", s[s.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", s[s.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", s[s.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", s[s.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", s[s.PAUSED = 21] = "PAUSED", s[s.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", s[s.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", s[s.USER = 24] = "USER";
    })(t.ERROR || (t.ERROR = {})), (function(s) {
      s[s.BOTH = 0] = "BOTH", s[s.REQUEST = 1] = "REQUEST", s[s.RESPONSE = 2] = "RESPONSE";
    })(t.TYPE || (t.TYPE = {})), (function(s) {
      s[s.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", s[s.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", s[s.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", s[s.CHUNKED = 8] = "CHUNKED", s[s.UPGRADE = 16] = "UPGRADE", s[s.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", s[s.SKIPBODY = 64] = "SKIPBODY", s[s.TRAILING = 128] = "TRAILING", s[s.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
    })(t.FLAGS || (t.FLAGS = {})), (function(s) {
      s[s.HEADERS = 1] = "HEADERS", s[s.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", s[s.KEEP_ALIVE = 4] = "KEEP_ALIVE";
    })(t.LENIENT_FLAGS || (t.LENIENT_FLAGS = {}));
    var r;
    (function(s) {
      s[s.DELETE = 0] = "DELETE", s[s.GET = 1] = "GET", s[s.HEAD = 2] = "HEAD", s[s.POST = 3] = "POST", s[s.PUT = 4] = "PUT", s[s.CONNECT = 5] = "CONNECT", s[s.OPTIONS = 6] = "OPTIONS", s[s.TRACE = 7] = "TRACE", s[s.COPY = 8] = "COPY", s[s.LOCK = 9] = "LOCK", s[s.MKCOL = 10] = "MKCOL", s[s.MOVE = 11] = "MOVE", s[s.PROPFIND = 12] = "PROPFIND", s[s.PROPPATCH = 13] = "PROPPATCH", s[s.SEARCH = 14] = "SEARCH", s[s.UNLOCK = 15] = "UNLOCK", s[s.BIND = 16] = "BIND", s[s.REBIND = 17] = "REBIND", s[s.UNBIND = 18] = "UNBIND", s[s.ACL = 19] = "ACL", s[s.REPORT = 20] = "REPORT", s[s.MKACTIVITY = 21] = "MKACTIVITY", s[s.CHECKOUT = 22] = "CHECKOUT", s[s.MERGE = 23] = "MERGE", s[s["M-SEARCH"] = 24] = "M-SEARCH", s[s.NOTIFY = 25] = "NOTIFY", s[s.SUBSCRIBE = 26] = "SUBSCRIBE", s[s.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", s[s.PATCH = 28] = "PATCH", s[s.PURGE = 29] = "PURGE", s[s.MKCALENDAR = 30] = "MKCALENDAR", s[s.LINK = 31] = "LINK", s[s.UNLINK = 32] = "UNLINK", s[s.SOURCE = 33] = "SOURCE", s[s.PRI = 34] = "PRI", s[s.DESCRIBE = 35] = "DESCRIBE", s[s.ANNOUNCE = 36] = "ANNOUNCE", s[s.SETUP = 37] = "SETUP", s[s.PLAY = 38] = "PLAY", s[s.PAUSE = 39] = "PAUSE", s[s.TEARDOWN = 40] = "TEARDOWN", s[s.GET_PARAMETER = 41] = "GET_PARAMETER", s[s.SET_PARAMETER = 42] = "SET_PARAMETER", s[s.REDIRECT = 43] = "REDIRECT", s[s.RECORD = 44] = "RECORD", s[s.FLUSH = 45] = "FLUSH";
    })(r = t.METHODS || (t.METHODS = {})), t.METHODS_HTTP = [
      r.DELETE,
      r.GET,
      r.HEAD,
      r.POST,
      r.PUT,
      r.CONNECT,
      r.OPTIONS,
      r.TRACE,
      r.COPY,
      r.LOCK,
      r.MKCOL,
      r.MOVE,
      r.PROPFIND,
      r.PROPPATCH,
      r.SEARCH,
      r.UNLOCK,
      r.BIND,
      r.REBIND,
      r.UNBIND,
      r.ACL,
      r.REPORT,
      r.MKACTIVITY,
      r.CHECKOUT,
      r.MERGE,
      r["M-SEARCH"],
      r.NOTIFY,
      r.SUBSCRIBE,
      r.UNSUBSCRIBE,
      r.PATCH,
      r.PURGE,
      r.MKCALENDAR,
      r.LINK,
      r.UNLINK,
      r.PRI,
      // TODO(indutny): should we allow it with HTTP?
      r.SOURCE
    ], t.METHODS_ICE = [
      r.SOURCE
    ], t.METHODS_RTSP = [
      r.OPTIONS,
      r.DESCRIBE,
      r.ANNOUNCE,
      r.SETUP,
      r.PLAY,
      r.PAUSE,
      r.TEARDOWN,
      r.GET_PARAMETER,
      r.SET_PARAMETER,
      r.REDIRECT,
      r.RECORD,
      r.FLUSH,
      // For AirPlay
      r.GET,
      r.POST
    ], t.METHOD_MAP = e.enumToMap(r), t.H_METHOD_MAP = {}, Object.keys(t.METHOD_MAP).forEach((s) => {
      /^H/.test(s) && (t.H_METHOD_MAP[s] = t.METHOD_MAP[s]);
    }), (function(s) {
      s[s.SAFE = 0] = "SAFE", s[s.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", s[s.UNSAFE = 2] = "UNSAFE";
    })(t.FINISH || (t.FINISH = {})), t.ALPHA = [];
    for (let s = 65; s <= 90; s++)
      t.ALPHA.push(String.fromCharCode(s)), t.ALPHA.push(String.fromCharCode(s + 32));
    t.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    }, t.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    }, t.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ], t.ALPHANUM = t.ALPHA.concat(t.NUM), t.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"], t.USERINFO_CHARS = t.ALPHANUM.concat(t.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]), t.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(t.ALPHANUM), t.URL_CHAR = t.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let s = 128; s <= 255; s++)
      t.URL_CHAR.push(s);
    t.HEX = t.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]), t.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(t.ALPHANUM), t.TOKEN = t.STRICT_TOKEN.concat([" "]), t.HEADER_CHARS = ["	"];
    for (let s = 32; s <= 255; s++)
      s !== 127 && t.HEADER_CHARS.push(s);
    t.CONNECTION_TOKEN_CHARS = t.HEADER_CHARS.filter((s) => s !== 44), t.MAJOR = t.NUM_MAP, t.MINOR = t.MAJOR;
    var n;
    (function(s) {
      s[s.GENERAL = 0] = "GENERAL", s[s.CONNECTION = 1] = "CONNECTION", s[s.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", s[s.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", s[s.UPGRADE = 4] = "UPGRADE", s[s.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", s[s.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", s[s.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", s[s.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(n = t.HEADER_STATE || (t.HEADER_STATE = {})), t.SPECIAL_HEADERS = {
      connection: n.CONNECTION,
      "content-length": n.CONTENT_LENGTH,
      "proxy-connection": n.CONNECTION,
      "transfer-encoding": n.TRANSFER_ENCODING,
      upgrade: n.UPGRADE
    };
  })(ra)), ra;
}
var na, Gd;
function Yd() {
  if (Gd) return na;
  Gd = 1;
  const { Buffer: t } = ur;
  return na = t.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64"), na;
}
var sa, Jd;
function Fy() {
  if (Jd) return sa;
  Jd = 1;
  const { Buffer: t } = ur;
  return sa = t.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64"), sa;
}
var ia, Vd;
function ji() {
  if (Vd) return ia;
  Vd = 1;
  const t = (
    /** @type {const} */
    ["GET", "HEAD", "POST"]
  ), e = new Set(t), r = (
    /** @type {const} */
    [101, 204, 205, 304]
  ), n = (
    /** @type {const} */
    [301, 302, 303, 307, 308]
  ), s = new Set(n), i = (
    /** @type {const} */
    [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "4190",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6679",
      "6697",
      "10080"
    ]
  ), o = new Set(i), a = (
    /** @type {const} */
    [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]
  ), A = new Set(a), c = (
    /** @type {const} */
    ["follow", "manual", "error"]
  ), l = (
    /** @type {const} */
    ["GET", "HEAD", "OPTIONS", "TRACE"]
  ), d = new Set(l), u = (
    /** @type {const} */
    ["navigate", "same-origin", "no-cors", "cors"]
  ), m = (
    /** @type {const} */
    ["omit", "same-origin", "include"]
  ), h = (
    /** @type {const} */
    [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ]
  ), f = (
    /** @type {const} */
    [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ]
  ), p = (
    /** @type {const} */
    [
      "half"
    ]
  ), y = (
    /** @type {const} */
    ["CONNECT", "TRACE", "TRACK"]
  ), w = new Set(y), R = (
    /** @type {const} */
    [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ]
  ), D = new Set(R);
  return ia = {
    subresource: R,
    forbiddenMethods: y,
    requestBodyHeader: f,
    referrerPolicy: a,
    requestRedirect: c,
    requestMode: u,
    requestCredentials: m,
    requestCache: h,
    redirectStatus: n,
    corsSafeListedMethods: t,
    nullBodyStatus: r,
    safeMethods: l,
    badPorts: i,
    requestDuplex: p,
    subresourceSet: D,
    badPortsSet: o,
    redirectStatusSet: s,
    corsSafeListedMethodsSet: e,
    safeMethodsSet: d,
    forbiddenMethodsSet: w,
    referrerPolicySet: A
  }, ia;
}
var oa, _d;
function nf() {
  if (_d) return oa;
  _d = 1;
  const t = /* @__PURE__ */ Symbol.for("undici.globalOrigin.1");
  function e() {
    return globalThis[t];
  }
  function r(n) {
    if (n === void 0) {
      Object.defineProperty(globalThis, t, {
        value: void 0,
        writable: !0,
        enumerable: !1,
        configurable: !1
      });
      return;
    }
    const s = new URL(n);
    if (s.protocol !== "http:" && s.protocol !== "https:")
      throw new TypeError(`Only http & https urls are allowed, received ${s.protocol}`);
    Object.defineProperty(globalThis, t, {
      value: s,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  return oa = {
    getGlobalOrigin: e,
    setGlobalOrigin: r
  }, oa;
}
var aa, Wd;
function or() {
  if (Wd) return aa;
  Wd = 1;
  const t = lt, e = new TextEncoder(), r = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/, n = /[\u000A\u000D\u0009\u0020]/, s = /[\u0009\u000A\u000C\u000D\u0020]/g, i = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
  function o(g) {
    t(g.protocol === "data:");
    let B = a(g, !0);
    B = B.slice(5);
    const Q = { position: 0 };
    let E = c(
      ",",
      B,
      Q
    );
    const b = E.length;
    if (E = L(E, !0, !0), Q.position >= B.length)
      return "failure";
    Q.position++;
    const N = B.slice(b + 1);
    let S = l(N);
    if (/;(\u0020){0,}base64$/i.test(E)) {
      const k = I(S);
      if (S = f(k), S === "failure")
        return "failure";
      E = E.slice(0, -6), E = E.replace(/(\u0020)+$/, ""), E = E.slice(0, -1);
    }
    E.startsWith(";") && (E = "text/plain" + E);
    let M = h(E);
    return M === "failure" && (M = h("text/plain;charset=US-ASCII")), { mimeType: M, body: S };
  }
  function a(g, B = !1) {
    if (!B)
      return g.href;
    const Q = g.href, E = g.hash.length, b = E === 0 ? Q : Q.substring(0, Q.length - E);
    return !E && Q.endsWith("#") ? b.slice(0, -1) : b;
  }
  function A(g, B, Q) {
    let E = "";
    for (; Q.position < B.length && g(B[Q.position]); )
      E += B[Q.position], Q.position++;
    return E;
  }
  function c(g, B, Q) {
    const E = B.indexOf(g, Q.position), b = Q.position;
    return E === -1 ? (Q.position = B.length, B.slice(b)) : (Q.position = E, B.slice(b, Q.position));
  }
  function l(g) {
    const B = e.encode(g);
    return m(B);
  }
  function d(g) {
    return g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102;
  }
  function u(g) {
    return (
      // 0-9
      g >= 48 && g <= 57 ? g - 48 : (g & 223) - 55
    );
  }
  function m(g) {
    const B = g.length, Q = new Uint8Array(B);
    let E = 0;
    for (let b = 0; b < B; ++b) {
      const N = g[b];
      N !== 37 ? Q[E++] = N : N === 37 && !(d(g[b + 1]) && d(g[b + 2])) ? Q[E++] = 37 : (Q[E++] = u(g[b + 1]) << 4 | u(g[b + 2]), b += 2);
    }
    return B === E ? Q : Q.subarray(0, E);
  }
  function h(g) {
    g = R(g, !0, !0);
    const B = { position: 0 }, Q = c(
      "/",
      g,
      B
    );
    if (Q.length === 0 || !r.test(Q) || B.position > g.length)
      return "failure";
    B.position++;
    let E = c(
      ";",
      g,
      B
    );
    if (E = R(E, !1, !0), E.length === 0 || !r.test(E))
      return "failure";
    const b = Q.toLowerCase(), N = E.toLowerCase(), S = {
      type: b,
      subtype: N,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${b}/${N}`
    };
    for (; B.position < g.length; ) {
      B.position++, A(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (F) => n.test(F),
        g,
        B
      );
      let M = A(
        (F) => F !== ";" && F !== "=",
        g,
        B
      );
      if (M = M.toLowerCase(), B.position < g.length) {
        if (g[B.position] === ";")
          continue;
        B.position++;
      }
      if (B.position > g.length)
        break;
      let k = null;
      if (g[B.position] === '"')
        k = p(g, B, !0), c(
          ";",
          g,
          B
        );
      else if (k = c(
        ";",
        g,
        B
      ), k = R(k, !1, !0), k.length === 0)
        continue;
      M.length !== 0 && r.test(M) && (k.length === 0 || i.test(k)) && !S.parameters.has(M) && S.parameters.set(M, k);
    }
    return S;
  }
  function f(g) {
    g = g.replace(s, "");
    let B = g.length;
    if (B % 4 === 0 && g.charCodeAt(B - 1) === 61 && (--B, g.charCodeAt(B - 1) === 61 && --B), B % 4 === 1 || /[^+/0-9A-Za-z]/.test(g.length === B ? g : g.substring(0, B)))
      return "failure";
    const Q = Buffer.from(g, "base64");
    return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength);
  }
  function p(g, B, Q) {
    const E = B.position;
    let b = "";
    for (t(g[B.position] === '"'), B.position++; b += A(
      (S) => S !== '"' && S !== "\\",
      g,
      B
    ), !(B.position >= g.length); ) {
      const N = g[B.position];
      if (B.position++, N === "\\") {
        if (B.position >= g.length) {
          b += "\\";
          break;
        }
        b += g[B.position], B.position++;
      } else {
        t(N === '"');
        break;
      }
    }
    return Q ? b : g.slice(E, B.position);
  }
  function y(g) {
    t(g !== "failure");
    const { parameters: B, essence: Q } = g;
    let E = Q;
    for (let [b, N] of B.entries())
      E += ";", E += b, E += "=", r.test(N) || (N = N.replace(/(\\|")/g, "\\$1"), N = '"' + N, N += '"'), E += N;
    return E;
  }
  function w(g) {
    return g === 13 || g === 10 || g === 9 || g === 32;
  }
  function R(g, B = !0, Q = !0) {
    return C(g, B, Q, w);
  }
  function D(g) {
    return g === 13 || g === 10 || g === 9 || g === 12 || g === 32;
  }
  function L(g, B = !0, Q = !0) {
    return C(g, B, Q, D);
  }
  function C(g, B, Q, E) {
    let b = 0, N = g.length - 1;
    if (B)
      for (; b < g.length && E(g.charCodeAt(b)); ) b++;
    if (Q)
      for (; N > 0 && E(g.charCodeAt(N)); ) N--;
    return b === 0 && N === g.length - 1 ? g : g.slice(b, N + 1);
  }
  function I(g) {
    const B = g.length;
    if (65535 > B)
      return String.fromCharCode.apply(null, g);
    let Q = "", E = 0, b = 65535;
    for (; E < B; )
      E + b > B && (b = B - E), Q += String.fromCharCode.apply(null, g.subarray(E, E += b));
    return Q;
  }
  function x(g) {
    switch (g.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    return g.subtype.endsWith("+json") ? "application/json" : g.subtype.endsWith("+xml") ? "application/xml" : "";
  }
  return aa = {
    dataURLProcessor: o,
    URLSerializer: a,
    collectASequenceOfCodePoints: A,
    collectASequenceOfCodePointsFast: c,
    stringPercentDecode: l,
    parseMIMEType: h,
    collectAnHTTPQuotedString: p,
    serializeAMimeType: y,
    removeChars: C,
    removeHTTPWhitespace: R,
    minimizeSupportedMimeType: x,
    HTTP_TOKEN_CODEPOINTS: r,
    isomorphicDecode: I
  }, aa;
}
var Aa, $d;
function zt() {
  if ($d) return Aa;
  $d = 1;
  const { types: t, inspect: e } = _t, { markAsUncloneable: r } = Xg, { toUSVString: n } = Xe(), s = {};
  return s.converters = {}, s.util = {}, s.errors = {}, s.errors.exception = function(i) {
    return new TypeError(`${i.header}: ${i.message}`);
  }, s.errors.conversionFailed = function(i) {
    const o = i.types.length === 1 ? "" : " one of", a = `${i.argument} could not be converted to${o}: ${i.types.join(", ")}.`;
    return s.errors.exception({
      header: i.prefix,
      message: a
    });
  }, s.errors.invalidArgument = function(i) {
    return s.errors.exception({
      header: i.prefix,
      message: `"${i.value}" is an invalid ${i.type}.`
    });
  }, s.brandCheck = function(i, o, a) {
    if (a?.strict !== !1) {
      if (!(i instanceof o)) {
        const A = new TypeError("Illegal invocation");
        throw A.code = "ERR_INVALID_THIS", A;
      }
    } else if (i?.[Symbol.toStringTag] !== o.prototype[Symbol.toStringTag]) {
      const A = new TypeError("Illegal invocation");
      throw A.code = "ERR_INVALID_THIS", A;
    }
  }, s.argumentLengthCheck = function({ length: i }, o, a) {
    if (i < o)
      throw s.errors.exception({
        message: `${o} argument${o !== 1 ? "s" : ""} required, but${i ? " only" : ""} ${i} found.`,
        header: a
      });
  }, s.illegalConstructor = function() {
    throw s.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  }, s.util.Type = function(i) {
    switch (typeof i) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object":
        return i === null ? "Null" : "Object";
    }
  }, s.util.markAsUncloneable = r || (() => {
  }), s.util.ConvertToInt = function(i, o, a, A) {
    let c, l;
    o === 64 ? (c = Math.pow(2, 53) - 1, a === "unsigned" ? l = 0 : l = Math.pow(-2, 53) + 1) : a === "unsigned" ? (l = 0, c = Math.pow(2, o) - 1) : (l = Math.pow(-2, o) - 1, c = Math.pow(2, o - 1) - 1);
    let d = Number(i);
    if (d === 0 && (d = 0), A?.enforceRange === !0) {
      if (Number.isNaN(d) || d === Number.POSITIVE_INFINITY || d === Number.NEGATIVE_INFINITY)
        throw s.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${s.util.Stringify(i)} to an integer.`
        });
      if (d = s.util.IntegerPart(d), d < l || d > c)
        throw s.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${l}-${c}, got ${d}.`
        });
      return d;
    }
    return !Number.isNaN(d) && A?.clamp === !0 ? (d = Math.min(Math.max(d, l), c), Math.floor(d) % 2 === 0 ? d = Math.floor(d) : d = Math.ceil(d), d) : Number.isNaN(d) || d === 0 && Object.is(0, d) || d === Number.POSITIVE_INFINITY || d === Number.NEGATIVE_INFINITY ? 0 : (d = s.util.IntegerPart(d), d = d % Math.pow(2, o), a === "signed" && d >= Math.pow(2, o) - 1 ? d - Math.pow(2, o) : d);
  }, s.util.IntegerPart = function(i) {
    const o = Math.floor(Math.abs(i));
    return i < 0 ? -1 * o : o;
  }, s.util.Stringify = function(i) {
    switch (s.util.Type(i)) {
      case "Symbol":
        return `Symbol(${i.description})`;
      case "Object":
        return e(i);
      case "String":
        return `"${i}"`;
      default:
        return `${i}`;
    }
  }, s.sequenceConverter = function(i) {
    return (o, a, A, c) => {
      if (s.util.Type(o) !== "Object")
        throw s.errors.exception({
          header: a,
          message: `${A} (${s.util.Stringify(o)}) is not iterable.`
        });
      const l = typeof c == "function" ? c() : o?.[Symbol.iterator]?.(), d = [];
      let u = 0;
      if (l === void 0 || typeof l.next != "function")
        throw s.errors.exception({
          header: a,
          message: `${A} is not iterable.`
        });
      for (; ; ) {
        const { done: m, value: h } = l.next();
        if (m)
          break;
        d.push(i(h, a, `${A}[${u++}]`));
      }
      return d;
    };
  }, s.recordConverter = function(i, o) {
    return (a, A, c) => {
      if (s.util.Type(a) !== "Object")
        throw s.errors.exception({
          header: A,
          message: `${c} ("${s.util.Type(a)}") is not an Object.`
        });
      const l = {};
      if (!t.isProxy(a)) {
        const u = [...Object.getOwnPropertyNames(a), ...Object.getOwnPropertySymbols(a)];
        for (const m of u) {
          const h = i(m, A, c), f = o(a[m], A, c);
          l[h] = f;
        }
        return l;
      }
      const d = Reflect.ownKeys(a);
      for (const u of d)
        if (Reflect.getOwnPropertyDescriptor(a, u)?.enumerable) {
          const h = i(u, A, c), f = o(a[u], A, c);
          l[h] = f;
        }
      return l;
    };
  }, s.interfaceConverter = function(i) {
    return (o, a, A, c) => {
      if (c?.strict !== !1 && !(o instanceof i))
        throw s.errors.exception({
          header: a,
          message: `Expected ${A} ("${s.util.Stringify(o)}") to be an instance of ${i.name}.`
        });
      return o;
    };
  }, s.dictionaryConverter = function(i) {
    return (o, a, A) => {
      const c = s.util.Type(o), l = {};
      if (c === "Null" || c === "Undefined")
        return l;
      if (c !== "Object")
        throw s.errors.exception({
          header: a,
          message: `Expected ${o} to be one of: Null, Undefined, Object.`
        });
      for (const d of i) {
        const { key: u, defaultValue: m, required: h, converter: f } = d;
        if (h === !0 && !Object.hasOwn(o, u))
          throw s.errors.exception({
            header: a,
            message: `Missing required key "${u}".`
          });
        let p = o[u];
        const y = Object.hasOwn(d, "defaultValue");
        if (y && p !== null && (p ??= m()), h || y || p !== void 0) {
          if (p = f(p, a, `${A}.${u}`), d.allowedValues && !d.allowedValues.includes(p))
            throw s.errors.exception({
              header: a,
              message: `${p} is not an accepted type. Expected one of ${d.allowedValues.join(", ")}.`
            });
          l[u] = p;
        }
      }
      return l;
    };
  }, s.nullableConverter = function(i) {
    return (o, a, A) => o === null ? o : i(o, a, A);
  }, s.converters.DOMString = function(i, o, a, A) {
    if (i === null && A?.legacyNullToEmptyString)
      return "";
    if (typeof i == "symbol")
      throw s.errors.exception({
        header: o,
        message: `${a} is a symbol, which cannot be converted to a DOMString.`
      });
    return String(i);
  }, s.converters.ByteString = function(i, o, a) {
    const A = s.converters.DOMString(i, o, a);
    for (let c = 0; c < A.length; c++)
      if (A.charCodeAt(c) > 255)
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${c} has a value of ${A.charCodeAt(c)} which is greater than 255.`
        );
    return A;
  }, s.converters.USVString = n, s.converters.boolean = function(i) {
    return !!i;
  }, s.converters.any = function(i) {
    return i;
  }, s.converters["long long"] = function(i, o, a) {
    return s.util.ConvertToInt(i, 64, "signed", void 0, o, a);
  }, s.converters["unsigned long long"] = function(i, o, a) {
    return s.util.ConvertToInt(i, 64, "unsigned", void 0, o, a);
  }, s.converters["unsigned long"] = function(i, o, a) {
    return s.util.ConvertToInt(i, 32, "unsigned", void 0, o, a);
  }, s.converters["unsigned short"] = function(i, o, a, A) {
    return s.util.ConvertToInt(i, 16, "unsigned", A, o, a);
  }, s.converters.ArrayBuffer = function(i, o, a, A) {
    if (s.util.Type(i) !== "Object" || !t.isAnyArrayBuffer(i))
      throw s.errors.conversionFailed({
        prefix: o,
        argument: `${a} ("${s.util.Stringify(i)}")`,
        types: ["ArrayBuffer"]
      });
    if (A?.allowShared === !1 && t.isSharedArrayBuffer(i))
      throw s.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    if (i.resizable || i.growable)
      throw s.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    return i;
  }, s.converters.TypedArray = function(i, o, a, A, c) {
    if (s.util.Type(i) !== "Object" || !t.isTypedArray(i) || i.constructor.name !== o.name)
      throw s.errors.conversionFailed({
        prefix: a,
        argument: `${A} ("${s.util.Stringify(i)}")`,
        types: [o.name]
      });
    if (c?.allowShared === !1 && t.isSharedArrayBuffer(i.buffer))
      throw s.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    if (i.buffer.resizable || i.buffer.growable)
      throw s.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    return i;
  }, s.converters.DataView = function(i, o, a, A) {
    if (s.util.Type(i) !== "Object" || !t.isDataView(i))
      throw s.errors.exception({
        header: o,
        message: `${a} is not a DataView.`
      });
    if (A?.allowShared === !1 && t.isSharedArrayBuffer(i.buffer))
      throw s.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    if (i.buffer.resizable || i.buffer.growable)
      throw s.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    return i;
  }, s.converters.BufferSource = function(i, o, a, A) {
    if (t.isAnyArrayBuffer(i))
      return s.converters.ArrayBuffer(i, o, a, { ...A, allowShared: !1 });
    if (t.isTypedArray(i))
      return s.converters.TypedArray(i, i.constructor, o, a, { ...A, allowShared: !1 });
    if (t.isDataView(i))
      return s.converters.DataView(i, o, a, { ...A, allowShared: !1 });
    throw s.errors.conversionFailed({
      prefix: o,
      argument: `${a} ("${s.util.Stringify(i)}")`,
      types: ["BufferSource"]
    });
  }, s.converters["sequence<ByteString>"] = s.sequenceConverter(
    s.converters.ByteString
  ), s.converters["sequence<sequence<ByteString>>"] = s.sequenceConverter(
    s.converters["sequence<ByteString>"]
  ), s.converters["record<ByteString, ByteString>"] = s.recordConverter(
    s.converters.ByteString,
    s.converters.ByteString
  ), Aa = {
    webidl: s
  }, Aa;
}
var ca, Xd;
function mr() {
  if (Xd) return ca;
  Xd = 1;
  const { Transform: t } = dr, e = Hs, { redirectStatusSet: r, referrerPolicySet: n, badPortsSet: s } = ji(), { getGlobalOrigin: i } = nf(), { collectASequenceOfCodePoints: o, collectAnHTTPQuotedString: a, removeChars: A, parseMIMEType: c } = or(), { performance: l } = dy, { isBlobLike: d, ReadableStreamFrom: u, isValidHTTPToken: m, normalizedMethodRecordsBase: h } = Xe(), f = lt, { isUint8Array: p } = $g, { webidl: y } = zt();
  let w = [], R;
  try {
    R = Wn("node:crypto");
    const U = ["sha256", "sha384", "sha512"];
    w = R.getHashes().filter((V) => U.includes(V));
  } catch {
  }
  function D(U) {
    const V = U.urlList, v = V.length;
    return v === 0 ? null : V[v - 1].toString();
  }
  function L(U, V) {
    if (!r.has(U.status))
      return null;
    let v = U.headersList.get("location", !0);
    return v !== null && b(v) && (C(v) || (v = I(v)), v = new URL(v, D(U))), v && !v.hash && (v.hash = V), v;
  }
  function C(U) {
    for (let V = 0; V < U.length; ++V) {
      const v = U.charCodeAt(V);
      if (v > 126 || // Non-US-ASCII + DEL
      v < 32)
        return !1;
    }
    return !0;
  }
  function I(U) {
    return Buffer.from(U, "binary").toString("utf8");
  }
  function x(U) {
    return U.urlList[U.urlList.length - 1];
  }
  function g(U) {
    const V = x(U);
    return be(V) && s.has(V.port) ? "blocked" : "allowed";
  }
  function B(U) {
    return U instanceof Error || U?.constructor?.name === "Error" || U?.constructor?.name === "DOMException";
  }
  function Q(U) {
    for (let V = 0; V < U.length; ++V) {
      const v = U.charCodeAt(V);
      if (!(v === 9 || // HTAB
      v >= 32 && v <= 126 || // SP / VCHAR
      v >= 128 && v <= 255))
        return !1;
    }
    return !0;
  }
  const E = m;
  function b(U) {
    return (U[0] === "	" || U[0] === " " || U[U.length - 1] === "	" || U[U.length - 1] === " " || U.includes(`
`) || U.includes("\r") || U.includes("\0")) === !1;
  }
  function N(U, V) {
    const { headersList: v } = V, G = (v.get("referrer-policy", !0) ?? "").split(",");
    let q = "";
    if (G.length > 0)
      for (let Y = G.length; Y !== 0; Y--) {
        const oe = G[Y - 1].trim();
        if (n.has(oe)) {
          q = oe;
          break;
        }
      }
    q !== "" && (U.referrerPolicy = q);
  }
  function S() {
    return "allowed";
  }
  function M() {
    return "success";
  }
  function k() {
    return "success";
  }
  function F(U) {
    let V = null;
    V = U.mode, U.headersList.set("sec-fetch-mode", V, !0);
  }
  function P(U) {
    let V = U.origin;
    if (!(V === "client" || V === void 0)) {
      if (U.responseTainting === "cors" || U.mode === "websocket")
        U.headersList.append("origin", V, !0);
      else if (U.method !== "GET" && U.method !== "HEAD") {
        switch (U.referrerPolicy) {
          case "no-referrer":
            V = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            U.origin && Ee(U.origin) && !Ee(x(U)) && (V = null);
            break;
          case "same-origin":
            pe(U, x(U)) || (V = null);
            break;
        }
        U.headersList.append("origin", V, !0);
      }
    }
  }
  function J(U, V) {
    return U;
  }
  function te(U, V, v) {
    return !U?.startTime || U.startTime < V ? {
      domainLookupStartTime: V,
      domainLookupEndTime: V,
      connectionStartTime: V,
      connectionEndTime: V,
      secureConnectionStartTime: V,
      ALPNNegotiatedProtocol: U?.ALPNNegotiatedProtocol
    } : {
      domainLookupStartTime: J(U.domainLookupStartTime),
      domainLookupEndTime: J(U.domainLookupEndTime),
      connectionStartTime: J(U.connectionStartTime),
      connectionEndTime: J(U.connectionEndTime),
      secureConnectionStartTime: J(U.secureConnectionStartTime),
      ALPNNegotiatedProtocol: U.ALPNNegotiatedProtocol
    };
  }
  function ee(U) {
    return J(l.now());
  }
  function de(U) {
    return {
      startTime: U.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: U.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function ue() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function ce(U) {
    return {
      referrerPolicy: U.referrerPolicy
    };
  }
  function fe(U) {
    const V = U.referrerPolicy;
    f(V);
    let v = null;
    if (U.referrer === "client") {
      const K = i();
      if (!K || K.origin === "null")
        return "no-referrer";
      v = new URL(K);
    } else U.referrer instanceof URL && (v = U.referrer);
    let G = Ce(v);
    const q = Ce(v, !0);
    G.toString().length > 4096 && (G = q);
    const Y = pe(U, G), oe = Z(G) && !Z(U.url);
    switch (V) {
      case "origin":
        return q ?? Ce(v, !0);
      case "unsafe-url":
        return G;
      case "same-origin":
        return Y ? q : "no-referrer";
      case "origin-when-cross-origin":
        return Y ? G : q;
      case "strict-origin-when-cross-origin": {
        const K = x(U);
        return pe(G, K) ? G : Z(G) && !Z(K) ? "no-referrer" : q;
      }
      // eslint-disable-line
      /**
       * 1. If referrerURL is a potentially trustworthy URL and
       * requests current URL is not a potentially trustworthy URL,
       * then return no referrer.
       * 2. Return referrerOrigin
      */
      default:
        return oe ? "no-referrer" : q;
    }
  }
  function Ce(U, V) {
    return f(U instanceof URL), U = new URL(U), U.protocol === "file:" || U.protocol === "about:" || U.protocol === "blank:" ? "no-referrer" : (U.username = "", U.password = "", U.hash = "", V && (U.pathname = "", U.search = ""), U);
  }
  function Z(U) {
    if (!(U instanceof URL))
      return !1;
    if (U.href === "about:blank" || U.href === "about:srcdoc" || U.protocol === "data:" || U.protocol === "file:") return !0;
    return V(U.origin);
    function V(v) {
      if (v == null || v === "null") return !1;
      const G = new URL(v);
      return !!(G.protocol === "https:" || G.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(G.hostname) || G.hostname === "localhost" || G.hostname.includes("localhost.") || G.hostname.endsWith(".localhost"));
    }
  }
  function _(U, V) {
    if (R === void 0)
      return !0;
    const v = H(V);
    if (v === "no metadata" || v.length === 0)
      return !0;
    const G = W(v), q = z(v, G);
    for (const Y of q) {
      const oe = Y.algo, K = Y.hash;
      let ge = R.createHash(oe).update(U).digest("base64");
      if (ge[ge.length - 1] === "=" && (ge[ge.length - 2] === "=" ? ge = ge.slice(0, -2) : ge = ge.slice(0, -1)), $(ge, K))
        return !0;
    }
    return !1;
  }
  const ne = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function H(U) {
    const V = [];
    let v = !0;
    for (const G of U.split(" ")) {
      v = !1;
      const q = ne.exec(G);
      if (q === null || q.groups === void 0 || q.groups.algo === void 0)
        continue;
      const Y = q.groups.algo.toLowerCase();
      w.includes(Y) && V.push(q.groups);
    }
    return v === !0 ? "no metadata" : V;
  }
  function W(U) {
    let V = U[0].algo;
    if (V[3] === "5")
      return V;
    for (let v = 1; v < U.length; ++v) {
      const G = U[v];
      if (G.algo[3] === "5") {
        V = "sha512";
        break;
      } else {
        if (V[3] === "3")
          continue;
        G.algo[3] === "3" && (V = "sha384");
      }
    }
    return V;
  }
  function z(U, V) {
    if (U.length === 1)
      return U;
    let v = 0;
    for (let G = 0; G < U.length; ++G)
      U[G].algo === V && (U[v++] = U[G]);
    return U.length = v, U;
  }
  function $(U, V) {
    if (U.length !== V.length)
      return !1;
    for (let v = 0; v < U.length; ++v)
      if (U[v] !== V[v]) {
        if (U[v] === "+" && V[v] === "-" || U[v] === "/" && V[v] === "_")
          continue;
        return !1;
      }
    return !0;
  }
  function Ae(U) {
  }
  function pe(U, V) {
    return U.origin === V.origin && U.origin === "null" || U.protocol === V.protocol && U.hostname === V.hostname && U.port === V.port;
  }
  function me() {
    let U, V;
    return { promise: new Promise((G, q) => {
      U = G, V = q;
    }), resolve: U, reject: V };
  }
  function xe(U) {
    return U.controller.state === "aborted";
  }
  function _e(U) {
    return U.controller.state === "aborted" || U.controller.state === "terminated";
  }
  function ke(U) {
    return h[U.toLowerCase()] ?? U;
  }
  function We(U) {
    const V = JSON.stringify(U);
    if (V === void 0)
      throw new TypeError("Value is not JSON serializable");
    return f(typeof V == "string"), V;
  }
  const ve = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function He(U, V, v = 0, G = 1) {
    class q {
      /** @type {any} */
      #e;
      /** @type {'key' | 'value' | 'key+value'} */
      #t;
      /** @type {number} */
      #s;
      /**
       * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
       * @param {unknown} target
       * @param {'key' | 'value' | 'key+value'} kind
       */
      constructor(oe, K) {
        this.#e = oe, this.#t = K, this.#s = 0;
      }
      next() {
        if (typeof this != "object" || this === null || !(#e in this))
          throw new TypeError(
            `'next' called on an object that does not implement interface ${U} Iterator.`
          );
        const oe = this.#s, K = this.#e[V], ge = K.length;
        if (oe >= ge)
          return {
            value: void 0,
            done: !0
          };
        const { [v]: ze, [G]: je } = K[oe];
        this.#s = oe + 1;
        let Ze;
        switch (this.#t) {
          case "key":
            Ze = ze;
            break;
          case "value":
            Ze = je;
            break;
          case "key+value":
            Ze = [ze, je];
            break;
        }
        return {
          value: Ze,
          done: !1
        };
      }
    }
    return delete q.prototype.constructor, Object.setPrototypeOf(q.prototype, ve), Object.defineProperties(q.prototype, {
      [Symbol.toStringTag]: {
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: `${U} Iterator`
      },
      next: { writable: !0, enumerable: !0, configurable: !0 }
    }), function(Y, oe) {
      return new q(Y, oe);
    };
  }
  function Re(U, V, v, G = 0, q = 1) {
    const Y = He(U, v, G, q), oe = {
      keys: {
        writable: !0,
        enumerable: !0,
        configurable: !0,
        value: function() {
          return y.brandCheck(this, V), Y(this, "key");
        }
      },
      values: {
        writable: !0,
        enumerable: !0,
        configurable: !0,
        value: function() {
          return y.brandCheck(this, V), Y(this, "value");
        }
      },
      entries: {
        writable: !0,
        enumerable: !0,
        configurable: !0,
        value: function() {
          return y.brandCheck(this, V), Y(this, "key+value");
        }
      },
      forEach: {
        writable: !0,
        enumerable: !0,
        configurable: !0,
        value: function(ge, ze = globalThis) {
          if (y.brandCheck(this, V), y.argumentLengthCheck(arguments, 1, `${U}.forEach`), typeof ge != "function")
            throw new TypeError(
              `Failed to execute 'forEach' on '${U}': parameter 1 is not of type 'Function'.`
            );
          for (const { 0: je, 1: Ze } of Y(this, "key+value"))
            ge.call(ze, Ze, je, this);
        }
      }
    };
    return Object.defineProperties(V.prototype, {
      ...oe,
      [Symbol.iterator]: {
        writable: !0,
        enumerable: !1,
        configurable: !0,
        value: oe.entries.value
      }
    });
  }
  async function ut(U, V, v) {
    const G = V, q = v;
    let Y;
    try {
      Y = U.stream.getReader();
    } catch (oe) {
      q(oe);
      return;
    }
    try {
      G(await X(Y));
    } catch (oe) {
      q(oe);
    }
  }
  function At(U) {
    return U instanceof ReadableStream || U[Symbol.toStringTag] === "ReadableStream" && typeof U.tee == "function";
  }
  function rt(U) {
    try {
      U.close(), U.byobRequest?.respond(0);
    } catch (V) {
      if (!V.message.includes("Controller is already closed") && !V.message.includes("ReadableStream is already closed"))
        throw V;
    }
  }
  const re = /[^\x00-\xFF]/;
  function T(U) {
    return f(!re.test(U)), U;
  }
  async function X(U) {
    const V = [];
    let v = 0;
    for (; ; ) {
      const { done: G, value: q } = await U.read();
      if (G)
        return Buffer.concat(V, v);
      if (!p(q))
        throw new TypeError("Received non-Uint8Array chunk");
      V.push(q), v += q.length;
    }
  }
  function he(U) {
    f("protocol" in U);
    const V = U.protocol;
    return V === "about:" || V === "blob:" || V === "data:";
  }
  function Ee(U) {
    return typeof U == "string" && U[5] === ":" && U[0] === "h" && U[1] === "t" && U[2] === "t" && U[3] === "p" && U[4] === "s" || U.protocol === "https:";
  }
  function be(U) {
    f("protocol" in U);
    const V = U.protocol;
    return V === "http:" || V === "https:";
  }
  function Le(U, V) {
    const v = U;
    if (!v.startsWith("bytes"))
      return "failure";
    const G = { position: 5 };
    if (V && o(
      (ge) => ge === "	" || ge === " ",
      v,
      G
    ), v.charCodeAt(G.position) !== 61)
      return "failure";
    G.position++, V && o(
      (ge) => ge === "	" || ge === " ",
      v,
      G
    );
    const q = o(
      (ge) => {
        const ze = ge.charCodeAt(0);
        return ze >= 48 && ze <= 57;
      },
      v,
      G
    ), Y = q.length ? Number(q) : null;
    if (V && o(
      (ge) => ge === "	" || ge === " ",
      v,
      G
    ), v.charCodeAt(G.position) !== 45)
      return "failure";
    G.position++, V && o(
      (ge) => ge === "	" || ge === " ",
      v,
      G
    );
    const oe = o(
      (ge) => {
        const ze = ge.charCodeAt(0);
        return ze >= 48 && ze <= 57;
      },
      v,
      G
    ), K = oe.length ? Number(oe) : null;
    return G.position < v.length || K === null && Y === null || Y > K ? "failure" : { rangeStartValue: Y, rangeEndValue: K };
  }
  function st(U, V, v) {
    let G = "bytes ";
    return G += T(`${U}`), G += "-", G += T(`${V}`), G += "/", G += T(`${v}`), G;
  }
  class Bt extends t {
    #e;
    /** @param {zlib.ZlibOptions} [zlibOptions] */
    constructor(V) {
      super(), this.#e = V;
    }
    _transform(V, v, G) {
      if (!this._inflateStream) {
        if (V.length === 0) {
          G();
          return;
        }
        this._inflateStream = (V[0] & 15) === 8 ? e.createInflate(this.#e) : e.createInflateRaw(this.#e), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", (q) => this.destroy(q));
      }
      this._inflateStream.write(V, v, G);
    }
    _final(V) {
      this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), V();
    }
  }
  function wt(U) {
    return new Bt(U);
  }
  function Se(U) {
    let V = null, v = null, G = null;
    const q = se("content-type", U);
    if (q === null)
      return "failure";
    for (const Y of q) {
      const oe = c(Y);
      oe === "failure" || oe.essence === "*/*" || (G = oe, G.essence !== v ? (V = null, G.parameters.has("charset") && (V = G.parameters.get("charset")), v = G.essence) : !G.parameters.has("charset") && V !== null && G.parameters.set("charset", V));
    }
    return G ?? "failure";
  }
  function O(U) {
    const V = U, v = { position: 0 }, G = [];
    let q = "";
    for (; v.position < V.length; ) {
      if (q += o(
        (Y) => Y !== '"' && Y !== ",",
        V,
        v
      ), v.position < V.length)
        if (V.charCodeAt(v.position) === 34) {
          if (q += a(
            V,
            v
          ), v.position < V.length)
            continue;
        } else
          f(V.charCodeAt(v.position) === 44), v.position++;
      q = A(q, !0, !0, (Y) => Y === 9 || Y === 32), G.push(q), q = "";
    }
    return G;
  }
  function se(U, V) {
    const v = V.get(U, !0);
    return v === null ? null : O(v);
  }
  const j = new TextDecoder();
  function ie(U) {
    return U.length === 0 ? "" : (U[0] === 239 && U[1] === 187 && U[2] === 191 && (U = U.subarray(3)), j.decode(U));
  }
  class Be {
    get baseUrl() {
      return i();
    }
    get origin() {
      return this.baseUrl?.origin;
    }
    policyContainer = ue();
  }
  class Pe {
    settingsObject = new Be();
  }
  const Ye = new Pe();
  return ca = {
    isAborted: xe,
    isCancelled: _e,
    isValidEncodedURL: C,
    createDeferredPromise: me,
    ReadableStreamFrom: u,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: Ae,
    clampAndCoarsenConnectionTimingInfo: te,
    coarsenedSharedCurrentTime: ee,
    determineRequestsReferrer: fe,
    makePolicyContainer: ue,
    clonePolicyContainer: ce,
    appendFetchMetadata: F,
    appendRequestOriginHeader: P,
    TAOCheck: k,
    corsCheck: M,
    crossOriginResourcePolicyCheck: S,
    createOpaqueTimingInfo: de,
    setRequestReferrerPolicyOnRedirect: N,
    isValidHTTPToken: m,
    requestBadPort: g,
    requestCurrentURL: x,
    responseURL: D,
    responseLocationURL: L,
    isBlobLike: d,
    isURLPotentiallyTrustworthy: Z,
    isValidReasonPhrase: Q,
    sameOrigin: pe,
    normalizeMethod: ke,
    serializeJavascriptValueToJSONString: We,
    iteratorMixin: Re,
    createIterator: He,
    isValidHeaderName: E,
    isValidHeaderValue: b,
    isErrorLike: B,
    fullyReadBody: ut,
    bytesMatch: _,
    isReadableStreamLike: At,
    readableStreamClose: rt,
    isomorphicEncode: T,
    urlIsLocal: he,
    urlHasHttpsScheme: Ee,
    urlIsHttpHttpsScheme: be,
    readAllBytes: X,
    simpleRangeHeaderValue: Le,
    buildContentRange: st,
    parseMetadata: H,
    createInflate: wt,
    extractMimeType: Se,
    getDecodeSplit: se,
    utf8DecodeBytes: ie,
    environmentSettingsObject: Ye
  }, ca;
}
var la, Zd;
function xn() {
  return Zd || (Zd = 1, la = {
    kUrl: /* @__PURE__ */ Symbol("url"),
    kHeaders: /* @__PURE__ */ Symbol("headers"),
    kSignal: /* @__PURE__ */ Symbol("signal"),
    kState: /* @__PURE__ */ Symbol("state"),
    kDispatcher: /* @__PURE__ */ Symbol("dispatcher")
  }), la;
}
var da, Kd;
function sf() {
  if (Kd) return da;
  Kd = 1;
  const { Blob: t, File: e } = ur, { kState: r } = xn(), { webidl: n } = zt();
  class s {
    constructor(a, A, c = {}) {
      const l = A, d = c.type, u = c.lastModified ?? Date.now();
      this[r] = {
        blobLike: a,
        name: l,
        type: d,
        lastModified: u
      };
    }
    stream(...a) {
      return n.brandCheck(this, s), this[r].blobLike.stream(...a);
    }
    arrayBuffer(...a) {
      return n.brandCheck(this, s), this[r].blobLike.arrayBuffer(...a);
    }
    slice(...a) {
      return n.brandCheck(this, s), this[r].blobLike.slice(...a);
    }
    text(...a) {
      return n.brandCheck(this, s), this[r].blobLike.text(...a);
    }
    get size() {
      return n.brandCheck(this, s), this[r].blobLike.size;
    }
    get type() {
      return n.brandCheck(this, s), this[r].blobLike.type;
    }
    get name() {
      return n.brandCheck(this, s), this[r].name;
    }
    get lastModified() {
      return n.brandCheck(this, s), this[r].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  n.converters.Blob = n.interfaceConverter(t);
  function i(o) {
    return o instanceof e || o && (typeof o.stream == "function" || typeof o.arrayBuffer == "function") && o[Symbol.toStringTag] === "File";
  }
  return da = { FileLike: s, isFileLike: i }, da;
}
var ua, jd;
function eo() {
  if (jd) return ua;
  jd = 1;
  const { isBlobLike: t, iteratorMixin: e } = mr(), { kState: r } = xn(), { kEnumerableProperty: n } = Xe(), { FileLike: s, isFileLike: i } = sf(), { webidl: o } = zt(), { File: a } = ur, A = _t, c = globalThis.File ?? a;
  class l {
    constructor(m) {
      if (o.util.markAsUncloneable(this), m !== void 0)
        throw o.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      this[r] = [];
    }
    append(m, h, f = void 0) {
      o.brandCheck(this, l);
      const p = "FormData.append";
      if (o.argumentLengthCheck(arguments, 2, p), arguments.length === 3 && !t(h))
        throw new TypeError(
          "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      m = o.converters.USVString(m, p, "name"), h = t(h) ? o.converters.Blob(h, p, "value", { strict: !1 }) : o.converters.USVString(h, p, "value"), f = arguments.length === 3 ? o.converters.USVString(f, p, "filename") : void 0;
      const y = d(m, h, f);
      this[r].push(y);
    }
    delete(m) {
      o.brandCheck(this, l);
      const h = "FormData.delete";
      o.argumentLengthCheck(arguments, 1, h), m = o.converters.USVString(m, h, "name"), this[r] = this[r].filter((f) => f.name !== m);
    }
    get(m) {
      o.brandCheck(this, l);
      const h = "FormData.get";
      o.argumentLengthCheck(arguments, 1, h), m = o.converters.USVString(m, h, "name");
      const f = this[r].findIndex((p) => p.name === m);
      return f === -1 ? null : this[r][f].value;
    }
    getAll(m) {
      o.brandCheck(this, l);
      const h = "FormData.getAll";
      return o.argumentLengthCheck(arguments, 1, h), m = o.converters.USVString(m, h, "name"), this[r].filter((f) => f.name === m).map((f) => f.value);
    }
    has(m) {
      o.brandCheck(this, l);
      const h = "FormData.has";
      return o.argumentLengthCheck(arguments, 1, h), m = o.converters.USVString(m, h, "name"), this[r].findIndex((f) => f.name === m) !== -1;
    }
    set(m, h, f = void 0) {
      o.brandCheck(this, l);
      const p = "FormData.set";
      if (o.argumentLengthCheck(arguments, 2, p), arguments.length === 3 && !t(h))
        throw new TypeError(
          "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      m = o.converters.USVString(m, p, "name"), h = t(h) ? o.converters.Blob(h, p, "name", { strict: !1 }) : o.converters.USVString(h, p, "name"), f = arguments.length === 3 ? o.converters.USVString(f, p, "name") : void 0;
      const y = d(m, h, f), w = this[r].findIndex((R) => R.name === m);
      w !== -1 ? this[r] = [
        ...this[r].slice(0, w),
        y,
        ...this[r].slice(w + 1).filter((R) => R.name !== m)
      ] : this[r].push(y);
    }
    [A.inspect.custom](m, h) {
      const f = this[r].reduce((y, w) => (y[w.name] ? Array.isArray(y[w.name]) ? y[w.name].push(w.value) : y[w.name] = [y[w.name], w.value] : y[w.name] = w.value, y), { __proto__: null });
      h.depth ??= m, h.colors ??= !0;
      const p = A.formatWithOptions(h, f);
      return `FormData ${p.slice(p.indexOf("]") + 2)}`;
    }
  }
  e("FormData", l, r, "name", "value"), Object.defineProperties(l.prototype, {
    append: n,
    delete: n,
    get: n,
    getAll: n,
    has: n,
    set: n,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: !0
    }
  });
  function d(u, m, h) {
    if (typeof m != "string") {
      if (i(m) || (m = m instanceof Blob ? new c([m], "blob", { type: m.type }) : new s(m, "blob", { type: m.type })), h !== void 0) {
        const f = {
          type: m.type,
          lastModified: m.lastModified
        };
        m = m instanceof a ? new c([m], h, f) : new s(m, h, f);
      }
    }
    return { name: u, value: m };
  }
  return ua = { FormData: l, makeEntry: d }, ua;
}
var ma, eu;
function vy() {
  if (eu) return ma;
  eu = 1;
  const { isUSVString: t, bufferToLowerCasedHeaderName: e } = Xe(), { utf8DecodeBytes: r } = mr(), { HTTP_TOKEN_CODEPOINTS: n, isomorphicDecode: s } = or(), { isFileLike: i } = sf(), { makeEntry: o } = eo(), a = lt, { File: A } = ur, c = globalThis.File ?? A, l = Buffer.from('form-data; name="'), d = Buffer.from("; filename"), u = Buffer.from("--"), m = Buffer.from(`--\r
`);
  function h(C) {
    for (let I = 0; I < C.length; ++I)
      if ((C.charCodeAt(I) & -128) !== 0)
        return !1;
    return !0;
  }
  function f(C) {
    const I = C.length;
    if (I < 27 || I > 70)
      return !1;
    for (let x = 0; x < I; ++x) {
      const g = C.charCodeAt(x);
      if (!(g >= 48 && g <= 57 || g >= 65 && g <= 90 || g >= 97 && g <= 122 || g === 39 || g === 45 || g === 95))
        return !1;
    }
    return !0;
  }
  function p(C, I) {
    a(I !== "failure" && I.essence === "multipart/form-data");
    const x = I.parameters.get("boundary");
    if (x === void 0)
      return "failure";
    const g = Buffer.from(`--${x}`, "utf8"), B = [], Q = { position: 0 };
    for (; C[Q.position] === 13 && C[Q.position + 1] === 10; )
      Q.position += 2;
    let E = C.length;
    for (; C[E - 1] === 10 && C[E - 2] === 13; )
      E -= 2;
    for (E !== C.length && (C = C.subarray(0, E)); ; ) {
      if (C.subarray(Q.position, Q.position + g.length).equals(g))
        Q.position += g.length;
      else
        return "failure";
      if (Q.position === C.length - 2 && L(C, u, Q) || Q.position === C.length - 4 && L(C, m, Q))
        return B;
      if (C[Q.position] !== 13 || C[Q.position + 1] !== 10)
        return "failure";
      Q.position += 2;
      const b = y(C, Q);
      if (b === "failure")
        return "failure";
      let { name: N, filename: S, contentType: M, encoding: k } = b;
      Q.position += 2;
      let F;
      {
        const J = C.indexOf(g.subarray(2), Q.position);
        if (J === -1)
          return "failure";
        F = C.subarray(Q.position, J - 4), Q.position += F.length, k === "base64" && (F = Buffer.from(F.toString(), "base64"));
      }
      if (C[Q.position] !== 13 || C[Q.position + 1] !== 10)
        return "failure";
      Q.position += 2;
      let P;
      S !== null ? (M ??= "text/plain", h(M) || (M = ""), P = new c([F], S, { type: M })) : P = r(Buffer.from(F)), a(t(N)), a(typeof P == "string" && t(P) || i(P)), B.push(o(N, P, S));
    }
  }
  function y(C, I) {
    let x = null, g = null, B = null, Q = null;
    for (; ; ) {
      if (C[I.position] === 13 && C[I.position + 1] === 10)
        return x === null ? "failure" : { name: x, filename: g, contentType: B, encoding: Q };
      let E = R(
        (b) => b !== 10 && b !== 13 && b !== 58,
        C,
        I
      );
      if (E = D(E, !0, !0, (b) => b === 9 || b === 32), !n.test(E.toString()) || C[I.position] !== 58)
        return "failure";
      switch (I.position++, R(
        (b) => b === 32 || b === 9,
        C,
        I
      ), e(E)) {
        case "content-disposition": {
          if (x = g = null, !L(C, l, I) || (I.position += 17, x = w(C, I), x === null))
            return "failure";
          if (L(C, d, I)) {
            let b = I.position + d.length;
            if (C[b] === 42 && (I.position += 1, b += 1), C[b] !== 61 || C[b + 1] !== 34 || (I.position += 12, g = w(C, I), g === null))
              return "failure";
          }
          break;
        }
        case "content-type": {
          let b = R(
            (N) => N !== 10 && N !== 13,
            C,
            I
          );
          b = D(b, !1, !0, (N) => N === 9 || N === 32), B = s(b);
          break;
        }
        case "content-transfer-encoding": {
          let b = R(
            (N) => N !== 10 && N !== 13,
            C,
            I
          );
          b = D(b, !1, !0, (N) => N === 9 || N === 32), Q = s(b);
          break;
        }
        default:
          R(
            (b) => b !== 10 && b !== 13,
            C,
            I
          );
      }
      if (C[I.position] !== 13 && C[I.position + 1] !== 10)
        return "failure";
      I.position += 2;
    }
  }
  function w(C, I) {
    a(C[I.position - 1] === 34);
    let x = R(
      (g) => g !== 10 && g !== 13 && g !== 34,
      C,
      I
    );
    return C[I.position] !== 34 ? null : (I.position++, x = new TextDecoder().decode(x).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), x);
  }
  function R(C, I, x) {
    let g = x.position;
    for (; g < I.length && C(I[g]); )
      ++g;
    return I.subarray(x.position, x.position = g);
  }
  function D(C, I, x, g) {
    let B = 0, Q = C.length - 1;
    if (I)
      for (; B < C.length && g(C[B]); ) B++;
    for (; Q > 0 && g(C[Q]); ) Q--;
    return B === 0 && Q === C.length - 1 ? C : C.subarray(B, Q + 1);
  }
  function L(C, I, x) {
    if (C.length < I.length)
      return !1;
    for (let g = 0; g < I.length; g++)
      if (I[g] !== C[x.position + g])
        return !1;
    return !0;
  }
  return ma = {
    multipartFormDataParser: p,
    validateBoundary: f
  }, ma;
}
var ha, tu;
function Xs() {
  if (tu) return ha;
  tu = 1;
  const t = Xe(), {
    ReadableStreamFrom: e,
    isBlobLike: r,
    isReadableStreamLike: n,
    readableStreamClose: s,
    createDeferredPromise: i,
    fullyReadBody: o,
    extractMimeType: a,
    utf8DecodeBytes: A
  } = mr(), { FormData: c } = eo(), { kState: l } = xn(), { webidl: d } = zt(), { Blob: u } = ur, m = lt, { isErrored: h, isDisturbed: f } = dr, { isArrayBuffer: p } = $g, { serializeAMimeType: y } = or(), { multipartFormDataParser: w } = vy();
  let R;
  try {
    const F = Wn("node:crypto");
    R = (P) => F.randomInt(0, P);
  } catch {
    R = (F) => Math.floor(Math.random(F));
  }
  const D = new TextEncoder();
  function L() {
  }
  const C = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
  let I;
  C && (I = new FinalizationRegistry((F) => {
    const P = F.deref();
    P && !P.locked && !f(P) && !h(P) && P.cancel("Response object has been garbage collected").catch(L);
  }));
  function x(F, P = !1) {
    let J = null;
    F instanceof ReadableStream ? J = F : r(F) ? J = F.stream() : J = new ReadableStream({
      async pull(fe) {
        const Ce = typeof ee == "string" ? D.encode(ee) : ee;
        Ce.byteLength && fe.enqueue(Ce), queueMicrotask(() => s(fe));
      },
      start() {
      },
      type: "bytes"
    }), m(n(J));
    let te = null, ee = null, de = null, ue = null;
    if (typeof F == "string")
      ee = F, ue = "text/plain;charset=UTF-8";
    else if (F instanceof URLSearchParams)
      ee = F.toString(), ue = "application/x-www-form-urlencoded;charset=UTF-8";
    else if (p(F))
      ee = new Uint8Array(F.slice());
    else if (ArrayBuffer.isView(F))
      ee = new Uint8Array(F.buffer.slice(F.byteOffset, F.byteOffset + F.byteLength));
    else if (t.isFormDataLike(F)) {
      const fe = `----formdata-undici-0${`${R(1e11)}`.padStart(11, "0")}`, Ce = `--${fe}\r
Content-Disposition: form-data`;
      const Z = ($) => $.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), _ = ($) => $.replace(/\r?\n|\r/g, `\r
`), ne = [], H = new Uint8Array([13, 10]);
      de = 0;
      let W = !1;
      for (const [$, Ae] of F)
        if (typeof Ae == "string") {
          const pe = D.encode(Ce + `; name="${Z(_($))}"\r
\r
${_(Ae)}\r
`);
          ne.push(pe), de += pe.byteLength;
        } else {
          const pe = D.encode(`${Ce}; name="${Z(_($))}"` + (Ae.name ? `; filename="${Z(Ae.name)}"` : "") + `\r
Content-Type: ${Ae.type || "application/octet-stream"}\r
\r
`);
          ne.push(pe, Ae, H), typeof Ae.size == "number" ? de += pe.byteLength + Ae.size + H.byteLength : W = !0;
        }
      const z = D.encode(`--${fe}--\r
`);
      ne.push(z), de += z.byteLength, W && (de = null), ee = F, te = async function* () {
        for (const $ of ne)
          $.stream ? yield* $.stream() : yield $;
      }, ue = `multipart/form-data; boundary=${fe}`;
    } else if (r(F))
      ee = F, de = F.size, F.type && (ue = F.type);
    else if (typeof F[Symbol.asyncIterator] == "function") {
      if (P)
        throw new TypeError("keepalive");
      if (t.isDisturbed(F) || F.locked)
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      J = F instanceof ReadableStream ? F : e(F);
    }
    if ((typeof ee == "string" || t.isBuffer(ee)) && (de = Buffer.byteLength(ee)), te != null) {
      let fe;
      J = new ReadableStream({
        async start() {
          fe = te(F)[Symbol.asyncIterator]();
        },
        async pull(Ce) {
          const { value: Z, done: _ } = await fe.next();
          if (_)
            queueMicrotask(() => {
              Ce.close(), Ce.byobRequest?.respond(0);
            });
          else if (!h(J)) {
            const ne = new Uint8Array(Z);
            ne.byteLength && Ce.enqueue(ne);
          }
          return Ce.desiredSize > 0;
        },
        async cancel(Ce) {
          await fe.return();
        },
        type: "bytes"
      });
    }
    return [{ stream: J, source: ee, length: de }, ue];
  }
  function g(F, P = !1) {
    return F instanceof ReadableStream && (m(!t.isDisturbed(F), "The body has already been consumed."), m(!F.locked, "The stream is locked.")), x(F, P);
  }
  function B(F, P) {
    const [J, te] = P.stream.tee();
    return P.stream = J, {
      stream: te,
      length: P.length,
      source: P.source
    };
  }
  function Q(F) {
    if (F.aborted)
      throw new DOMException("The operation was aborted.", "AbortError");
  }
  function E(F) {
    return {
      blob() {
        return N(this, (J) => {
          let te = k(this);
          return te === null ? te = "" : te && (te = y(te)), new u([J], { type: te });
        }, F);
      },
      arrayBuffer() {
        return N(this, (J) => new Uint8Array(J).buffer, F);
      },
      text() {
        return N(this, A, F);
      },
      json() {
        return N(this, M, F);
      },
      formData() {
        return N(this, (J) => {
          const te = k(this);
          if (te !== null)
            switch (te.essence) {
              case "multipart/form-data": {
                const ee = w(J, te);
                if (ee === "failure")
                  throw new TypeError("Failed to parse body as FormData.");
                const de = new c();
                return de[l] = ee, de;
              }
              case "application/x-www-form-urlencoded": {
                const ee = new URLSearchParams(J.toString()), de = new c();
                for (const [ue, ce] of ee)
                  de.append(ue, ce);
                return de;
              }
            }
          throw new TypeError(
            'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
          );
        }, F);
      },
      bytes() {
        return N(this, (J) => new Uint8Array(J), F);
      }
    };
  }
  function b(F) {
    Object.assign(F.prototype, E(F));
  }
  async function N(F, P, J) {
    if (d.brandCheck(F, J), S(F))
      throw new TypeError("Body is unusable: Body has already been read");
    Q(F[l]);
    const te = i(), ee = (ue) => te.reject(ue), de = (ue) => {
      try {
        te.resolve(P(ue));
      } catch (ce) {
        ee(ce);
      }
    };
    return F[l].body == null ? (de(Buffer.allocUnsafe(0)), te.promise) : (await o(F[l].body, de, ee), te.promise);
  }
  function S(F) {
    const P = F[l].body;
    return P != null && (P.stream.locked || t.isDisturbed(P.stream));
  }
  function M(F) {
    return JSON.parse(A(F));
  }
  function k(F) {
    const P = F[l].headersList, J = a(P);
    return J === "failure" ? null : J;
  }
  return ha = {
    extractBody: x,
    safelyExtractBody: g,
    cloneBody: B,
    mixinBody: b,
    streamRegistry: I,
    hasFinalizationRegistry: C,
    bodyUnusable: S
  }, ha;
}
var ga, ru;
function Ly() {
  if (ru) return ga;
  ru = 1;
  const t = lt, e = Xe(), { channels: r } = Ws(), n = rf(), {
    RequestContentLengthMismatchError: s,
    ResponseContentLengthMismatchError: i,
    RequestAbortedError: o,
    HeadersTimeoutError: a,
    HeadersOverflowError: A,
    SocketError: c,
    InformationalError: l,
    BodyTimeoutError: d,
    HTTPParserError: u,
    ResponseExceededMaxSizeError: m
  } = it(), {
    kUrl: h,
    kReset: f,
    kClient: p,
    kParser: y,
    kBlocking: w,
    kRunning: R,
    kPending: D,
    kSize: L,
    kWriting: C,
    kQueue: I,
    kNoRef: x,
    kKeepAliveDefaultTimeout: g,
    kHostHeader: B,
    kPendingIdx: Q,
    kRunningIdx: E,
    kError: b,
    kPipelining: N,
    kSocket: S,
    kKeepAliveTimeoutValue: M,
    kMaxHeadersSize: k,
    kKeepAliveMaxTimeout: F,
    kKeepAliveTimeoutThreshold: P,
    kHeadersTimeout: J,
    kBodyTimeout: te,
    kStrictContentLength: ee,
    kMaxRequests: de,
    kCounter: ue,
    kMaxResponseSize: ce,
    kOnError: fe,
    kResume: Ce,
    kHTTPContext: Z
  } = gt(), _ = Ty(), ne = Buffer.alloc(0), H = Buffer[Symbol.species], W = e.addListener, z = e.removeAllListeners;
  let $;
  async function Ae() {
    const Se = process.env.JEST_WORKER_ID ? Yd() : void 0;
    let O;
    try {
      O = await WebAssembly.compile(Fy());
    } catch {
      O = await WebAssembly.compile(Se || Yd());
    }
    return await WebAssembly.instantiate(O, {
      env: {
        /* eslint-disable camelcase */
        wasm_on_url: (se, j, ie) => 0,
        wasm_on_status: (se, j, ie) => {
          t(xe.ptr === se);
          const Be = j - We + _e.byteOffset;
          return xe.onStatus(new H(_e.buffer, Be, ie)) || 0;
        },
        wasm_on_message_begin: (se) => (t(xe.ptr === se), xe.onMessageBegin() || 0),
        wasm_on_header_field: (se, j, ie) => {
          t(xe.ptr === se);
          const Be = j - We + _e.byteOffset;
          return xe.onHeaderField(new H(_e.buffer, Be, ie)) || 0;
        },
        wasm_on_header_value: (se, j, ie) => {
          t(xe.ptr === se);
          const Be = j - We + _e.byteOffset;
          return xe.onHeaderValue(new H(_e.buffer, Be, ie)) || 0;
        },
        wasm_on_headers_complete: (se, j, ie, Be) => (t(xe.ptr === se), xe.onHeadersComplete(j, !!ie, !!Be) || 0),
        wasm_on_body: (se, j, ie) => {
          t(xe.ptr === se);
          const Be = j - We + _e.byteOffset;
          return xe.onBody(new H(_e.buffer, Be, ie)) || 0;
        },
        wasm_on_message_complete: (se) => (t(xe.ptr === se), xe.onMessageComplete() || 0)
        /* eslint-enable camelcase */
      }
    });
  }
  let pe = null, me = Ae();
  me.catch();
  let xe = null, _e = null, ke = 0, We = null;
  const ve = 0, He = 1, Re = 2 | He, ut = 4 | He, At = 8 | ve;
  class rt {
    constructor(O, se, { exports: j }) {
      t(Number.isFinite(O[k]) && O[k] > 0), this.llhttp = j, this.ptr = this.llhttp.llhttp_alloc(_.TYPE.RESPONSE), this.client = O, this.socket = se, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = O[k], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = O[ce];
    }
    setTimeout(O, se) {
      O !== this.timeoutValue || se & He ^ this.timeoutType & He ? (this.timeout && (n.clearTimeout(this.timeout), this.timeout = null), O && (se & He ? this.timeout = n.setFastTimeout(re, O, new WeakRef(this)) : (this.timeout = setTimeout(re, O, new WeakRef(this)), this.timeout.unref())), this.timeoutValue = O) : this.timeout && this.timeout.refresh && this.timeout.refresh(), this.timeoutType = se;
    }
    resume() {
      this.socket.destroyed || !this.paused || (t(this.ptr != null), t(xe == null), this.llhttp.llhttp_resume(this.ptr), t(this.timeoutType === ut), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = !1, this.execute(this.socket.read() || ne), this.readMore());
    }
    readMore() {
      for (; !this.paused && this.ptr; ) {
        const O = this.socket.read();
        if (O === null)
          break;
        this.execute(O);
      }
    }
    execute(O) {
      t(this.ptr != null), t(xe == null), t(!this.paused);
      const { socket: se, llhttp: j } = this;
      O.length > ke && (We && j.free(We), ke = Math.ceil(O.length / 4096) * 4096, We = j.malloc(ke)), new Uint8Array(j.memory.buffer, We, ke).set(O);
      try {
        let ie;
        try {
          _e = O, xe = this, ie = j.llhttp_execute(this.ptr, We, O.length);
        } catch (Pe) {
          throw Pe;
        } finally {
          xe = null, _e = null;
        }
        const Be = j.llhttp_get_error_pos(this.ptr) - We;
        if (ie === _.ERROR.PAUSED_UPGRADE)
          this.onUpgrade(O.slice(Be));
        else if (ie === _.ERROR.PAUSED)
          this.paused = !0, se.unshift(O.slice(Be));
        else if (ie !== _.ERROR.OK) {
          const Pe = j.llhttp_get_error_reason(this.ptr);
          let Ye = "";
          if (Pe) {
            const U = new Uint8Array(j.memory.buffer, Pe).indexOf(0);
            Ye = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(j.memory.buffer, Pe, U).toString() + ")";
          }
          throw new u(Ye, _.ERROR[ie], O.slice(Be));
        }
      } catch (ie) {
        e.destroy(se, ie);
      }
    }
    destroy() {
      t(this.ptr != null), t(xe == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, this.timeout && n.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;
    }
    onStatus(O) {
      this.statusText = O.toString();
    }
    onMessageBegin() {
      const { socket: O, client: se } = this;
      if (O.destroyed)
        return -1;
      const j = se[I][se[E]];
      if (!j)
        return -1;
      j.onResponseStarted();
    }
    onHeaderField(O) {
      const se = this.headers.length;
      (se & 1) === 0 ? this.headers.push(O) : this.headers[se - 1] = Buffer.concat([this.headers[se - 1], O]), this.trackHeader(O.length);
    }
    onHeaderValue(O) {
      let se = this.headers.length;
      (se & 1) === 1 ? (this.headers.push(O), se += 1) : this.headers[se - 1] = Buffer.concat([this.headers[se - 1], O]);
      const j = this.headers[se - 2];
      if (j.length === 10) {
        const ie = e.bufferToLowerCasedHeaderName(j);
        ie === "keep-alive" ? this.keepAlive += O.toString() : ie === "connection" && (this.connection += O.toString());
      } else j.length === 14 && e.bufferToLowerCasedHeaderName(j) === "content-length" && (this.contentLength += O.toString());
      this.trackHeader(O.length);
    }
    trackHeader(O) {
      this.headersSize += O, this.headersSize >= this.headersMaxSize && e.destroy(this.socket, new A());
    }
    onUpgrade(O) {
      const { upgrade: se, client: j, socket: ie, headers: Be, statusCode: Pe } = this;
      t(se), t(j[S] === ie), t(!ie.destroyed), t(!this.paused), t((Be.length & 1) === 0);
      const Ye = j[I][j[E]];
      t(Ye), t(Ye.upgrade || Ye.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, this.headers = [], this.headersSize = 0, ie.unshift(O), ie[y].destroy(), ie[y] = null, ie[p] = null, ie[b] = null, z(ie), j[S] = null, j[Z] = null, j[I][j[E]++] = null, j.emit("disconnect", j[h], [j], new l("upgrade"));
      try {
        Ye.onUpgrade(Pe, Be, ie);
      } catch (U) {
        e.destroy(ie, U);
      }
      j[Ce]();
    }
    onHeadersComplete(O, se, j) {
      const { client: ie, socket: Be, headers: Pe, statusText: Ye } = this;
      if (Be.destroyed)
        return -1;
      const U = ie[I][ie[E]];
      if (!U)
        return -1;
      if (t(!this.upgrade), t(this.statusCode < 200), O === 100)
        return e.destroy(Be, new c("bad response", e.getSocketInfo(Be))), -1;
      if (se && !U.upgrade)
        return e.destroy(Be, new c("bad upgrade", e.getSocketInfo(Be))), -1;
      if (t(this.timeoutType === Re), this.statusCode = O, this.shouldKeepAlive = j || // Override llhttp value which does not allow keepAlive for HEAD.
      U.method === "HEAD" && !Be[f] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
        const v = U.bodyTimeout != null ? U.bodyTimeout : ie[te];
        this.setTimeout(v, ut);
      } else this.timeout && this.timeout.refresh && this.timeout.refresh();
      if (U.method === "CONNECT")
        return t(ie[R] === 1), this.upgrade = !0, 2;
      if (se)
        return t(ie[R] === 1), this.upgrade = !0, 2;
      if (t((this.headers.length & 1) === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && ie[N]) {
        const v = this.keepAlive ? e.parseKeepAliveTimeout(this.keepAlive) : null;
        if (v != null) {
          const G = Math.min(
            v - ie[P],
            ie[F]
          );
          G <= 0 ? Be[f] = !0 : ie[M] = G;
        } else
          ie[M] = ie[g];
      } else
        Be[f] = !0;
      const V = U.onHeaders(O, Pe, this.resume, Ye) === !1;
      return U.aborted ? -1 : U.method === "HEAD" || O < 200 ? 1 : (Be[w] && (Be[w] = !1, ie[Ce]()), V ? _.ERROR.PAUSED : 0);
    }
    onBody(O) {
      const { client: se, socket: j, statusCode: ie, maxResponseSize: Be } = this;
      if (j.destroyed)
        return -1;
      const Pe = se[I][se[E]];
      if (t(Pe), t(this.timeoutType === ut), this.timeout && this.timeout.refresh && this.timeout.refresh(), t(ie >= 200), Be > -1 && this.bytesRead + O.length > Be)
        return e.destroy(j, new m()), -1;
      if (this.bytesRead += O.length, Pe.onData(O) === !1)
        return _.ERROR.PAUSED;
    }
    onMessageComplete() {
      const { client: O, socket: se, statusCode: j, upgrade: ie, headers: Be, contentLength: Pe, bytesRead: Ye, shouldKeepAlive: U } = this;
      if (se.destroyed && (!j || U))
        return -1;
      if (ie)
        return;
      t(j >= 100), t((this.headers.length & 1) === 0);
      const V = O[I][O[E]];
      if (t(V), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", this.headers = [], this.headersSize = 0, !(j < 200)) {
        if (V.method !== "HEAD" && Pe && Ye !== parseInt(Pe, 10))
          return e.destroy(se, new i()), -1;
        if (V.onComplete(Be), O[I][O[E]++] = null, se[C])
          return t(O[R] === 0), e.destroy(se, new l("reset")), _.ERROR.PAUSED;
        if (U) {
          if (se[f] && O[R] === 0)
            return e.destroy(se, new l("reset")), _.ERROR.PAUSED;
          O[N] == null || O[N] === 1 ? setImmediate(() => O[Ce]()) : O[Ce]();
        } else return e.destroy(se, new l("reset")), _.ERROR.PAUSED;
      }
    }
  }
  function re(Se) {
    const { socket: O, timeoutType: se, client: j, paused: ie } = Se.deref();
    se === Re ? (!O[C] || O.writableNeedDrain || j[R] > 1) && (t(!ie, "cannot be paused while waiting for headers"), e.destroy(O, new a())) : se === ut ? ie || e.destroy(O, new d()) : se === At && (t(j[R] === 0 && j[M]), e.destroy(O, new l("socket idle timeout")));
  }
  async function T(Se, O) {
    Se[S] = O, pe || (pe = await me, me = null), O[x] = !1, O[C] = !1, O[f] = !1, O[w] = !1, O[y] = new rt(Se, O, pe), W(O, "error", function(j) {
      t(j.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      const ie = this[y];
      if (j.code === "ECONNRESET" && ie.statusCode && !ie.shouldKeepAlive) {
        ie.onMessageComplete();
        return;
      }
      this[b] = j, this[p][fe](j);
    }), W(O, "readable", function() {
      const j = this[y];
      j && j.readMore();
    }), W(O, "end", function() {
      const j = this[y];
      if (j.statusCode && !j.shouldKeepAlive) {
        j.onMessageComplete();
        return;
      }
      e.destroy(this, new c("other side closed", e.getSocketInfo(this)));
    }), W(O, "close", function() {
      const j = this[p], ie = this[y];
      ie && (!this[b] && ie.statusCode && !ie.shouldKeepAlive && ie.onMessageComplete(), this[y].destroy(), this[y] = null);
      const Be = this[b] || new c("closed", e.getSocketInfo(this));
      if (j[S] = null, j[Z] = null, j.destroyed) {
        t(j[D] === 0);
        const Pe = j[I].splice(j[E]);
        for (let Ye = 0; Ye < Pe.length; Ye++) {
          const U = Pe[Ye];
          e.errorRequest(j, U, Be);
        }
      } else if (j[R] > 0 && Be.code !== "UND_ERR_INFO") {
        const Pe = j[I][j[E]];
        j[I][j[E]++] = null, e.errorRequest(j, Pe, Be);
      }
      j[Q] = j[E], t(j[R] === 0), j.emit("disconnect", j[h], [j], Be), j[Ce]();
    });
    let se = !1;
    return O.on("close", () => {
      se = !0;
    }), {
      version: "h1",
      defaultPipelining: 1,
      write(...j) {
        return Ee(Se, ...j);
      },
      resume() {
        X(Se);
      },
      destroy(j, ie) {
        se ? queueMicrotask(ie) : O.destroy(j).on("close", ie);
      },
      get destroyed() {
        return O.destroyed;
      },
      busy(j) {
        return !!(O[C] || O[f] || O[w] || j && (Se[R] > 0 && !j.idempotent || Se[R] > 0 && (j.upgrade || j.method === "CONNECT") || Se[R] > 0 && e.bodyLength(j.body) !== 0 && (e.isStream(j.body) || e.isAsyncIterable(j.body) || e.isFormDataLike(j.body))));
      }
    };
  }
  function X(Se) {
    const O = Se[S];
    if (O && !O.destroyed) {
      if (Se[L] === 0 ? !O[x] && O.unref && (O.unref(), O[x] = !0) : O[x] && O.ref && (O.ref(), O[x] = !1), Se[L] === 0)
        O[y].timeoutType !== At && O[y].setTimeout(Se[M], At);
      else if (Se[R] > 0 && O[y].statusCode < 200 && O[y].timeoutType !== Re) {
        const se = Se[I][Se[E]], j = se.headersTimeout != null ? se.headersTimeout : Se[J];
        O[y].setTimeout(j, Re);
      }
    }
  }
  function he(Se) {
    return Se !== "GET" && Se !== "HEAD" && Se !== "OPTIONS" && Se !== "TRACE" && Se !== "CONNECT";
  }
  function Ee(Se, O) {
    const { method: se, path: j, host: ie, upgrade: Be, blocking: Pe, reset: Ye } = O;
    let { body: U, headers: V, contentLength: v } = O;
    const G = se === "PUT" || se === "POST" || se === "PATCH" || se === "QUERY" || se === "PROPFIND" || se === "PROPPATCH";
    if (e.isFormDataLike(U)) {
      $ || ($ = Xs().extractBody);
      const [ge, ze] = $(U);
      O.contentType == null && V.push("content-type", ze), U = ge.stream, v = ge.length;
    } else e.isBlobLike(U) && O.contentType == null && U.type && V.push("content-type", U.type);
    U && typeof U.read == "function" && U.read(0);
    const q = e.bodyLength(U);
    if (v = q ?? v, v === null && (v = O.contentLength), v === 0 && !G && (v = null), he(se) && v > 0 && O.contentLength !== null && O.contentLength !== v) {
      if (Se[ee])
        return e.errorRequest(Se, O, new s()), !1;
      process.emitWarning(new s());
    }
    const Y = Se[S], oe = (ge) => {
      O.aborted || O.completed || (e.errorRequest(Se, O, ge || new o()), e.destroy(U), e.destroy(Y, new l("aborted")));
    };
    try {
      O.onConnect(oe);
    } catch (ge) {
      e.errorRequest(Se, O, ge);
    }
    if (O.aborted)
      return !1;
    se === "HEAD" && (Y[f] = !0), (Be || se === "CONNECT") && (Y[f] = !0), Ye != null && (Y[f] = Ye), Se[de] && Y[ue]++ >= Se[de] && (Y[f] = !0), Pe && (Y[w] = !0);
    let K = `${se} ${j} HTTP/1.1\r
`;
    if (typeof ie == "string" ? K += `host: ${ie}\r
` : K += Se[B], Be ? K += `connection: upgrade\r
upgrade: ${Be}\r
` : Se[N] && !Y[f] ? K += `connection: keep-alive\r
` : K += `connection: close\r
`, Array.isArray(V))
      for (let ge = 0; ge < V.length; ge += 2) {
        const ze = V[ge + 0], je = V[ge + 1];
        if (Array.isArray(je))
          for (let Ze = 0; Ze < je.length; Ze++)
            K += `${ze}: ${je[Ze]}\r
`;
        else
          K += `${ze}: ${je}\r
`;
      }
    return r.sendHeaders.hasSubscribers && r.sendHeaders.publish({ request: O, headers: K, socket: Y }), !U || q === 0 ? Le(oe, null, Se, O, Y, v, K, G) : e.isBuffer(U) ? Le(oe, U, Se, O, Y, v, K, G) : e.isBlobLike(U) ? typeof U.stream == "function" ? Bt(oe, U.stream(), Se, O, Y, v, K, G) : st(oe, U, Se, O, Y, v, K, G) : e.isStream(U) ? be(oe, U, Se, O, Y, v, K, G) : e.isIterable(U) ? Bt(oe, U, Se, O, Y, v, K, G) : t(!1), !0;
  }
  function be(Se, O, se, j, ie, Be, Pe, Ye) {
    t(Be !== 0 || se[R] === 0, "stream body cannot be pipelined");
    let U = !1;
    const V = new wt({ abort: Se, socket: ie, request: j, contentLength: Be, client: se, expectsPayload: Ye, header: Pe }), v = function(oe) {
      if (!U)
        try {
          !V.write(oe) && this.pause && this.pause();
        } catch (K) {
          e.destroy(this, K);
        }
    }, G = function() {
      U || O.resume && O.resume();
    }, q = function() {
      if (queueMicrotask(() => {
        O.removeListener("error", Y);
      }), !U) {
        const oe = new o();
        queueMicrotask(() => Y(oe));
      }
    }, Y = function(oe) {
      if (!U) {
        if (U = !0, t(ie.destroyed || ie[C] && se[R] <= 1), ie.off("drain", G).off("error", Y), O.removeListener("data", v).removeListener("end", Y).removeListener("close", q), !oe)
          try {
            V.end();
          } catch (K) {
            oe = K;
          }
        V.destroy(oe), oe && (oe.code !== "UND_ERR_INFO" || oe.message !== "reset") ? e.destroy(O, oe) : e.destroy(O);
      }
    };
    O.on("data", v).on("end", Y).on("error", Y).on("close", q), O.resume && O.resume(), ie.on("drain", G).on("error", Y), O.errorEmitted ?? O.errored ? setImmediate(() => Y(O.errored)) : (O.endEmitted ?? O.readableEnded) && setImmediate(() => Y(null)), (O.closeEmitted ?? O.closed) && setImmediate(q);
  }
  function Le(Se, O, se, j, ie, Be, Pe, Ye) {
    try {
      O ? e.isBuffer(O) && (t(Be === O.byteLength, "buffer body must have content length"), ie.cork(), ie.write(`${Pe}content-length: ${Be}\r
\r
`, "latin1"), ie.write(O), ie.uncork(), j.onBodySent(O), !Ye && j.reset !== !1 && (ie[f] = !0)) : Be === 0 ? ie.write(`${Pe}content-length: 0\r
\r
`, "latin1") : (t(Be === null, "no body must not have content length"), ie.write(`${Pe}\r
`, "latin1")), j.onRequestSent(), se[Ce]();
    } catch (U) {
      Se(U);
    }
  }
  async function st(Se, O, se, j, ie, Be, Pe, Ye) {
    t(Be === O.size, "blob body must have content length");
    try {
      if (Be != null && Be !== O.size)
        throw new s();
      const U = Buffer.from(await O.arrayBuffer());
      ie.cork(), ie.write(`${Pe}content-length: ${Be}\r
\r
`, "latin1"), ie.write(U), ie.uncork(), j.onBodySent(U), j.onRequestSent(), !Ye && j.reset !== !1 && (ie[f] = !0), se[Ce]();
    } catch (U) {
      Se(U);
    }
  }
  async function Bt(Se, O, se, j, ie, Be, Pe, Ye) {
    t(Be !== 0 || se[R] === 0, "iterator body cannot be pipelined");
    let U = null;
    function V() {
      if (U) {
        const q = U;
        U = null, q();
      }
    }
    const v = () => new Promise((q, Y) => {
      t(U === null), ie[b] ? Y(ie[b]) : U = q;
    });
    ie.on("close", V).on("drain", V);
    const G = new wt({ abort: Se, socket: ie, request: j, contentLength: Be, client: se, expectsPayload: Ye, header: Pe });
    try {
      for await (const q of O) {
        if (ie[b])
          throw ie[b];
        G.write(q) || await v();
      }
      G.end();
    } catch (q) {
      G.destroy(q);
    } finally {
      ie.off("close", V).off("drain", V);
    }
  }
  class wt {
    constructor({ abort: O, socket: se, request: j, contentLength: ie, client: Be, expectsPayload: Pe, header: Ye }) {
      this.socket = se, this.request = j, this.contentLength = ie, this.client = Be, this.bytesWritten = 0, this.expectsPayload = Pe, this.header = Ye, this.abort = O, se[C] = !0;
    }
    write(O) {
      const { socket: se, request: j, contentLength: ie, client: Be, bytesWritten: Pe, expectsPayload: Ye, header: U } = this;
      if (se[b])
        throw se[b];
      if (se.destroyed)
        return !1;
      const V = Buffer.byteLength(O);
      if (!V)
        return !0;
      if (ie !== null && Pe + V > ie) {
        if (Be[ee])
          throw new s();
        process.emitWarning(new s());
      }
      se.cork(), Pe === 0 && (!Ye && j.reset !== !1 && (se[f] = !0), ie === null ? se.write(`${U}transfer-encoding: chunked\r
`, "latin1") : se.write(`${U}content-length: ${ie}\r
\r
`, "latin1")), ie === null && se.write(`\r
${V.toString(16)}\r
`, "latin1"), this.bytesWritten += V;
      const v = se.write(O);
      return se.uncork(), j.onBodySent(O), v || se[y].timeout && se[y].timeoutType === Re && se[y].timeout.refresh && se[y].timeout.refresh(), v;
    }
    end() {
      const { socket: O, contentLength: se, client: j, bytesWritten: ie, expectsPayload: Be, header: Pe, request: Ye } = this;
      if (Ye.onRequestSent(), O[C] = !1, O[b])
        throw O[b];
      if (!O.destroyed) {
        if (ie === 0 ? Be ? O.write(`${Pe}content-length: 0\r
\r
`, "latin1") : O.write(`${Pe}\r
`, "latin1") : se === null && O.write(`\r
0\r
\r
`, "latin1"), se !== null && ie !== se) {
          if (j[ee])
            throw new s();
          process.emitWarning(new s());
        }
        O[y].timeout && O[y].timeoutType === Re && O[y].timeout.refresh && O[y].timeout.refresh(), j[Ce]();
      }
    }
    destroy(O) {
      const { socket: se, client: j, abort: ie } = this;
      se[C] = !1, O && (t(j[R] <= 1, "pipeline should only contain this request"), ie(O));
    }
  }
  return ga = T, ga;
}
var fa, nu;
function Uy() {
  if (nu) return fa;
  nu = 1;
  const t = lt, { pipeline: e } = dr, r = Xe(), {
    RequestContentLengthMismatchError: n,
    RequestAbortedError: s,
    SocketError: i,
    InformationalError: o
  } = it(), {
    kUrl: a,
    kReset: A,
    kClient: c,
    kRunning: l,
    kPending: d,
    kQueue: u,
    kPendingIdx: m,
    kRunningIdx: h,
    kError: f,
    kSocket: p,
    kStrictContentLength: y,
    kOnError: w,
    kMaxConcurrentStreams: R,
    kHTTP2Session: D,
    kResume: L,
    kSize: C,
    kHTTPContext: I
  } = gt(), x = /* @__PURE__ */ Symbol("open streams");
  let g, B = !1, Q;
  try {
    Q = Wn("node:http2");
  } catch {
    Q = { constants: {} };
  }
  const {
    constants: {
      HTTP2_HEADER_AUTHORITY: E,
      HTTP2_HEADER_METHOD: b,
      HTTP2_HEADER_PATH: N,
      HTTP2_HEADER_SCHEME: S,
      HTTP2_HEADER_CONTENT_LENGTH: M,
      HTTP2_HEADER_EXPECT: k,
      HTTP2_HEADER_STATUS: F
    }
  } = Q;
  function P(W) {
    const z = [];
    for (const [$, Ae] of Object.entries(W))
      if (Array.isArray(Ae))
        for (const pe of Ae)
          z.push(Buffer.from($), Buffer.from(pe));
      else
        z.push(Buffer.from($), Buffer.from(Ae));
    return z;
  }
  async function J(W, z) {
    W[p] = z, B || (B = !0, process.emitWarning("H2 support is experimental, expect them to change at any time.", {
      code: "UNDICI-H2"
    }));
    const $ = Q.connect(W[a], {
      createConnection: () => z,
      peerMaxConcurrentStreams: W[R]
    });
    $[x] = 0, $[c] = W, $[p] = z, r.addListener($, "error", ee), r.addListener($, "frameError", de), r.addListener($, "end", ue), r.addListener($, "goaway", ce), r.addListener($, "close", function() {
      const { [c]: pe } = this, { [p]: me } = pe, xe = this[p][f] || this[f] || new i("closed", r.getSocketInfo(me));
      if (pe[D] = null, pe.destroyed) {
        t(pe[d] === 0);
        const _e = pe[u].splice(pe[h]);
        for (let ke = 0; ke < _e.length; ke++) {
          const We = _e[ke];
          r.errorRequest(pe, We, xe);
        }
      }
    }), $.unref(), W[D] = $, z[D] = $, r.addListener(z, "error", function(pe) {
      t(pe.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[f] = pe, this[c][w](pe);
    }), r.addListener(z, "end", function() {
      r.destroy(this, new i("other side closed", r.getSocketInfo(this)));
    }), r.addListener(z, "close", function() {
      const pe = this[f] || new i("closed", r.getSocketInfo(this));
      W[p] = null, this[D] != null && this[D].destroy(pe), W[m] = W[h], t(W[l] === 0), W.emit("disconnect", W[a], [W], pe), W[L]();
    });
    let Ae = !1;
    return z.on("close", () => {
      Ae = !0;
    }), {
      version: "h2",
      defaultPipelining: 1 / 0,
      write(...pe) {
        return Ce(W, ...pe);
      },
      resume() {
        te(W);
      },
      destroy(pe, me) {
        Ae ? queueMicrotask(me) : z.destroy(pe).on("close", me);
      },
      get destroyed() {
        return z.destroyed;
      },
      busy() {
        return !1;
      }
    };
  }
  function te(W) {
    const z = W[p];
    z?.destroyed === !1 && (W[C] === 0 && W[R] === 0 ? (z.unref(), W[D].unref()) : (z.ref(), W[D].ref()));
  }
  function ee(W) {
    t(W.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[p][f] = W, this[c][w](W);
  }
  function de(W, z, $) {
    if ($ === 0) {
      const Ae = new o(`HTTP/2: "frameError" received - type ${W}, code ${z}`);
      this[p][f] = Ae, this[c][w](Ae);
    }
  }
  function ue() {
    const W = new i("other side closed", r.getSocketInfo(this[p]));
    this.destroy(W), r.destroy(this[p], W);
  }
  function ce(W) {
    const z = this[f] || new i(`HTTP/2: "GOAWAY" frame received with code ${W}`, r.getSocketInfo(this)), $ = this[c];
    if ($[p] = null, $[I] = null, this[D] != null && (this[D].destroy(z), this[D] = null), r.destroy(this[p], z), $[h] < $[u].length) {
      const Ae = $[u][$[h]];
      $[u][$[h]++] = null, r.errorRequest($, Ae, z), $[m] = $[h];
    }
    t($[l] === 0), $.emit("disconnect", $[a], [$], z), $[L]();
  }
  function fe(W) {
    return W !== "GET" && W !== "HEAD" && W !== "OPTIONS" && W !== "TRACE" && W !== "CONNECT";
  }
  function Ce(W, z) {
    const $ = W[D], { method: Ae, path: pe, host: me, upgrade: xe, expectContinue: _e, signal: ke, headers: We } = z;
    let { body: ve } = z;
    if (xe)
      return r.errorRequest(W, z, new Error("Upgrade not supported for H2")), !1;
    const He = {};
    for (let Ee = 0; Ee < We.length; Ee += 2) {
      const be = We[Ee + 0], Le = We[Ee + 1];
      if (Array.isArray(Le))
        for (let st = 0; st < Le.length; st++)
          He[be] ? He[be] += `,${Le[st]}` : He[be] = Le[st];
      else
        He[be] = Le;
    }
    let Re;
    const { hostname: ut, port: At } = W[a];
    He[E] = me || `${ut}${At ? `:${At}` : ""}`, He[b] = Ae;
    const rt = (Ee) => {
      z.aborted || z.completed || (Ee = Ee || new s(), r.errorRequest(W, z, Ee), Re != null && r.destroy(Re, Ee), r.destroy(ve, Ee), W[u][W[h]++] = null, W[L]());
    };
    try {
      z.onConnect(rt);
    } catch (Ee) {
      r.errorRequest(W, z, Ee);
    }
    if (z.aborted)
      return !1;
    if (Ae === "CONNECT")
      return $.ref(), Re = $.request(He, { endStream: !1, signal: ke }), Re.id && !Re.pending ? (z.onUpgrade(null, null, Re), ++$[x], W[u][W[h]++] = null) : Re.once("ready", () => {
        z.onUpgrade(null, null, Re), ++$[x], W[u][W[h]++] = null;
      }), Re.once("close", () => {
        $[x] -= 1, $[x] === 0 && $.unref();
      }), !0;
    He[N] = pe, He[S] = "https";
    const re = Ae === "PUT" || Ae === "POST" || Ae === "PATCH";
    ve && typeof ve.read == "function" && ve.read(0);
    let T = r.bodyLength(ve);
    if (r.isFormDataLike(ve)) {
      g ??= Xs().extractBody;
      const [Ee, be] = g(ve);
      He["content-type"] = be, ve = Ee.stream, T = Ee.length;
    }
    if (T == null && (T = z.contentLength), (T === 0 || !re) && (T = null), fe(Ae) && T > 0 && z.contentLength != null && z.contentLength !== T) {
      if (W[y])
        return r.errorRequest(W, z, new n()), !1;
      process.emitWarning(new n());
    }
    T != null && (t(ve, "no body must not have content length"), He[M] = `${T}`), $.ref();
    const X = Ae === "GET" || Ae === "HEAD" || ve === null;
    return _e ? (He[k] = "100-continue", Re = $.request(He, { endStream: X, signal: ke }), Re.once("continue", he)) : (Re = $.request(He, {
      endStream: X,
      signal: ke
    }), he()), ++$[x], Re.once("response", (Ee) => {
      const { [F]: be, ...Le } = Ee;
      if (z.onResponseStarted(), z.aborted) {
        const st = new s();
        r.errorRequest(W, z, st), r.destroy(Re, st);
        return;
      }
      z.onHeaders(Number(be), P(Le), Re.resume.bind(Re), "") === !1 && Re.pause(), Re.on("data", (st) => {
        z.onData(st) === !1 && Re.pause();
      });
    }), Re.once("end", () => {
      (Re.state?.state == null || Re.state.state < 6) && z.onComplete([]), $[x] === 0 && $.unref(), rt(new o("HTTP/2: stream half-closed (remote)")), W[u][W[h]++] = null, W[m] = W[h], W[L]();
    }), Re.once("close", () => {
      $[x] -= 1, $[x] === 0 && $.unref();
    }), Re.once("error", function(Ee) {
      rt(Ee);
    }), Re.once("frameError", (Ee, be) => {
      rt(new o(`HTTP/2: "frameError" received - type ${Ee}, code ${be}`));
    }), !0;
    function he() {
      !ve || T === 0 ? Z(
        rt,
        Re,
        null,
        W,
        z,
        W[p],
        T,
        re
      ) : r.isBuffer(ve) ? Z(
        rt,
        Re,
        ve,
        W,
        z,
        W[p],
        T,
        re
      ) : r.isBlobLike(ve) ? typeof ve.stream == "function" ? H(
        rt,
        Re,
        ve.stream(),
        W,
        z,
        W[p],
        T,
        re
      ) : ne(
        rt,
        Re,
        ve,
        W,
        z,
        W[p],
        T,
        re
      ) : r.isStream(ve) ? _(
        rt,
        W[p],
        re,
        Re,
        ve,
        W,
        z,
        T
      ) : r.isIterable(ve) ? H(
        rt,
        Re,
        ve,
        W,
        z,
        W[p],
        T,
        re
      ) : t(!1);
    }
  }
  function Z(W, z, $, Ae, pe, me, xe, _e) {
    try {
      $ != null && r.isBuffer($) && (t(xe === $.byteLength, "buffer body must have content length"), z.cork(), z.write($), z.uncork(), z.end(), pe.onBodySent($)), _e || (me[A] = !0), pe.onRequestSent(), Ae[L]();
    } catch (ke) {
      W(ke);
    }
  }
  function _(W, z, $, Ae, pe, me, xe, _e) {
    t(_e !== 0 || me[l] === 0, "stream body cannot be pipelined");
    const ke = e(
      pe,
      Ae,
      (ve) => {
        ve ? (r.destroy(ke, ve), W(ve)) : (r.removeAllListeners(ke), xe.onRequestSent(), $ || (z[A] = !0), me[L]());
      }
    );
    r.addListener(ke, "data", We);
    function We(ve) {
      xe.onBodySent(ve);
    }
  }
  async function ne(W, z, $, Ae, pe, me, xe, _e) {
    t(xe === $.size, "blob body must have content length");
    try {
      if (xe != null && xe !== $.size)
        throw new n();
      const ke = Buffer.from(await $.arrayBuffer());
      z.cork(), z.write(ke), z.uncork(), z.end(), pe.onBodySent(ke), pe.onRequestSent(), _e || (me[A] = !0), Ae[L]();
    } catch (ke) {
      W(ke);
    }
  }
  async function H(W, z, $, Ae, pe, me, xe, _e) {
    t(xe !== 0 || Ae[l] === 0, "iterator body cannot be pipelined");
    let ke = null;
    function We() {
      if (ke) {
        const He = ke;
        ke = null, He();
      }
    }
    const ve = () => new Promise((He, Re) => {
      t(ke === null), me[f] ? Re(me[f]) : ke = He;
    });
    z.on("close", We).on("drain", We);
    try {
      for await (const He of $) {
        if (me[f])
          throw me[f];
        const Re = z.write(He);
        pe.onBodySent(He), Re || await ve();
      }
      z.end(), pe.onRequestSent(), _e || (me[A] = !0), Ae[L]();
    } catch (He) {
      W(He);
    } finally {
      z.off("close", We).off("drain", We);
    }
  }
  return fa = J, fa;
}
var pa, su;
function Il() {
  if (su) return pa;
  su = 1;
  const t = Xe(), { kBodyUsed: e } = gt(), r = lt, { InvalidArgumentError: n } = it(), s = Vs, i = [300, 301, 302, 303, 307, 308], o = /* @__PURE__ */ Symbol("body");
  class a {
    constructor(m) {
      this[o] = m, this[e] = !1;
    }
    async *[Symbol.asyncIterator]() {
      r(!this[e], "disturbed"), this[e] = !0, yield* this[o];
    }
  }
  class A {
    constructor(m, h, f, p) {
      if (h != null && (!Number.isInteger(h) || h < 0))
        throw new n("maxRedirections must be a positive number");
      t.validateHandler(p, f.method, f.upgrade), this.dispatch = m, this.location = null, this.abort = null, this.opts = { ...f, maxRedirections: 0 }, this.maxRedirections = h, this.handler = p, this.history = [], this.redirectionLimitReached = !1, t.isStream(this.opts.body) ? (t.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
        r(!1);
      }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[e] = !1, s.prototype.on.call(this.opts.body, "data", function() {
        this[e] = !0;
      }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new a(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && t.isIterable(this.opts.body) && (this.opts.body = new a(this.opts.body));
    }
    onConnect(m) {
      this.abort = m, this.handler.onConnect(m, { history: this.history });
    }
    onUpgrade(m, h, f) {
      this.handler.onUpgrade(m, h, f);
    }
    onError(m) {
      this.handler.onError(m);
    }
    onHeaders(m, h, f, p) {
      if (this.location = this.history.length >= this.maxRedirections || t.isDisturbed(this.opts.body) ? null : c(m, h), this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        this.request && this.request.abort(new Error("max redirects")), this.redirectionLimitReached = !0, this.abort(new Error("max redirects"));
        return;
      }
      if (this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location)
        return this.handler.onHeaders(m, h, f, p);
      const { origin: y, pathname: w, search: R } = t.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), D = R ? `${w}${R}` : w;
      this.opts.headers = d(this.opts.headers, m === 303, this.opts.origin !== y), this.opts.path = D, this.opts.origin = y, this.opts.maxRedirections = 0, this.opts.query = null, m === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
    }
    onData(m) {
      if (!this.location) return this.handler.onData(m);
    }
    onComplete(m) {
      this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(m);
    }
    onBodySent(m) {
      this.handler.onBodySent && this.handler.onBodySent(m);
    }
  }
  function c(u, m) {
    if (i.indexOf(u) === -1)
      return null;
    for (let h = 0; h < m.length; h += 2)
      if (m[h].length === 8 && t.headerNameToString(m[h]) === "location")
        return m[h + 1];
  }
  function l(u, m, h) {
    if (u.length === 4)
      return t.headerNameToString(u) === "host";
    if (m && t.headerNameToString(u).startsWith("content-"))
      return !0;
    if (h && (u.length === 13 || u.length === 6 || u.length === 19)) {
      const f = t.headerNameToString(u);
      return f === "authorization" || f === "cookie" || f === "proxy-authorization";
    }
    return !1;
  }
  function d(u, m, h) {
    const f = [];
    if (Array.isArray(u))
      for (let p = 0; p < u.length; p += 2)
        l(u[p], m, h) || f.push(u[p], u[p + 1]);
    else if (u && typeof u == "object")
      for (const p of Object.keys(u))
        l(p, m, h) || f.push(p, u[p]);
    else
      r(u == null, "headers must be an object or an array");
    return f;
  }
  return pa = A, pa;
}
var Ea, iu;
function yl() {
  if (iu) return Ea;
  iu = 1;
  const t = Il();
  function e({ maxRedirections: r }) {
    return (n) => function(i, o) {
      const { maxRedirections: a = r } = i;
      if (!a)
        return n(i, o);
      const A = new t(n, a, i, o);
      return i = { ...i, maxRedirections: 0 }, n(i, A);
    };
  }
  return Ea = e, Ea;
}
var Ca, ou;
function Zs() {
  if (ou) return Ca;
  ou = 1;
  const t = lt, e = Xi, r = Bn, n = Xe(), { channels: s } = Ws(), i = ky(), o = $s(), {
    InvalidArgumentError: a,
    InformationalError: A,
    ClientDestroyedError: c
  } = it(), l = Ki(), {
    kUrl: d,
    kServerName: u,
    kClient: m,
    kBusy: h,
    kConnect: f,
    kResuming: p,
    kRunning: y,
    kPending: w,
    kSize: R,
    kQueue: D,
    kConnected: L,
    kConnecting: C,
    kNeedDrain: I,
    kKeepAliveDefaultTimeout: x,
    kHostHeader: g,
    kPendingIdx: B,
    kRunningIdx: Q,
    kError: E,
    kPipelining: b,
    kKeepAliveTimeoutValue: N,
    kMaxHeadersSize: S,
    kKeepAliveMaxTimeout: M,
    kKeepAliveTimeoutThreshold: k,
    kHeadersTimeout: F,
    kBodyTimeout: P,
    kStrictContentLength: J,
    kConnector: te,
    kMaxRedirections: ee,
    kMaxRequests: de,
    kCounter: ue,
    kClose: ce,
    kDestroy: fe,
    kDispatch: Ce,
    kInterceptors: Z,
    kLocalAddress: _,
    kMaxResponseSize: ne,
    kOnError: H,
    kHTTPContext: W,
    kMaxConcurrentStreams: z,
    kResume: $
  } = gt(), Ae = Ly(), pe = Uy();
  let me = !1;
  const xe = /* @__PURE__ */ Symbol("kClosedResolve"), _e = () => {
  };
  function ke(re) {
    return re[b] ?? re[W]?.defaultPipelining ?? 1;
  }
  class We extends o {
    /**
     *
     * @param {string|URL} url
     * @param {import('../../types/client.js').Client.Options} options
     */
    constructor(T, {
      interceptors: X,
      maxHeaderSize: he,
      headersTimeout: Ee,
      socketTimeout: be,
      requestTimeout: Le,
      connectTimeout: st,
      bodyTimeout: Bt,
      idleTimeout: wt,
      keepAlive: Se,
      keepAliveTimeout: O,
      maxKeepAliveTimeout: se,
      keepAliveMaxTimeout: j,
      keepAliveTimeoutThreshold: ie,
      socketPath: Be,
      pipelining: Pe,
      tls: Ye,
      strictContentLength: U,
      maxCachedSessions: V,
      maxRedirections: v,
      connect: G,
      maxRequestsPerClient: q,
      localAddress: Y,
      maxResponseSize: oe,
      autoSelectFamily: K,
      autoSelectFamilyAttemptTimeout: ge,
      // h2
      maxConcurrentStreams: ze,
      allowH2: je
    } = {}) {
      if (super(), Se !== void 0)
        throw new a("unsupported keepAlive, use pipelining=0 instead");
      if (be !== void 0)
        throw new a("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      if (Le !== void 0)
        throw new a("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      if (wt !== void 0)
        throw new a("unsupported idleTimeout, use keepAliveTimeout instead");
      if (se !== void 0)
        throw new a("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      if (he != null && !Number.isFinite(he))
        throw new a("invalid maxHeaderSize");
      if (Be != null && typeof Be != "string")
        throw new a("invalid socketPath");
      if (st != null && (!Number.isFinite(st) || st < 0))
        throw new a("invalid connectTimeout");
      if (O != null && (!Number.isFinite(O) || O <= 0))
        throw new a("invalid keepAliveTimeout");
      if (j != null && (!Number.isFinite(j) || j <= 0))
        throw new a("invalid keepAliveMaxTimeout");
      if (ie != null && !Number.isFinite(ie))
        throw new a("invalid keepAliveTimeoutThreshold");
      if (Ee != null && (!Number.isInteger(Ee) || Ee < 0))
        throw new a("headersTimeout must be a positive integer or zero");
      if (Bt != null && (!Number.isInteger(Bt) || Bt < 0))
        throw new a("bodyTimeout must be a positive integer or zero");
      if (G != null && typeof G != "function" && typeof G != "object")
        throw new a("connect must be a function or an object");
      if (v != null && (!Number.isInteger(v) || v < 0))
        throw new a("maxRedirections must be a positive number");
      if (q != null && (!Number.isInteger(q) || q < 0))
        throw new a("maxRequestsPerClient must be a positive number");
      if (Y != null && (typeof Y != "string" || e.isIP(Y) === 0))
        throw new a("localAddress must be valid string IP address");
      if (oe != null && (!Number.isInteger(oe) || oe < -1))
        throw new a("maxResponseSize must be a positive number");
      if (ge != null && (!Number.isInteger(ge) || ge < -1))
        throw new a("autoSelectFamilyAttemptTimeout must be a positive number");
      if (je != null && typeof je != "boolean")
        throw new a("allowH2 must be a valid boolean value");
      if (ze != null && (typeof ze != "number" || ze < 1))
        throw new a("maxConcurrentStreams must be a positive integer, greater than 0");
      typeof G != "function" && (G = l({
        ...Ye,
        maxCachedSessions: V,
        allowH2: je,
        socketPath: Be,
        timeout: st,
        ...K ? { autoSelectFamily: K, autoSelectFamilyAttemptTimeout: ge } : void 0,
        ...G
      })), X?.Client && Array.isArray(X.Client) ? (this[Z] = X.Client, me || (me = !0, process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", {
        code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"
      }))) : this[Z] = [ve({ maxRedirections: v })], this[d] = n.parseOrigin(T), this[te] = G, this[b] = Pe ?? 1, this[S] = he || r.maxHeaderSize, this[x] = O ?? 4e3, this[M] = j ?? 6e5, this[k] = ie ?? 2e3, this[N] = this[x], this[u] = null, this[_] = Y ?? null, this[p] = 0, this[I] = 0, this[g] = `host: ${this[d].hostname}${this[d].port ? `:${this[d].port}` : ""}\r
`, this[P] = Bt ?? 3e5, this[F] = Ee ?? 3e5, this[J] = U ?? !0, this[ee] = v, this[de] = q, this[xe] = null, this[ne] = oe > -1 ? oe : -1, this[z] = ze ?? 100, this[W] = null, this[D] = [], this[Q] = 0, this[B] = 0, this[$] = (Ze) => At(this, Ze), this[H] = (Ze) => He(this, Ze);
    }
    get pipelining() {
      return this[b];
    }
    set pipelining(T) {
      this[b] = T, this[$](!0);
    }
    get [w]() {
      return this[D].length - this[B];
    }
    get [y]() {
      return this[B] - this[Q];
    }
    get [R]() {
      return this[D].length - this[Q];
    }
    get [L]() {
      return !!this[W] && !this[C] && !this[W].destroyed;
    }
    get [h]() {
      return !!(this[W]?.busy(null) || this[R] >= (ke(this) || 1) || this[w] > 0);
    }
    /* istanbul ignore: only used for test */
    [f](T) {
      Re(this), this.once("connect", T);
    }
    [Ce](T, X) {
      const he = T.origin || this[d].origin, Ee = new i(he, T, X);
      return this[D].push(Ee), this[p] || (n.bodyLength(Ee.body) == null && n.isIterable(Ee.body) ? (this[p] = 1, queueMicrotask(() => At(this))) : this[$](!0)), this[p] && this[I] !== 2 && this[h] && (this[I] = 2), this[I] < 2;
    }
    async [ce]() {
      return new Promise((T) => {
        this[R] ? this[xe] = T : T(null);
      });
    }
    async [fe](T) {
      return new Promise((X) => {
        const he = this[D].splice(this[B]);
        for (let be = 0; be < he.length; be++) {
          const Le = he[be];
          n.errorRequest(this, Le, T);
        }
        const Ee = () => {
          this[xe] && (this[xe](), this[xe] = null), X(null);
        };
        this[W] ? (this[W].destroy(T, Ee), this[W] = null) : queueMicrotask(Ee), this[$]();
      });
    }
  }
  const ve = yl();
  function He(re, T) {
    if (re[y] === 0 && T.code !== "UND_ERR_INFO" && T.code !== "UND_ERR_SOCKET") {
      t(re[B] === re[Q]);
      const X = re[D].splice(re[Q]);
      for (let he = 0; he < X.length; he++) {
        const Ee = X[he];
        n.errorRequest(re, Ee, T);
      }
      t(re[R] === 0);
    }
  }
  async function Re(re) {
    t(!re[C]), t(!re[W]);
    let { host: T, hostname: X, protocol: he, port: Ee } = re[d];
    if (X[0] === "[") {
      const be = X.indexOf("]");
      t(be !== -1);
      const Le = X.substring(1, be);
      t(e.isIP(Le)), X = Le;
    }
    re[C] = !0, s.beforeConnect.hasSubscribers && s.beforeConnect.publish({
      connectParams: {
        host: T,
        hostname: X,
        protocol: he,
        port: Ee,
        version: re[W]?.version,
        servername: re[u],
        localAddress: re[_]
      },
      connector: re[te]
    });
    try {
      const be = await new Promise((Le, st) => {
        re[te]({
          host: T,
          hostname: X,
          protocol: he,
          port: Ee,
          servername: re[u],
          localAddress: re[_]
        }, (Bt, wt) => {
          Bt ? st(Bt) : Le(wt);
        });
      });
      if (re.destroyed) {
        n.destroy(be.on("error", _e), new c());
        return;
      }
      t(be);
      try {
        re[W] = be.alpnProtocol === "h2" ? await pe(re, be) : await Ae(re, be);
      } catch (Le) {
        throw be.destroy().on("error", _e), Le;
      }
      re[C] = !1, be[ue] = 0, be[de] = re[de], be[m] = re, be[E] = null, s.connected.hasSubscribers && s.connected.publish({
        connectParams: {
          host: T,
          hostname: X,
          protocol: he,
          port: Ee,
          version: re[W]?.version,
          servername: re[u],
          localAddress: re[_]
        },
        connector: re[te],
        socket: be
      }), re.emit("connect", re[d], [re]);
    } catch (be) {
      if (re.destroyed)
        return;
      if (re[C] = !1, s.connectError.hasSubscribers && s.connectError.publish({
        connectParams: {
          host: T,
          hostname: X,
          protocol: he,
          port: Ee,
          version: re[W]?.version,
          servername: re[u],
          localAddress: re[_]
        },
        connector: re[te],
        error: be
      }), be.code === "ERR_TLS_CERT_ALTNAME_INVALID")
        for (t(re[y] === 0); re[w] > 0 && re[D][re[B]].servername === re[u]; ) {
          const Le = re[D][re[B]++];
          n.errorRequest(re, Le, be);
        }
      else
        He(re, be);
      re.emit("connectionError", re[d], [re], be);
    }
    re[$]();
  }
  function ut(re) {
    re[I] = 0, re.emit("drain", re[d], [re]);
  }
  function At(re, T) {
    re[p] !== 2 && (re[p] = 2, rt(re, T), re[p] = 0, re[Q] > 256 && (re[D].splice(0, re[Q]), re[B] -= re[Q], re[Q] = 0));
  }
  function rt(re, T) {
    for (; ; ) {
      if (re.destroyed) {
        t(re[w] === 0);
        return;
      }
      if (re[xe] && !re[R]) {
        re[xe](), re[xe] = null;
        return;
      }
      if (re[W] && re[W].resume(), re[h])
        re[I] = 2;
      else if (re[I] === 2) {
        T ? (re[I] = 1, queueMicrotask(() => ut(re))) : ut(re);
        continue;
      }
      if (re[w] === 0 || re[y] >= (ke(re) || 1))
        return;
      const X = re[D][re[B]];
      if (re[d].protocol === "https:" && re[u] !== X.servername) {
        if (re[y] > 0)
          return;
        re[u] = X.servername, re[W]?.destroy(new A("servername changed"), () => {
          re[W] = null, At(re);
        });
      }
      if (re[C])
        return;
      if (!re[W]) {
        Re(re);
        return;
      }
      if (re[W].destroyed || re[W].busy(X))
        return;
      !X.aborted && re[W].write(X) ? re[B]++ : re[D].splice(re[B], 1);
    }
  }
  return Ca = We, Ca;
}
var Ba, au;
function of() {
  if (au) return Ba;
  au = 1;
  const t = 2048, e = t - 1;
  class r {
    constructor() {
      this.bottom = 0, this.top = 0, this.list = new Array(t), this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & e) === this.bottom;
    }
    push(s) {
      this.list[this.top] = s, this.top = this.top + 1 & e;
    }
    shift() {
      const s = this.list[this.bottom];
      return s === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & e, s);
    }
  }
  return Ba = class {
    constructor() {
      this.head = this.tail = new r();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(s) {
      this.head.isFull() && (this.head = this.head.next = new r()), this.head.push(s);
    }
    shift() {
      const s = this.tail, i = s.shift();
      return s.isEmpty() && s.next !== null && (this.tail = s.next), i;
    }
  }, Ba;
}
var Ia, Au;
function Py() {
  if (Au) return Ia;
  Au = 1;
  const { kFree: t, kConnected: e, kPending: r, kQueued: n, kRunning: s, kSize: i } = gt(), o = /* @__PURE__ */ Symbol("pool");
  class a {
    constructor(c) {
      this[o] = c;
    }
    get connected() {
      return this[o][e];
    }
    get free() {
      return this[o][t];
    }
    get pending() {
      return this[o][r];
    }
    get queued() {
      return this[o][n];
    }
    get running() {
      return this[o][s];
    }
    get size() {
      return this[o][i];
    }
  }
  return Ia = a, Ia;
}
var ya, cu;
function af() {
  if (cu) return ya;
  cu = 1;
  const t = $s(), e = of(), { kConnected: r, kSize: n, kRunning: s, kPending: i, kQueued: o, kBusy: a, kFree: A, kUrl: c, kClose: l, kDestroy: d, kDispatch: u } = gt(), m = Py(), h = /* @__PURE__ */ Symbol("clients"), f = /* @__PURE__ */ Symbol("needDrain"), p = /* @__PURE__ */ Symbol("queue"), y = /* @__PURE__ */ Symbol("closed resolve"), w = /* @__PURE__ */ Symbol("onDrain"), R = /* @__PURE__ */ Symbol("onConnect"), D = /* @__PURE__ */ Symbol("onDisconnect"), L = /* @__PURE__ */ Symbol("onConnectionError"), C = /* @__PURE__ */ Symbol("get dispatcher"), I = /* @__PURE__ */ Symbol("add client"), x = /* @__PURE__ */ Symbol("remove client"), g = /* @__PURE__ */ Symbol("stats");
  class B extends t {
    constructor() {
      super(), this[p] = new e(), this[h] = [], this[o] = 0;
      const E = this;
      this[w] = function(N, S) {
        const M = E[p];
        let k = !1;
        for (; !k; ) {
          const F = M.shift();
          if (!F)
            break;
          E[o]--, k = !this.dispatch(F.opts, F.handler);
        }
        this[f] = k, !this[f] && E[f] && (E[f] = !1, E.emit("drain", N, [E, ...S])), E[y] && M.isEmpty() && Promise.all(E[h].map((F) => F.close())).then(E[y]);
      }, this[R] = (b, N) => {
        E.emit("connect", b, [E, ...N]);
      }, this[D] = (b, N, S) => {
        E.emit("disconnect", b, [E, ...N], S);
      }, this[L] = (b, N, S) => {
        E.emit("connectionError", b, [E, ...N], S);
      }, this[g] = new m(this);
    }
    get [a]() {
      return this[f];
    }
    get [r]() {
      return this[h].filter((E) => E[r]).length;
    }
    get [A]() {
      return this[h].filter((E) => E[r] && !E[f]).length;
    }
    get [i]() {
      let E = this[o];
      for (const { [i]: b } of this[h])
        E += b;
      return E;
    }
    get [s]() {
      let E = 0;
      for (const { [s]: b } of this[h])
        E += b;
      return E;
    }
    get [n]() {
      let E = this[o];
      for (const { [n]: b } of this[h])
        E += b;
      return E;
    }
    get stats() {
      return this[g];
    }
    async [l]() {
      this[p].isEmpty() ? await Promise.all(this[h].map((E) => E.close())) : await new Promise((E) => {
        this[y] = E;
      });
    }
    async [d](E) {
      for (; ; ) {
        const b = this[p].shift();
        if (!b)
          break;
        b.handler.onError(E);
      }
      await Promise.all(this[h].map((b) => b.destroy(E)));
    }
    [u](E, b) {
      const N = this[C]();
      return N ? N.dispatch(E, b) || (N[f] = !0, this[f] = !this[C]()) : (this[f] = !0, this[p].push({ opts: E, handler: b }), this[o]++), !this[f];
    }
    [I](E) {
      return E.on("drain", this[w]).on("connect", this[R]).on("disconnect", this[D]).on("connectionError", this[L]), this[h].push(E), this[f] && queueMicrotask(() => {
        this[f] && this[w](E[c], [this, E]);
      }), this;
    }
    [x](E) {
      E.close(() => {
        const b = this[h].indexOf(E);
        b !== -1 && this[h].splice(b, 1);
      }), this[f] = this[h].some((b) => !b[f] && b.closed !== !0 && b.destroyed !== !0);
    }
  }
  return ya = {
    PoolBase: B,
    kClients: h,
    kNeedDrain: f,
    kAddClient: I,
    kRemoveClient: x,
    kGetDispatcher: C
  }, ya;
}
var Qa, lu;
function Ks() {
  if (lu) return Qa;
  lu = 1;
  const {
    PoolBase: t,
    kClients: e,
    kNeedDrain: r,
    kAddClient: n,
    kGetDispatcher: s
  } = af(), i = Zs(), {
    InvalidArgumentError: o
  } = it(), a = Xe(), { kUrl: A, kInterceptors: c } = gt(), l = Ki(), d = /* @__PURE__ */ Symbol("options"), u = /* @__PURE__ */ Symbol("connections"), m = /* @__PURE__ */ Symbol("factory");
  function h(p, y) {
    return new i(p, y);
  }
  class f extends t {
    constructor(y, {
      connections: w,
      factory: R = h,
      connect: D,
      connectTimeout: L,
      tls: C,
      maxCachedSessions: I,
      socketPath: x,
      autoSelectFamily: g,
      autoSelectFamilyAttemptTimeout: B,
      allowH2: Q,
      ...E
    } = {}) {
      if (super(), w != null && (!Number.isFinite(w) || w < 0))
        throw new o("invalid connections");
      if (typeof R != "function")
        throw new o("factory must be a function.");
      if (D != null && typeof D != "function" && typeof D != "object")
        throw new o("connect must be a function or an object");
      typeof D != "function" && (D = l({
        ...C,
        maxCachedSessions: I,
        allowH2: Q,
        socketPath: x,
        timeout: L,
        ...g ? { autoSelectFamily: g, autoSelectFamilyAttemptTimeout: B } : void 0,
        ...D
      })), this[c] = E.interceptors?.Pool && Array.isArray(E.interceptors.Pool) ? E.interceptors.Pool : [], this[u] = w || null, this[A] = a.parseOrigin(y), this[d] = { ...a.deepClone(E), connect: D, allowH2: Q }, this[d].interceptors = E.interceptors ? { ...E.interceptors } : void 0, this[m] = R, this.on("connectionError", (b, N, S) => {
        for (const M of N) {
          const k = this[e].indexOf(M);
          k !== -1 && this[e].splice(k, 1);
        }
      });
    }
    [s]() {
      for (const y of this[e])
        if (!y[r])
          return y;
      if (!this[u] || this[e].length < this[u]) {
        const y = this[m](this[A], this[d]);
        return this[n](y), y;
      }
    }
  }
  return Qa = f, Qa;
}
var Na, du;
function Hy() {
  if (du) return Na;
  du = 1;
  const {
    BalancedPoolMissingUpstreamError: t,
    InvalidArgumentError: e
  } = it(), {
    PoolBase: r,
    kClients: n,
    kNeedDrain: s,
    kAddClient: i,
    kRemoveClient: o,
    kGetDispatcher: a
  } = af(), A = Ks(), { kUrl: c, kInterceptors: l } = gt(), { parseOrigin: d } = Xe(), u = /* @__PURE__ */ Symbol("factory"), m = /* @__PURE__ */ Symbol("options"), h = /* @__PURE__ */ Symbol("kGreatestCommonDivisor"), f = /* @__PURE__ */ Symbol("kCurrentWeight"), p = /* @__PURE__ */ Symbol("kIndex"), y = /* @__PURE__ */ Symbol("kWeight"), w = /* @__PURE__ */ Symbol("kMaxWeightPerServer"), R = /* @__PURE__ */ Symbol("kErrorPenalty");
  function D(I, x) {
    if (I === 0) return x;
    for (; x !== 0; ) {
      const g = x;
      x = I % x, I = g;
    }
    return I;
  }
  function L(I, x) {
    return new A(I, x);
  }
  class C extends r {
    constructor(x = [], { factory: g = L, ...B } = {}) {
      if (super(), this[m] = B, this[p] = -1, this[f] = 0, this[w] = this[m].maxWeightPerServer || 100, this[R] = this[m].errorPenalty || 15, Array.isArray(x) || (x = [x]), typeof g != "function")
        throw new e("factory must be a function.");
      this[l] = B.interceptors?.BalancedPool && Array.isArray(B.interceptors.BalancedPool) ? B.interceptors.BalancedPool : [], this[u] = g;
      for (const Q of x)
        this.addUpstream(Q);
      this._updateBalancedPoolStats();
    }
    addUpstream(x) {
      const g = d(x).origin;
      if (this[n].find((Q) => Q[c].origin === g && Q.closed !== !0 && Q.destroyed !== !0))
        return this;
      const B = this[u](g, Object.assign({}, this[m]));
      this[i](B), B.on("connect", () => {
        B[y] = Math.min(this[w], B[y] + this[R]);
      }), B.on("connectionError", () => {
        B[y] = Math.max(1, B[y] - this[R]), this._updateBalancedPoolStats();
      }), B.on("disconnect", (...Q) => {
        const E = Q[2];
        E && E.code === "UND_ERR_SOCKET" && (B[y] = Math.max(1, B[y] - this[R]), this._updateBalancedPoolStats());
      });
      for (const Q of this[n])
        Q[y] = this[w];
      return this._updateBalancedPoolStats(), this;
    }
    _updateBalancedPoolStats() {
      let x = 0;
      for (let g = 0; g < this[n].length; g++)
        x = D(this[n][g][y], x);
      this[h] = x;
    }
    removeUpstream(x) {
      const g = d(x).origin, B = this[n].find((Q) => Q[c].origin === g && Q.closed !== !0 && Q.destroyed !== !0);
      return B && this[o](B), this;
    }
    get upstreams() {
      return this[n].filter((x) => x.closed !== !0 && x.destroyed !== !0).map((x) => x[c].origin);
    }
    [a]() {
      if (this[n].length === 0)
        throw new t();
      if (!this[n].find((E) => !E[s] && E.closed !== !0 && E.destroyed !== !0) || this[n].map((E) => E[s]).reduce((E, b) => E && b, !0))
        return;
      let B = 0, Q = this[n].findIndex((E) => !E[s]);
      for (; B++ < this[n].length; ) {
        this[p] = (this[p] + 1) % this[n].length;
        const E = this[n][this[p]];
        if (E[y] > this[n][Q][y] && !E[s] && (Q = this[p]), this[p] === 0 && (this[f] = this[f] - this[h], this[f] <= 0 && (this[f] = this[w])), E[y] >= this[f] && !E[s])
          return E;
      }
      return this[f] = this[n][Q][y], this[p] = Q, this[n][Q];
    }
  }
  return Na = C, Na;
}
var wa, uu;
function js() {
  if (uu) return wa;
  uu = 1;
  const { InvalidArgumentError: t } = it(), { kClients: e, kRunning: r, kClose: n, kDestroy: s, kDispatch: i, kInterceptors: o } = gt(), a = $s(), A = Ks(), c = Zs(), l = Xe(), d = yl(), u = /* @__PURE__ */ Symbol("onConnect"), m = /* @__PURE__ */ Symbol("onDisconnect"), h = /* @__PURE__ */ Symbol("onConnectionError"), f = /* @__PURE__ */ Symbol("maxRedirections"), p = /* @__PURE__ */ Symbol("onDrain"), y = /* @__PURE__ */ Symbol("factory"), w = /* @__PURE__ */ Symbol("options");
  function R(L, C) {
    return C && C.connections === 1 ? new c(L, C) : new A(L, C);
  }
  class D extends a {
    constructor({ factory: C = R, maxRedirections: I = 0, connect: x, ...g } = {}) {
      if (super(), typeof C != "function")
        throw new t("factory must be a function.");
      if (x != null && typeof x != "function" && typeof x != "object")
        throw new t("connect must be a function or an object");
      if (!Number.isInteger(I) || I < 0)
        throw new t("maxRedirections must be a positive number");
      x && typeof x != "function" && (x = { ...x }), this[o] = g.interceptors?.Agent && Array.isArray(g.interceptors.Agent) ? g.interceptors.Agent : [d({ maxRedirections: I })], this[w] = { ...l.deepClone(g), connect: x }, this[w].interceptors = g.interceptors ? { ...g.interceptors } : void 0, this[f] = I, this[y] = C, this[e] = /* @__PURE__ */ new Map(), this[p] = (B, Q) => {
        this.emit("drain", B, [this, ...Q]);
      }, this[u] = (B, Q) => {
        this.emit("connect", B, [this, ...Q]);
      }, this[m] = (B, Q, E) => {
        this.emit("disconnect", B, [this, ...Q], E);
      }, this[h] = (B, Q, E) => {
        this.emit("connectionError", B, [this, ...Q], E);
      };
    }
    get [r]() {
      let C = 0;
      for (const I of this[e].values())
        C += I[r];
      return C;
    }
    [i](C, I) {
      let x;
      if (C.origin && (typeof C.origin == "string" || C.origin instanceof URL))
        x = String(C.origin);
      else
        throw new t("opts.origin must be a non-empty string or URL.");
      let g = this[e].get(x);
      return g || (g = this[y](C.origin, this[w]).on("drain", this[p]).on("connect", this[u]).on("disconnect", this[m]).on("connectionError", this[h]), this[e].set(x, g)), g.dispatch(C, I);
    }
    async [n]() {
      const C = [];
      for (const I of this[e].values())
        C.push(I.close());
      this[e].clear(), await Promise.all(C);
    }
    async [s](C) {
      const I = [];
      for (const x of this[e].values())
        I.push(x.destroy(C));
      this[e].clear(), await Promise.all(I);
    }
  }
  return wa = D, wa;
}
var ba, mu;
function Af() {
  if (mu) return ba;
  mu = 1;
  const { kProxy: t, kClose: e, kDestroy: r, kDispatch: n, kInterceptors: s } = gt(), { URL: i } = uy, o = js(), a = Ks(), A = $s(), { InvalidArgumentError: c, RequestAbortedError: l, SecureProxyConnectionError: d } = it(), u = Ki(), m = Zs(), h = /* @__PURE__ */ Symbol("proxy agent"), f = /* @__PURE__ */ Symbol("proxy client"), p = /* @__PURE__ */ Symbol("proxy headers"), y = /* @__PURE__ */ Symbol("request tls settings"), w = /* @__PURE__ */ Symbol("proxy tls settings"), R = /* @__PURE__ */ Symbol("connect endpoint function"), D = /* @__PURE__ */ Symbol("tunnel proxy");
  function L(b) {
    return b === "https:" ? 443 : 80;
  }
  function C(b, N) {
    return new a(b, N);
  }
  const I = () => {
  };
  function x(b, N) {
    return N.connections === 1 ? new m(b, N) : new a(b, N);
  }
  class g extends A {
    #e;
    constructor(N, { headers: S = {}, connect: M, factory: k }) {
      if (super(), !N)
        throw new c("Proxy URL is mandatory");
      this[p] = S, k ? this.#e = k(N, { connect: M }) : this.#e = new m(N, { connect: M });
    }
    [n](N, S) {
      const M = S.onHeaders;
      S.onHeaders = function(J, te, ee) {
        if (J === 407) {
          typeof S.onError == "function" && S.onError(new c("Proxy Authentication Required (407)"));
          return;
        }
        M && M.call(this, J, te, ee);
      };
      const {
        origin: k,
        path: F = "/",
        headers: P = {}
      } = N;
      if (N.path = k + F, !("host" in P) && !("Host" in P)) {
        const { host: J } = new i(k);
        P.host = J;
      }
      return N.headers = { ...this[p], ...P }, this.#e[n](N, S);
    }
    async [e]() {
      return this.#e.close();
    }
    async [r](N) {
      return this.#e.destroy(N);
    }
  }
  class B extends A {
    constructor(N) {
      if (super(), !N || typeof N == "object" && !(N instanceof i) && !N.uri)
        throw new c("Proxy uri is mandatory");
      const { clientFactory: S = C } = N;
      if (typeof S != "function")
        throw new c("Proxy opts.clientFactory must be a function.");
      const { proxyTunnel: M = !0 } = N, k = this.#e(N), { href: F, origin: P, port: J, protocol: te, username: ee, password: de, hostname: ue } = k;
      if (this[t] = { uri: F, protocol: te }, this[s] = N.interceptors?.ProxyAgent && Array.isArray(N.interceptors.ProxyAgent) ? N.interceptors.ProxyAgent : [], this[y] = N.requestTls, this[w] = N.proxyTls, this[p] = N.headers || {}, this[D] = M, N.auth && N.token)
        throw new c("opts.auth cannot be used in combination with opts.token");
      N.auth ? this[p]["proxy-authorization"] = `Basic ${N.auth}` : N.token ? this[p]["proxy-authorization"] = N.token : ee && de && (this[p]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(ee)}:${decodeURIComponent(de)}`).toString("base64")}`);
      const ce = u({ ...N.proxyTls });
      this[R] = u({ ...N.requestTls });
      const fe = N.factory || x, Ce = (Z, _) => {
        const { protocol: ne } = new i(Z);
        return !this[D] && ne === "http:" && this[t].protocol === "http:" ? new g(this[t].uri, {
          headers: this[p],
          connect: ce,
          factory: fe
        }) : fe(Z, _);
      };
      this[f] = S(k, { connect: ce }), this[h] = new o({
        ...N,
        factory: Ce,
        connect: async (Z, _) => {
          let ne = Z.host;
          Z.port || (ne += `:${L(Z.protocol)}`);
          try {
            const { socket: H, statusCode: W } = await this[f].connect({
              origin: P,
              port: J,
              path: ne,
              signal: Z.signal,
              headers: {
                ...this[p],
                host: Z.host
              },
              servername: this[w]?.servername || ue
            });
            if (W !== 200 && (H.on("error", I).destroy(), _(new l(`Proxy response (${W}) !== 200 when HTTP Tunneling`))), Z.protocol !== "https:") {
              _(null, H);
              return;
            }
            let z;
            this[y] ? z = this[y].servername : z = Z.servername, this[R]({ ...Z, servername: z, httpSocket: H }, _);
          } catch (H) {
            H.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? _(new d(H)) : _(H);
          }
        }
      });
    }
    dispatch(N, S) {
      const M = Q(N.headers);
      if (E(M), M && !("host" in M) && !("Host" in M)) {
        const { host: k } = new i(N.origin);
        M.host = k;
      }
      return this[h].dispatch(
        {
          ...N,
          headers: M
        },
        S
      );
    }
    /**
     * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
     * @returns {URL}
     */
    #e(N) {
      return typeof N == "string" ? new i(N) : N instanceof i ? N : new i(N.uri);
    }
    async [e]() {
      await this[h].close(), await this[f].close();
    }
    async [r]() {
      await this[h].destroy(), await this[f].destroy();
    }
  }
  function Q(b) {
    if (Array.isArray(b)) {
      const N = {};
      for (let S = 0; S < b.length; S += 2)
        N[b[S]] = b[S + 1];
      return N;
    }
    return b;
  }
  function E(b) {
    if (b && Object.keys(b).find((S) => S.toLowerCase() === "proxy-authorization"))
      throw new c("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
  return ba = B, ba;
}
var xa, hu;
function Oy() {
  if (hu) return xa;
  hu = 1;
  const t = $s(), { kClose: e, kDestroy: r, kClosed: n, kDestroyed: s, kDispatch: i, kNoProxyAgent: o, kHttpProxyAgent: a, kHttpsProxyAgent: A } = gt(), c = Af(), l = js(), d = {
    "http:": 80,
    "https:": 443
  };
  let u = !1;
  class m extends t {
    #e = null;
    #t = null;
    #s = null;
    constructor(f = {}) {
      super(), this.#s = f, u || (u = !0, process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
        code: "UNDICI-EHPA"
      }));
      const { httpProxy: p, httpsProxy: y, noProxy: w, ...R } = f;
      this[o] = new l(R);
      const D = p ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
      D ? this[a] = new c({ ...R, uri: D }) : this[a] = this[o];
      const L = y ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
      L ? this[A] = new c({ ...R, uri: L }) : this[A] = this[a], this.#i();
    }
    [i](f, p) {
      const y = new URL(f.origin);
      return this.#n(y).dispatch(f, p);
    }
    async [e]() {
      await this[o].close(), this[a][n] || await this[a].close(), this[A][n] || await this[A].close();
    }
    async [r](f) {
      await this[o].destroy(f), this[a][s] || await this[a].destroy(f), this[A][s] || await this[A].destroy(f);
    }
    #n(f) {
      let { protocol: p, host: y, port: w } = f;
      return y = y.replace(/:\d*$/, "").toLowerCase(), w = Number.parseInt(w, 10) || d[p] || 0, this.#r(y, w) ? p === "https:" ? this[A] : this[a] : this[o];
    }
    #r(f, p) {
      if (this.#o && this.#i(), this.#t.length === 0)
        return !0;
      if (this.#e === "*")
        return !1;
      for (let y = 0; y < this.#t.length; y++) {
        const w = this.#t[y];
        if (!(w.port && w.port !== p)) {
          if (/^[.*]/.test(w.hostname)) {
            if (f.endsWith(w.hostname.replace(/^\*/, "")))
              return !1;
          } else if (f === w.hostname)
            return !1;
        }
      }
      return !0;
    }
    #i() {
      const f = this.#s.noProxy ?? this.#a, p = f.split(/[,\s]/), y = [];
      for (let w = 0; w < p.length; w++) {
        const R = p[w];
        if (!R)
          continue;
        const D = R.match(/^(.+):(\d+)$/);
        y.push({
          hostname: (D ? D[1] : R).toLowerCase(),
          port: D ? Number.parseInt(D[2], 10) : 0
        });
      }
      this.#e = f, this.#t = y;
    }
    get #o() {
      return this.#s.noProxy !== void 0 ? !1 : this.#e !== this.#a;
    }
    get #a() {
      return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
    }
  }
  return xa = m, xa;
}
var Ra, gu;
function Ql() {
  if (gu) return Ra;
  gu = 1;
  const t = lt, { kRetryHandlerDefaultRetry: e } = gt(), { RequestRetryError: r } = it(), {
    isDisturbed: n,
    parseHeaders: s,
    parseRangeHeader: i,
    wrapRequestBody: o
  } = Xe();
  function a(c) {
    const l = Date.now();
    return new Date(c).getTime() - l;
  }
  class A {
    constructor(l, d) {
      const { retryOptions: u, ...m } = l, {
        // Retry scoped
        retry: h,
        maxRetries: f,
        maxTimeout: p,
        minTimeout: y,
        timeoutFactor: w,
        // Response scoped
        methods: R,
        errorCodes: D,
        retryAfter: L,
        statusCodes: C
      } = u ?? {};
      this.dispatch = d.dispatch, this.handler = d.handler, this.opts = { ...m, body: o(l.body) }, this.abort = null, this.aborted = !1, this.retryOpts = {
        retry: h ?? A[e],
        retryAfter: L ?? !0,
        maxTimeout: p ?? 30 * 1e3,
        // 30s,
        minTimeout: y ?? 500,
        // .5s
        timeoutFactor: w ?? 2,
        maxRetries: f ?? 5,
        // What errors we should retry
        methods: R ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        // Indicates which errors to retry
        statusCodes: C ?? [500, 502, 503, 504, 429],
        // List of errors to retry
        errorCodes: D ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE",
          "UND_ERR_SOCKET"
        ]
      }, this.retryCount = 0, this.retryCountCheckpoint = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((I) => {
        this.aborted = !0, this.abort ? this.abort(I) : this.reason = I;
      });
    }
    onRequestSent() {
      this.handler.onRequestSent && this.handler.onRequestSent();
    }
    onUpgrade(l, d, u) {
      this.handler.onUpgrade && this.handler.onUpgrade(l, d, u);
    }
    onConnect(l) {
      this.aborted ? l(this.reason) : this.abort = l;
    }
    onBodySent(l) {
      if (this.handler.onBodySent) return this.handler.onBodySent(l);
    }
    static [e](l, { state: d, opts: u }, m) {
      const { statusCode: h, code: f, headers: p } = l, { method: y, retryOptions: w } = u, {
        maxRetries: R,
        minTimeout: D,
        maxTimeout: L,
        timeoutFactor: C,
        statusCodes: I,
        errorCodes: x,
        methods: g
      } = w, { counter: B } = d;
      if (f && f !== "UND_ERR_REQ_RETRY" && !x.includes(f)) {
        m(l);
        return;
      }
      if (Array.isArray(g) && !g.includes(y)) {
        m(l);
        return;
      }
      if (h != null && Array.isArray(I) && !I.includes(h)) {
        m(l);
        return;
      }
      if (B > R) {
        m(l);
        return;
      }
      let Q = p?.["retry-after"];
      Q && (Q = Number(Q), Q = Number.isNaN(Q) ? a(Q) : Q * 1e3);
      const E = Q > 0 ? Math.min(Q, L) : Math.min(D * C ** (B - 1), L);
      setTimeout(() => m(null), E);
    }
    onHeaders(l, d, u, m) {
      const h = s(d);
      if (this.retryCount += 1, l >= 300)
        return this.retryOpts.statusCodes.includes(l) === !1 ? this.handler.onHeaders(
          l,
          d,
          u,
          m
        ) : (this.abort(
          new r("Request failed", l, {
            headers: h,
            data: {
              count: this.retryCount
            }
          })
        ), !1);
      if (this.resume != null) {
        if (this.resume = null, l !== 206 && (this.start > 0 || l !== 200))
          return this.abort(
            new r("server does not support the range header and the payload was partially consumed", l, {
              headers: h,
              data: { count: this.retryCount }
            })
          ), !1;
        const p = i(h["content-range"]);
        if (!p)
          return this.abort(
            new r("Content-Range mismatch", l, {
              headers: h,
              data: { count: this.retryCount }
            })
          ), !1;
        if (this.etag != null && this.etag !== h.etag)
          return this.abort(
            new r("ETag mismatch", l, {
              headers: h,
              data: { count: this.retryCount }
            })
          ), !1;
        const { start: y, size: w, end: R = w - 1 } = p;
        return t(this.start === y, "content-range mismatch"), t(this.end == null || this.end === R, "content-range mismatch"), this.resume = u, !0;
      }
      if (this.end == null) {
        if (l === 206) {
          const p = i(h["content-range"]);
          if (p == null)
            return this.handler.onHeaders(
              l,
              d,
              u,
              m
            );
          const { start: y, size: w, end: R = w - 1 } = p;
          t(
            y != null && Number.isFinite(y),
            "content-range mismatch"
          ), t(R != null && Number.isFinite(R), "invalid content-length"), this.start = y, this.end = R;
        }
        if (this.end == null) {
          const p = h["content-length"];
          this.end = p != null ? Number(p) - 1 : null;
        }
        return t(Number.isFinite(this.start)), t(
          this.end == null || Number.isFinite(this.end),
          "invalid content-length"
        ), this.resume = u, this.etag = h.etag != null ? h.etag : null, this.etag != null && this.etag.startsWith("W/") && (this.etag = null), this.handler.onHeaders(
          l,
          d,
          u,
          m
        );
      }
      const f = new r("Request failed", l, {
        headers: h,
        data: { count: this.retryCount }
      });
      return this.abort(f), !1;
    }
    onData(l) {
      return this.start += l.length, this.handler.onData(l);
    }
    onComplete(l) {
      return this.retryCount = 0, this.handler.onComplete(l);
    }
    onError(l) {
      if (this.aborted || n(this.opts.body))
        return this.handler.onError(l);
      this.retryCount - this.retryCountCheckpoint > 0 ? this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint) : this.retryCount += 1, this.retryOpts.retry(
        l,
        {
          state: { counter: this.retryCount },
          opts: { retryOptions: this.retryOpts, ...this.opts }
        },
        d.bind(this)
      );
      function d(u) {
        if (u != null || this.aborted || n(this.opts.body))
          return this.handler.onError(u);
        if (this.start !== 0) {
          const m = { range: `bytes=${this.start}-${this.end ?? ""}` };
          this.etag != null && (m["if-match"] = this.etag), this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              ...m
            }
          };
        }
        try {
          this.retryCountCheckpoint = this.retryCount, this.dispatch(this.opts, this);
        } catch (m) {
          this.handler.onError(m);
        }
      }
    }
  }
  return Ra = A, Ra;
}
var Sa, fu;
function zy() {
  if (fu) return Sa;
  fu = 1;
  const t = Zi(), e = Ql();
  class r extends t {
    #e = null;
    #t = null;
    constructor(s, i = {}) {
      super(i), this.#e = s, this.#t = i;
    }
    dispatch(s, i) {
      const o = new e({
        ...s,
        retryOptions: this.#t
      }, {
        dispatch: this.#e.dispatch.bind(this.#e),
        handler: i
      });
      return this.#e.dispatch(s, o);
    }
    close() {
      return this.#e.close();
    }
    destroy() {
      return this.#e.destroy();
    }
  }
  return Sa = r, Sa;
}
var dn = {}, pi = { exports: {} }, Da, pu;
function cf() {
  if (pu) return Da;
  pu = 1;
  const t = lt, { Readable: e } = dr, { RequestAbortedError: r, NotSupportedError: n, InvalidArgumentError: s, AbortError: i } = it(), o = Xe(), { ReadableStreamFrom: a } = Xe(), A = /* @__PURE__ */ Symbol("kConsume"), c = /* @__PURE__ */ Symbol("kReading"), l = /* @__PURE__ */ Symbol("kBody"), d = /* @__PURE__ */ Symbol("kAbort"), u = /* @__PURE__ */ Symbol("kContentType"), m = /* @__PURE__ */ Symbol("kContentLength"), h = () => {
  };
  class f extends e {
    constructor({
      resume: B,
      abort: Q,
      contentType: E = "",
      contentLength: b,
      highWaterMark: N = 64 * 1024
      // Same as nodejs fs streams.
    }) {
      super({
        autoDestroy: !0,
        read: B,
        highWaterMark: N
      }), this._readableState.dataEmitted = !1, this[d] = Q, this[A] = null, this[l] = null, this[u] = E, this[m] = b, this[c] = !1;
    }
    destroy(B) {
      return !B && !this._readableState.endEmitted && (B = new r()), B && this[d](), super.destroy(B);
    }
    _destroy(B, Q) {
      this[c] ? Q(B) : setImmediate(() => {
        Q(B);
      });
    }
    on(B, ...Q) {
      return (B === "data" || B === "readable") && (this[c] = !0), super.on(B, ...Q);
    }
    addListener(B, ...Q) {
      return this.on(B, ...Q);
    }
    off(B, ...Q) {
      const E = super.off(B, ...Q);
      return (B === "data" || B === "readable") && (this[c] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), E;
    }
    removeListener(B, ...Q) {
      return this.off(B, ...Q);
    }
    push(B) {
      return this[A] && B !== null ? (I(this[A], B), this[c] ? super.push(B) : !0) : super.push(B);
    }
    // https://fetch.spec.whatwg.org/#dom-body-text
    async text() {
      return w(this, "text");
    }
    // https://fetch.spec.whatwg.org/#dom-body-json
    async json() {
      return w(this, "json");
    }
    // https://fetch.spec.whatwg.org/#dom-body-blob
    async blob() {
      return w(this, "blob");
    }
    // https://fetch.spec.whatwg.org/#dom-body-bytes
    async bytes() {
      return w(this, "bytes");
    }
    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
    async arrayBuffer() {
      return w(this, "arrayBuffer");
    }
    // https://fetch.spec.whatwg.org/#dom-body-formdata
    async formData() {
      throw new n();
    }
    // https://fetch.spec.whatwg.org/#dom-body-bodyused
    get bodyUsed() {
      return o.isDisturbed(this);
    }
    // https://fetch.spec.whatwg.org/#dom-body-body
    get body() {
      return this[l] || (this[l] = a(this), this[A] && (this[l].getReader(), t(this[l].locked))), this[l];
    }
    async dump(B) {
      let Q = Number.isFinite(B?.limit) ? B.limit : 131072;
      const E = B?.signal;
      if (E != null && (typeof E != "object" || !("aborted" in E)))
        throw new s("signal must be an AbortSignal");
      return E?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((b, N) => {
        this[m] > Q && this.destroy(new i());
        const S = () => {
          this.destroy(E.reason ?? new i());
        };
        E?.addEventListener("abort", S), this.on("close", function() {
          E?.removeEventListener("abort", S), E?.aborted ? N(E.reason ?? new i()) : b(null);
        }).on("error", h).on("data", function(M) {
          Q -= M.length, Q <= 0 && this.destroy();
        }).resume();
      });
    }
  }
  function p(g) {
    return g[l] && g[l].locked === !0 || g[A];
  }
  function y(g) {
    return o.isDisturbed(g) || p(g);
  }
  async function w(g, B) {
    return t(!g[A]), new Promise((Q, E) => {
      if (y(g)) {
        const b = g._readableState;
        b.destroyed && b.closeEmitted === !1 ? g.on("error", (N) => {
          E(N);
        }).on("close", () => {
          E(new TypeError("unusable"));
        }) : E(b.errored ?? new TypeError("unusable"));
      } else
        queueMicrotask(() => {
          g[A] = {
            type: B,
            stream: g,
            resolve: Q,
            reject: E,
            length: 0,
            body: []
          }, g.on("error", function(b) {
            x(this[A], b);
          }).on("close", function() {
            this[A].body !== null && x(this[A], new r());
          }), R(g[A]);
        });
    });
  }
  function R(g) {
    if (g.body === null)
      return;
    const { _readableState: B } = g.stream;
    if (B.bufferIndex) {
      const Q = B.bufferIndex, E = B.buffer.length;
      for (let b = Q; b < E; b++)
        I(g, B.buffer[b]);
    } else
      for (const Q of B.buffer)
        I(g, Q);
    for (B.endEmitted ? C(this[A]) : g.stream.on("end", function() {
      C(this[A]);
    }), g.stream.resume(); g.stream.read() != null; )
      ;
  }
  function D(g, B) {
    if (g.length === 0 || B === 0)
      return "";
    const Q = g.length === 1 ? g[0] : Buffer.concat(g, B), E = Q.length, b = E > 2 && Q[0] === 239 && Q[1] === 187 && Q[2] === 191 ? 3 : 0;
    return Q.utf8Slice(b, E);
  }
  function L(g, B) {
    if (g.length === 0 || B === 0)
      return new Uint8Array(0);
    if (g.length === 1)
      return new Uint8Array(g[0]);
    const Q = new Uint8Array(Buffer.allocUnsafeSlow(B).buffer);
    let E = 0;
    for (let b = 0; b < g.length; ++b) {
      const N = g[b];
      Q.set(N, E), E += N.length;
    }
    return Q;
  }
  function C(g) {
    const { type: B, body: Q, resolve: E, stream: b, length: N } = g;
    try {
      B === "text" ? E(D(Q, N)) : B === "json" ? E(JSON.parse(D(Q, N))) : B === "arrayBuffer" ? E(L(Q, N).buffer) : B === "blob" ? E(new Blob(Q, { type: b[u] })) : B === "bytes" && E(L(Q, N)), x(g);
    } catch (S) {
      b.destroy(S);
    }
  }
  function I(g, B) {
    g.length += B.length, g.body.push(B);
  }
  function x(g, B) {
    g.body !== null && (B ? g.reject(B) : g.resolve(), g.type = null, g.stream = null, g.resolve = null, g.reject = null, g.length = 0, g.body = null);
  }
  return Da = { Readable: f, chunksDecode: D }, Da;
}
var ka, Eu;
function lf() {
  if (Eu) return ka;
  Eu = 1;
  const t = lt, {
    ResponseStatusCodeError: e
  } = it(), { chunksDecode: r } = cf(), n = 128 * 1024;
  async function s({ callback: a, body: A, contentType: c, statusCode: l, statusMessage: d, headers: u }) {
    t(A);
    let m = [], h = 0;
    try {
      for await (const w of A)
        if (m.push(w), h += w.length, h > n) {
          m = [], h = 0;
          break;
        }
    } catch {
      m = [], h = 0;
    }
    const f = `Response status code ${l}${d ? `: ${d}` : ""}`;
    if (l === 204 || !c || !h) {
      queueMicrotask(() => a(new e(f, l, u)));
      return;
    }
    const p = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    let y;
    try {
      i(c) ? y = JSON.parse(r(m, h)) : o(c) && (y = r(m, h));
    } catch {
    } finally {
      Error.stackTraceLimit = p;
    }
    queueMicrotask(() => a(new e(f, l, u, y)));
  }
  const i = (a) => a.length > 15 && a[11] === "/" && a[0] === "a" && a[1] === "p" && a[2] === "p" && a[3] === "l" && a[4] === "i" && a[5] === "c" && a[6] === "a" && a[7] === "t" && a[8] === "i" && a[9] === "o" && a[10] === "n" && a[12] === "j" && a[13] === "s" && a[14] === "o" && a[15] === "n", o = (a) => a.length > 4 && a[4] === "/" && a[0] === "t" && a[1] === "e" && a[2] === "x" && a[3] === "t";
  return ka = {
    getResolveErrorBodyCallback: s,
    isContentTypeApplicationJson: i,
    isContentTypeText: o
  }, ka;
}
var Cu;
function qy() {
  if (Cu) return pi.exports;
  Cu = 1;
  const t = lt, { Readable: e } = cf(), { InvalidArgumentError: r, RequestAbortedError: n } = it(), s = Xe(), { getResolveErrorBodyCallback: i } = lf(), { AsyncResource: o } = _s;
  class a extends o {
    constructor(l, d) {
      if (!l || typeof l != "object")
        throw new r("invalid opts");
      const { signal: u, method: m, opaque: h, body: f, onInfo: p, responseHeaders: y, throwOnError: w, highWaterMark: R } = l;
      try {
        if (typeof d != "function")
          throw new r("invalid callback");
        if (R && (typeof R != "number" || R < 0))
          throw new r("invalid highWaterMark");
        if (u && typeof u.on != "function" && typeof u.addEventListener != "function")
          throw new r("signal must be an EventEmitter or EventTarget");
        if (m === "CONNECT")
          throw new r("invalid method");
        if (p && typeof p != "function")
          throw new r("invalid onInfo callback");
        super("UNDICI_REQUEST");
      } catch (D) {
        throw s.isStream(f) && s.destroy(f.on("error", s.nop), D), D;
      }
      this.method = m, this.responseHeaders = y || null, this.opaque = h || null, this.callback = d, this.res = null, this.abort = null, this.body = f, this.trailers = {}, this.context = null, this.onInfo = p || null, this.throwOnError = w, this.highWaterMark = R, this.signal = u, this.reason = null, this.removeAbortListener = null, s.isStream(f) && f.on("error", (D) => {
        this.onError(D);
      }), this.signal && (this.signal.aborted ? this.reason = this.signal.reason ?? new n() : this.removeAbortListener = s.addAbortListener(this.signal, () => {
        this.reason = this.signal.reason ?? new n(), this.res ? s.destroy(this.res.on("error", s.nop), this.reason) : this.abort && this.abort(this.reason), this.removeAbortListener && (this.res?.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
      }));
    }
    onConnect(l, d) {
      if (this.reason) {
        l(this.reason);
        return;
      }
      t(this.callback), this.abort = l, this.context = d;
    }
    onHeaders(l, d, u, m) {
      const { callback: h, opaque: f, abort: p, context: y, responseHeaders: w, highWaterMark: R } = this, D = w === "raw" ? s.parseRawHeaders(d) : s.parseHeaders(d);
      if (l < 200) {
        this.onInfo && this.onInfo({ statusCode: l, headers: D });
        return;
      }
      const L = w === "raw" ? s.parseHeaders(d) : D, C = L["content-type"], I = L["content-length"], x = new e({
        resume: u,
        abort: p,
        contentType: C,
        contentLength: this.method !== "HEAD" && I ? Number(I) : null,
        highWaterMark: R
      });
      this.removeAbortListener && x.on("close", this.removeAbortListener), this.callback = null, this.res = x, h !== null && (this.throwOnError && l >= 400 ? this.runInAsyncScope(
        i,
        null,
        { callback: h, body: x, contentType: C, statusCode: l, statusMessage: m, headers: D }
      ) : this.runInAsyncScope(h, null, null, {
        statusCode: l,
        headers: D,
        trailers: this.trailers,
        opaque: f,
        body: x,
        context: y
      }));
    }
    onData(l) {
      return this.res.push(l);
    }
    onComplete(l) {
      s.parseHeaders(l, this.trailers), this.res.push(null);
    }
    onError(l) {
      const { res: d, callback: u, body: m, opaque: h } = this;
      u && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(u, null, l, { opaque: h });
      })), d && (this.res = null, queueMicrotask(() => {
        s.destroy(d, l);
      })), m && (this.body = null, s.destroy(m, l)), this.removeAbortListener && (d?.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
    }
  }
  function A(c, l) {
    if (l === void 0)
      return new Promise((d, u) => {
        A.call(this, c, (m, h) => m ? u(m) : d(h));
      });
    try {
      this.dispatch(c, new a(c, l));
    } catch (d) {
      if (typeof l != "function")
        throw d;
      const u = c?.opaque;
      queueMicrotask(() => l(d, { opaque: u }));
    }
  }
  return pi.exports = A, pi.exports.RequestHandler = a, pi.exports;
}
var Ma, Bu;
function to() {
  if (Bu) return Ma;
  Bu = 1;
  const { addAbortListener: t } = Xe(), { RequestAbortedError: e } = it(), r = /* @__PURE__ */ Symbol("kListener"), n = /* @__PURE__ */ Symbol("kSignal");
  function s(a) {
    a.abort ? a.abort(a[n]?.reason) : a.reason = a[n]?.reason ?? new e(), o(a);
  }
  function i(a, A) {
    if (a.reason = null, a[n] = null, a[r] = null, !!A) {
      if (A.aborted) {
        s(a);
        return;
      }
      a[n] = A, a[r] = () => {
        s(a);
      }, t(a[n], a[r]);
    }
  }
  function o(a) {
    a[n] && ("removeEventListener" in a[n] ? a[n].removeEventListener("abort", a[r]) : a[n].removeListener("abort", a[r]), a[n] = null, a[r] = null);
  }
  return Ma = {
    addSignal: i,
    removeSignal: o
  }, Ma;
}
var Ta, Iu;
function Gy() {
  if (Iu) return Ta;
  Iu = 1;
  const t = lt, { finished: e, PassThrough: r } = dr, { InvalidArgumentError: n, InvalidReturnValueError: s } = it(), i = Xe(), { getResolveErrorBodyCallback: o } = lf(), { AsyncResource: a } = _s, { addSignal: A, removeSignal: c } = to();
  class l extends a {
    constructor(m, h, f) {
      if (!m || typeof m != "object")
        throw new n("invalid opts");
      const { signal: p, method: y, opaque: w, body: R, onInfo: D, responseHeaders: L, throwOnError: C } = m;
      try {
        if (typeof f != "function")
          throw new n("invalid callback");
        if (typeof h != "function")
          throw new n("invalid factory");
        if (p && typeof p.on != "function" && typeof p.addEventListener != "function")
          throw new n("signal must be an EventEmitter or EventTarget");
        if (y === "CONNECT")
          throw new n("invalid method");
        if (D && typeof D != "function")
          throw new n("invalid onInfo callback");
        super("UNDICI_STREAM");
      } catch (I) {
        throw i.isStream(R) && i.destroy(R.on("error", i.nop), I), I;
      }
      this.responseHeaders = L || null, this.opaque = w || null, this.factory = h, this.callback = f, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = R, this.onInfo = D || null, this.throwOnError = C || !1, i.isStream(R) && R.on("error", (I) => {
        this.onError(I);
      }), A(this, p);
    }
    onConnect(m, h) {
      if (this.reason) {
        m(this.reason);
        return;
      }
      t(this.callback), this.abort = m, this.context = h;
    }
    onHeaders(m, h, f, p) {
      const { factory: y, opaque: w, context: R, callback: D, responseHeaders: L } = this, C = L === "raw" ? i.parseRawHeaders(h) : i.parseHeaders(h);
      if (m < 200) {
        this.onInfo && this.onInfo({ statusCode: m, headers: C });
        return;
      }
      this.factory = null;
      let I;
      if (this.throwOnError && m >= 400) {
        const B = (L === "raw" ? i.parseHeaders(h) : C)["content-type"];
        I = new r(), this.callback = null, this.runInAsyncScope(
          o,
          null,
          { callback: D, body: I, contentType: B, statusCode: m, statusMessage: p, headers: C }
        );
      } else {
        if (y === null)
          return;
        if (I = this.runInAsyncScope(y, null, {
          statusCode: m,
          headers: C,
          opaque: w,
          context: R
        }), !I || typeof I.write != "function" || typeof I.end != "function" || typeof I.on != "function")
          throw new s("expected Writable");
        e(I, { readable: !1 }, (g) => {
          const { callback: B, res: Q, opaque: E, trailers: b, abort: N } = this;
          this.res = null, (g || !Q.readable) && i.destroy(Q, g), this.callback = null, this.runInAsyncScope(B, null, g || null, { opaque: E, trailers: b }), g && N();
        });
      }
      return I.on("drain", f), this.res = I, (I.writableNeedDrain !== void 0 ? I.writableNeedDrain : I._writableState?.needDrain) !== !0;
    }
    onData(m) {
      const { res: h } = this;
      return h ? h.write(m) : !0;
    }
    onComplete(m) {
      const { res: h } = this;
      c(this), h && (this.trailers = i.parseHeaders(m), h.end());
    }
    onError(m) {
      const { res: h, callback: f, opaque: p, body: y } = this;
      c(this), this.factory = null, h ? (this.res = null, i.destroy(h, m)) : f && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(f, null, m, { opaque: p });
      })), y && (this.body = null, i.destroy(y, m));
    }
  }
  function d(u, m, h) {
    if (h === void 0)
      return new Promise((f, p) => {
        d.call(this, u, m, (y, w) => y ? p(y) : f(w));
      });
    try {
      this.dispatch(u, new l(u, m, h));
    } catch (f) {
      if (typeof h != "function")
        throw f;
      const p = u?.opaque;
      queueMicrotask(() => h(f, { opaque: p }));
    }
  }
  return Ta = d, Ta;
}
var Fa, yu;
function Yy() {
  if (yu) return Fa;
  yu = 1;
  const {
    Readable: t,
    Duplex: e,
    PassThrough: r
  } = dr, {
    InvalidArgumentError: n,
    InvalidReturnValueError: s,
    RequestAbortedError: i
  } = it(), o = Xe(), { AsyncResource: a } = _s, { addSignal: A, removeSignal: c } = to(), l = lt, d = /* @__PURE__ */ Symbol("resume");
  class u extends t {
    constructor() {
      super({ autoDestroy: !0 }), this[d] = null;
    }
    _read() {
      const { [d]: y } = this;
      y && (this[d] = null, y());
    }
    _destroy(y, w) {
      this._read(), w(y);
    }
  }
  class m extends t {
    constructor(y) {
      super({ autoDestroy: !0 }), this[d] = y;
    }
    _read() {
      this[d]();
    }
    _destroy(y, w) {
      !y && !this._readableState.endEmitted && (y = new i()), w(y);
    }
  }
  class h extends a {
    constructor(y, w) {
      if (!y || typeof y != "object")
        throw new n("invalid opts");
      if (typeof w != "function")
        throw new n("invalid handler");
      const { signal: R, method: D, opaque: L, onInfo: C, responseHeaders: I } = y;
      if (R && typeof R.on != "function" && typeof R.addEventListener != "function")
        throw new n("signal must be an EventEmitter or EventTarget");
      if (D === "CONNECT")
        throw new n("invalid method");
      if (C && typeof C != "function")
        throw new n("invalid onInfo callback");
      super("UNDICI_PIPELINE"), this.opaque = L || null, this.responseHeaders = I || null, this.handler = w, this.abort = null, this.context = null, this.onInfo = C || null, this.req = new u().on("error", o.nop), this.ret = new e({
        readableObjectMode: y.objectMode,
        autoDestroy: !0,
        read: () => {
          const { body: x } = this;
          x?.resume && x.resume();
        },
        write: (x, g, B) => {
          const { req: Q } = this;
          Q.push(x, g) || Q._readableState.destroyed ? B() : Q[d] = B;
        },
        destroy: (x, g) => {
          const { body: B, req: Q, res: E, ret: b, abort: N } = this;
          !x && !b._readableState.endEmitted && (x = new i()), N && x && N(), o.destroy(B, x), o.destroy(Q, x), o.destroy(E, x), c(this), g(x);
        }
      }).on("prefinish", () => {
        const { req: x } = this;
        x.push(null);
      }), this.res = null, A(this, R);
    }
    onConnect(y, w) {
      const { ret: R, res: D } = this;
      if (this.reason) {
        y(this.reason);
        return;
      }
      l(!D, "pipeline cannot be retried"), l(!R.destroyed), this.abort = y, this.context = w;
    }
    onHeaders(y, w, R) {
      const { opaque: D, handler: L, context: C } = this;
      if (y < 200) {
        if (this.onInfo) {
          const x = this.responseHeaders === "raw" ? o.parseRawHeaders(w) : o.parseHeaders(w);
          this.onInfo({ statusCode: y, headers: x });
        }
        return;
      }
      this.res = new m(R);
      let I;
      try {
        this.handler = null;
        const x = this.responseHeaders === "raw" ? o.parseRawHeaders(w) : o.parseHeaders(w);
        I = this.runInAsyncScope(L, null, {
          statusCode: y,
          headers: x,
          opaque: D,
          body: this.res,
          context: C
        });
      } catch (x) {
        throw this.res.on("error", o.nop), x;
      }
      if (!I || typeof I.on != "function")
        throw new s("expected Readable");
      I.on("data", (x) => {
        const { ret: g, body: B } = this;
        !g.push(x) && B.pause && B.pause();
      }).on("error", (x) => {
        const { ret: g } = this;
        o.destroy(g, x);
      }).on("end", () => {
        const { ret: x } = this;
        x.push(null);
      }).on("close", () => {
        const { ret: x } = this;
        x._readableState.ended || o.destroy(x, new i());
      }), this.body = I;
    }
    onData(y) {
      const { res: w } = this;
      return w.push(y);
    }
    onComplete(y) {
      const { res: w } = this;
      w.push(null);
    }
    onError(y) {
      const { ret: w } = this;
      this.handler = null, o.destroy(w, y);
    }
  }
  function f(p, y) {
    try {
      const w = new h(p, y);
      return this.dispatch({ ...p, body: w.req }, w), w.ret;
    } catch (w) {
      return new r().destroy(w);
    }
  }
  return Fa = f, Fa;
}
var va, Qu;
function Jy() {
  if (Qu) return va;
  Qu = 1;
  const { InvalidArgumentError: t, SocketError: e } = it(), { AsyncResource: r } = _s, n = Xe(), { addSignal: s, removeSignal: i } = to(), o = lt;
  class a extends r {
    constructor(l, d) {
      if (!l || typeof l != "object")
        throw new t("invalid opts");
      if (typeof d != "function")
        throw new t("invalid callback");
      const { signal: u, opaque: m, responseHeaders: h } = l;
      if (u && typeof u.on != "function" && typeof u.addEventListener != "function")
        throw new t("signal must be an EventEmitter or EventTarget");
      super("UNDICI_UPGRADE"), this.responseHeaders = h || null, this.opaque = m || null, this.callback = d, this.abort = null, this.context = null, s(this, u);
    }
    onConnect(l, d) {
      if (this.reason) {
        l(this.reason);
        return;
      }
      o(this.callback), this.abort = l, this.context = null;
    }
    onHeaders() {
      throw new e("bad upgrade", null);
    }
    onUpgrade(l, d, u) {
      o(l === 101);
      const { callback: m, opaque: h, context: f } = this;
      i(this), this.callback = null;
      const p = this.responseHeaders === "raw" ? n.parseRawHeaders(d) : n.parseHeaders(d);
      this.runInAsyncScope(m, null, null, {
        headers: p,
        socket: u,
        opaque: h,
        context: f
      });
    }
    onError(l) {
      const { callback: d, opaque: u } = this;
      i(this), d && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(d, null, l, { opaque: u });
      }));
    }
  }
  function A(c, l) {
    if (l === void 0)
      return new Promise((d, u) => {
        A.call(this, c, (m, h) => m ? u(m) : d(h));
      });
    try {
      const d = new a(c, l);
      this.dispatch({
        ...c,
        method: c.method || "GET",
        upgrade: c.protocol || "Websocket"
      }, d);
    } catch (d) {
      if (typeof l != "function")
        throw d;
      const u = c?.opaque;
      queueMicrotask(() => l(d, { opaque: u }));
    }
  }
  return va = A, va;
}
var La, Nu;
function Vy() {
  if (Nu) return La;
  Nu = 1;
  const t = lt, { AsyncResource: e } = _s, { InvalidArgumentError: r, SocketError: n } = it(), s = Xe(), { addSignal: i, removeSignal: o } = to();
  class a extends e {
    constructor(l, d) {
      if (!l || typeof l != "object")
        throw new r("invalid opts");
      if (typeof d != "function")
        throw new r("invalid callback");
      const { signal: u, opaque: m, responseHeaders: h } = l;
      if (u && typeof u.on != "function" && typeof u.addEventListener != "function")
        throw new r("signal must be an EventEmitter or EventTarget");
      super("UNDICI_CONNECT"), this.opaque = m || null, this.responseHeaders = h || null, this.callback = d, this.abort = null, i(this, u);
    }
    onConnect(l, d) {
      if (this.reason) {
        l(this.reason);
        return;
      }
      t(this.callback), this.abort = l, this.context = d;
    }
    onHeaders() {
      throw new n("bad connect", null);
    }
    onUpgrade(l, d, u) {
      const { callback: m, opaque: h, context: f } = this;
      o(this), this.callback = null;
      let p = d;
      p != null && (p = this.responseHeaders === "raw" ? s.parseRawHeaders(d) : s.parseHeaders(d)), this.runInAsyncScope(m, null, null, {
        statusCode: l,
        headers: p,
        socket: u,
        opaque: h,
        context: f
      });
    }
    onError(l) {
      const { callback: d, opaque: u } = this;
      o(this), d && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(d, null, l, { opaque: u });
      }));
    }
  }
  function A(c, l) {
    if (l === void 0)
      return new Promise((d, u) => {
        A.call(this, c, (m, h) => m ? u(m) : d(h));
      });
    try {
      const d = new a(c, l);
      this.dispatch({ ...c, method: "CONNECT" }, d);
    } catch (d) {
      if (typeof l != "function")
        throw d;
      const u = c?.opaque;
      queueMicrotask(() => l(d, { opaque: u }));
    }
  }
  return La = A, La;
}
var wu;
function _y() {
  return wu || (wu = 1, dn.request = qy(), dn.stream = Gy(), dn.pipeline = Yy(), dn.upgrade = Jy(), dn.connect = Vy()), dn;
}
var Ua, bu;
function df() {
  if (bu) return Ua;
  bu = 1;
  const { UndiciError: t } = it(), e = /* @__PURE__ */ Symbol.for("undici.error.UND_MOCK_ERR_MOCK_NOT_MATCHED");
  class r extends t {
    constructor(s) {
      super(s), Error.captureStackTrace(this, r), this.name = "MockNotMatchedError", this.message = s || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
    static [Symbol.hasInstance](s) {
      return s && s[e] === !0;
    }
    [e] = !0;
  }
  return Ua = {
    MockNotMatchedError: r
  }, Ua;
}
var Pa, xu;
function ei() {
  return xu || (xu = 1, Pa = {
    kAgent: /* @__PURE__ */ Symbol("agent"),
    kOptions: /* @__PURE__ */ Symbol("options"),
    kFactory: /* @__PURE__ */ Symbol("factory"),
    kDispatches: /* @__PURE__ */ Symbol("dispatches"),
    kDispatchKey: /* @__PURE__ */ Symbol("dispatch key"),
    kDefaultHeaders: /* @__PURE__ */ Symbol("default headers"),
    kDefaultTrailers: /* @__PURE__ */ Symbol("default trailers"),
    kContentLength: /* @__PURE__ */ Symbol("content length"),
    kMockAgent: /* @__PURE__ */ Symbol("mock agent"),
    kMockAgentSet: /* @__PURE__ */ Symbol("mock agent set"),
    kMockAgentGet: /* @__PURE__ */ Symbol("mock agent get"),
    kMockDispatch: /* @__PURE__ */ Symbol("mock dispatch"),
    kClose: /* @__PURE__ */ Symbol("close"),
    kOriginalClose: /* @__PURE__ */ Symbol("original agent close"),
    kOrigin: /* @__PURE__ */ Symbol("origin"),
    kIsMockActive: /* @__PURE__ */ Symbol("is mock active"),
    kNetConnect: /* @__PURE__ */ Symbol("net connect"),
    kGetNetConnect: /* @__PURE__ */ Symbol("get net connect"),
    kConnected: /* @__PURE__ */ Symbol("connected")
  }), Pa;
}
var Ha, Ru;
function ro() {
  if (Ru) return Ha;
  Ru = 1;
  const { MockNotMatchedError: t } = df(), {
    kDispatches: e,
    kMockAgent: r,
    kOriginalDispatch: n,
    kOrigin: s,
    kGetNetConnect: i
  } = ei(), { buildURL: o } = Xe(), { STATUS_CODES: a } = Bn, {
    types: {
      isPromise: A
    }
  } = _t;
  function c(E, b) {
    return typeof E == "string" ? E === b : E instanceof RegExp ? E.test(b) : typeof E == "function" ? E(b) === !0 : !1;
  }
  function l(E) {
    return Object.fromEntries(
      Object.entries(E).map(([b, N]) => [b.toLocaleLowerCase(), N])
    );
  }
  function d(E, b) {
    if (Array.isArray(E)) {
      for (let N = 0; N < E.length; N += 2)
        if (E[N].toLocaleLowerCase() === b.toLocaleLowerCase())
          return E[N + 1];
      return;
    } else return typeof E.get == "function" ? E.get(b) : l(E)[b.toLocaleLowerCase()];
  }
  function u(E) {
    const b = E.slice(), N = [];
    for (let S = 0; S < b.length; S += 2)
      N.push([b[S], b[S + 1]]);
    return Object.fromEntries(N);
  }
  function m(E, b) {
    if (typeof E.headers == "function")
      return Array.isArray(b) && (b = u(b)), E.headers(b ? l(b) : {});
    if (typeof E.headers > "u")
      return !0;
    if (typeof b != "object" || typeof E.headers != "object")
      return !1;
    for (const [N, S] of Object.entries(E.headers)) {
      const M = d(b, N);
      if (!c(S, M))
        return !1;
    }
    return !0;
  }
  function h(E) {
    if (typeof E != "string")
      return E;
    const b = E.split("?");
    if (b.length !== 2)
      return E;
    const N = new URLSearchParams(b.pop());
    return N.sort(), [...b, N.toString()].join("?");
  }
  function f(E, { path: b, method: N, body: S, headers: M }) {
    const k = c(E.path, b), F = c(E.method, N), P = typeof E.body < "u" ? c(E.body, S) : !0, J = m(E, M);
    return k && F && P && J;
  }
  function p(E) {
    return Buffer.isBuffer(E) || E instanceof Uint8Array || E instanceof ArrayBuffer ? E : typeof E == "object" ? JSON.stringify(E) : E.toString();
  }
  function y(E, b) {
    const N = b.query ? o(b.path, b.query) : b.path, S = typeof N == "string" ? h(N) : N;
    let M = E.filter(({ consumed: k }) => !k).filter(({ path: k }) => c(h(k), S));
    if (M.length === 0)
      throw new t(`Mock dispatch not matched for path '${S}'`);
    if (M = M.filter(({ method: k }) => c(k, b.method)), M.length === 0)
      throw new t(`Mock dispatch not matched for method '${b.method}' on path '${S}'`);
    if (M = M.filter(({ body: k }) => typeof k < "u" ? c(k, b.body) : !0), M.length === 0)
      throw new t(`Mock dispatch not matched for body '${b.body}' on path '${S}'`);
    if (M = M.filter((k) => m(k, b.headers)), M.length === 0) {
      const k = typeof b.headers == "object" ? JSON.stringify(b.headers) : b.headers;
      throw new t(`Mock dispatch not matched for headers '${k}' on path '${S}'`);
    }
    return M[0];
  }
  function w(E, b, N) {
    const S = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 }, M = typeof N == "function" ? { callback: N } : { ...N }, k = { ...S, ...b, pending: !0, data: { error: null, ...M } };
    return E.push(k), k;
  }
  function R(E, b) {
    const N = E.findIndex((S) => S.consumed ? f(S, b) : !1);
    N !== -1 && E.splice(N, 1);
  }
  function D(E) {
    const { path: b, method: N, body: S, headers: M, query: k } = E;
    return {
      path: b,
      method: N,
      body: S,
      headers: M,
      query: k
    };
  }
  function L(E) {
    const b = Object.keys(E), N = [];
    for (let S = 0; S < b.length; ++S) {
      const M = b[S], k = E[M], F = Buffer.from(`${M}`);
      if (Array.isArray(k))
        for (let P = 0; P < k.length; ++P)
          N.push(F, Buffer.from(`${k[P]}`));
      else
        N.push(F, Buffer.from(`${k}`));
    }
    return N;
  }
  function C(E) {
    return a[E] || "unknown";
  }
  async function I(E) {
    const b = [];
    for await (const N of E)
      b.push(N);
    return Buffer.concat(b).toString("utf8");
  }
  function x(E, b) {
    const N = D(E), S = y(this[e], N);
    S.timesInvoked++, S.data.callback && (S.data = { ...S.data, ...S.data.callback(E) });
    const { data: { statusCode: M, data: k, headers: F, trailers: P, error: J }, delay: te, persist: ee } = S, { timesInvoked: de, times: ue } = S;
    if (S.consumed = !ee && de >= ue, S.pending = de < ue, J !== null)
      return R(this[e], N), b.onError(J), !0;
    typeof te == "number" && te > 0 ? setTimeout(() => {
      ce(this[e]);
    }, te) : ce(this[e]);
    function ce(Ce, Z = k) {
      const _ = Array.isArray(E.headers) ? u(E.headers) : E.headers, ne = typeof Z == "function" ? Z({ ...E, headers: _ }) : Z;
      if (A(ne)) {
        ne.then(($) => ce(Ce, $));
        return;
      }
      const H = p(ne), W = L(F), z = L(P);
      b.onConnect?.(($) => b.onError($), null), b.onHeaders?.(M, W, fe, C(M)), b.onData?.(Buffer.from(H)), b.onComplete?.(z), R(Ce, N);
    }
    function fe() {
    }
    return !0;
  }
  function g() {
    const E = this[r], b = this[s], N = this[n];
    return function(M, k) {
      if (E.isMockActive)
        try {
          x.call(this, M, k);
        } catch (F) {
          if (F instanceof t) {
            const P = E[i]();
            if (P === !1)
              throw new t(`${F.message}: subsequent request to origin ${b} was not allowed (net.connect disabled)`);
            if (B(P, b))
              N.call(this, M, k);
            else
              throw new t(`${F.message}: subsequent request to origin ${b} was not allowed (net.connect is not enabled for this origin)`);
          } else
            throw F;
        }
      else
        N.call(this, M, k);
    };
  }
  function B(E, b) {
    const N = new URL(b);
    return E === !0 ? !0 : !!(Array.isArray(E) && E.some((S) => c(S, N.host)));
  }
  function Q(E) {
    if (E) {
      const { agent: b, ...N } = E;
      return N;
    }
  }
  return Ha = {
    getResponseData: p,
    getMockDispatch: y,
    addMockDispatch: w,
    deleteMockDispatch: R,
    buildKey: D,
    generateKeyValues: L,
    matchValue: c,
    getResponse: I,
    getStatusText: C,
    mockDispatch: x,
    buildMockDispatch: g,
    checkNetConnect: B,
    buildMockOptions: Q,
    getHeaderByName: d,
    buildHeadersFromArray: u
  }, Ha;
}
var Ei = {}, Su;
function uf() {
  if (Su) return Ei;
  Su = 1;
  const { getResponseData: t, buildKey: e, addMockDispatch: r } = ro(), {
    kDispatches: n,
    kDispatchKey: s,
    kDefaultHeaders: i,
    kDefaultTrailers: o,
    kContentLength: a,
    kMockDispatch: A
  } = ei(), { InvalidArgumentError: c } = it(), { buildURL: l } = Xe();
  class d {
    constructor(h) {
      this[A] = h;
    }
    /**
     * Delay a reply by a set amount in ms.
     */
    delay(h) {
      if (typeof h != "number" || !Number.isInteger(h) || h <= 0)
        throw new c("waitInMs must be a valid integer > 0");
      return this[A].delay = h, this;
    }
    /**
     * For a defined reply, never mark as consumed.
     */
    persist() {
      return this[A].persist = !0, this;
    }
    /**
     * Allow one to define a reply for a set amount of matching requests.
     */
    times(h) {
      if (typeof h != "number" || !Number.isInteger(h) || h <= 0)
        throw new c("repeatTimes must be a valid integer > 0");
      return this[A].times = h, this;
    }
  }
  class u {
    constructor(h, f) {
      if (typeof h != "object")
        throw new c("opts must be an object");
      if (typeof h.path > "u")
        throw new c("opts.path must be defined");
      if (typeof h.method > "u" && (h.method = "GET"), typeof h.path == "string")
        if (h.query)
          h.path = l(h.path, h.query);
        else {
          const p = new URL(h.path, "data://");
          h.path = p.pathname + p.search;
        }
      typeof h.method == "string" && (h.method = h.method.toUpperCase()), this[s] = e(h), this[n] = f, this[i] = {}, this[o] = {}, this[a] = !1;
    }
    createMockScopeDispatchData({ statusCode: h, data: f, responseOptions: p }) {
      const y = t(f), w = this[a] ? { "content-length": y.length } : {}, R = { ...this[i], ...w, ...p.headers }, D = { ...this[o], ...p.trailers };
      return { statusCode: h, data: f, headers: R, trailers: D };
    }
    validateReplyParameters(h) {
      if (typeof h.statusCode > "u")
        throw new c("statusCode must be defined");
      if (typeof h.responseOptions != "object" || h.responseOptions === null)
        throw new c("responseOptions must be an object");
    }
    /**
     * Mock an undici request with a defined reply.
     */
    reply(h) {
      if (typeof h == "function") {
        const w = (D) => {
          const L = h(D);
          if (typeof L != "object" || L === null)
            throw new c("reply options callback must return an object");
          const C = { data: "", responseOptions: {}, ...L };
          return this.validateReplyParameters(C), {
            ...this.createMockScopeDispatchData(C)
          };
        }, R = r(this[n], this[s], w);
        return new d(R);
      }
      const f = {
        statusCode: h,
        data: arguments[1] === void 0 ? "" : arguments[1],
        responseOptions: arguments[2] === void 0 ? {} : arguments[2]
      };
      this.validateReplyParameters(f);
      const p = this.createMockScopeDispatchData(f), y = r(this[n], this[s], p);
      return new d(y);
    }
    /**
     * Mock an undici request with a defined error.
     */
    replyWithError(h) {
      if (typeof h > "u")
        throw new c("error must be defined");
      const f = r(this[n], this[s], { error: h });
      return new d(f);
    }
    /**
     * Set default reply headers on the interceptor for subsequent replies
     */
    defaultReplyHeaders(h) {
      if (typeof h > "u")
        throw new c("headers must be defined");
      return this[i] = h, this;
    }
    /**
     * Set default reply trailers on the interceptor for subsequent replies
     */
    defaultReplyTrailers(h) {
      if (typeof h > "u")
        throw new c("trailers must be defined");
      return this[o] = h, this;
    }
    /**
     * Set reply content length header for replies on the interceptor
     */
    replyContentLength() {
      return this[a] = !0, this;
    }
  }
  return Ei.MockInterceptor = u, Ei.MockScope = d, Ei;
}
var Oa, Du;
function mf() {
  if (Du) return Oa;
  Du = 1;
  const { promisify: t } = _t, e = Zs(), { buildMockDispatch: r } = ro(), {
    kDispatches: n,
    kMockAgent: s,
    kClose: i,
    kOriginalClose: o,
    kOrigin: a,
    kOriginalDispatch: A,
    kConnected: c
  } = ei(), { MockInterceptor: l } = uf(), d = gt(), { InvalidArgumentError: u } = it();
  class m extends e {
    constructor(f, p) {
      if (super(f, p), !p || !p.agent || typeof p.agent.dispatch != "function")
        throw new u("Argument opts.agent must implement Agent");
      this[s] = p.agent, this[a] = f, this[n] = [], this[c] = 1, this[A] = this.dispatch, this[o] = this.close.bind(this), this.dispatch = r.call(this), this.close = this[i];
    }
    get [d.kConnected]() {
      return this[c];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(f) {
      return new l(f, this[n]);
    }
    async [i]() {
      await t(this[o])(), this[c] = 0, this[s][d.kClients].delete(this[a]);
    }
  }
  return Oa = m, Oa;
}
var za, ku;
function hf() {
  if (ku) return za;
  ku = 1;
  const { promisify: t } = _t, e = Ks(), { buildMockDispatch: r } = ro(), {
    kDispatches: n,
    kMockAgent: s,
    kClose: i,
    kOriginalClose: o,
    kOrigin: a,
    kOriginalDispatch: A,
    kConnected: c
  } = ei(), { MockInterceptor: l } = uf(), d = gt(), { InvalidArgumentError: u } = it();
  class m extends e {
    constructor(f, p) {
      if (super(f, p), !p || !p.agent || typeof p.agent.dispatch != "function")
        throw new u("Argument opts.agent must implement Agent");
      this[s] = p.agent, this[a] = f, this[n] = [], this[c] = 1, this[A] = this.dispatch, this[o] = this.close.bind(this), this.dispatch = r.call(this), this.close = this[i];
    }
    get [d.kConnected]() {
      return this[c];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(f) {
      return new l(f, this[n]);
    }
    async [i]() {
      await t(this[o])(), this[c] = 0, this[s][d.kClients].delete(this[a]);
    }
  }
  return za = m, za;
}
var qa, Mu;
function Wy() {
  if (Mu) return qa;
  Mu = 1;
  const t = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  }, e = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  return qa = class {
    constructor(n, s) {
      this.singular = n, this.plural = s;
    }
    pluralize(n) {
      const s = n === 1, i = s ? t : e, o = s ? this.singular : this.plural;
      return { ...i, count: n, noun: o };
    }
  }, qa;
}
var Ga, Tu;
function $y() {
  if (Tu) return Ga;
  Tu = 1;
  const { Transform: t } = dr, { Console: e } = my, r = process.versions.icu ? "" : "Y ", n = process.versions.icu ? "" : "N ";
  return Ga = class {
    constructor({ disableColors: i } = {}) {
      this.transform = new t({
        transform(o, a, A) {
          A(null, o);
        }
      }), this.logger = new e({
        stdout: this.transform,
        inspectOptions: {
          colors: !i && !process.env.CI
        }
      });
    }
    format(i) {
      const o = i.map(
        ({ method: a, path: A, data: { statusCode: c }, persist: l, times: d, timesInvoked: u, origin: m }) => ({
          Method: a,
          Origin: m,
          Path: A,
          "Status code": c,
          Persistent: l ? r : n,
          Invocations: u,
          Remaining: l ? 1 / 0 : d - u
        })
      );
      return this.logger.table(o), this.transform.read().toString();
    }
  }, Ga;
}
var Ya, Fu;
function Xy() {
  if (Fu) return Ya;
  Fu = 1;
  const { kClients: t } = gt(), e = js(), {
    kAgent: r,
    kMockAgentSet: n,
    kMockAgentGet: s,
    kDispatches: i,
    kIsMockActive: o,
    kNetConnect: a,
    kGetNetConnect: A,
    kOptions: c,
    kFactory: l
  } = ei(), d = mf(), u = hf(), { matchValue: m, buildMockOptions: h } = ro(), { InvalidArgumentError: f, UndiciError: p } = it(), y = Zi(), w = Wy(), R = $y();
  class D extends y {
    constructor(C) {
      if (super(C), this[a] = !0, this[o] = !0, C?.agent && typeof C.agent.dispatch != "function")
        throw new f("Argument opts.agent must implement Agent");
      const I = C?.agent ? C.agent : new e(C);
      this[r] = I, this[t] = I[t], this[c] = h(C);
    }
    get(C) {
      let I = this[s](C);
      return I || (I = this[l](C), this[n](C, I)), I;
    }
    dispatch(C, I) {
      return this.get(C.origin), this[r].dispatch(C, I);
    }
    async close() {
      await this[r].close(), this[t].clear();
    }
    deactivate() {
      this[o] = !1;
    }
    activate() {
      this[o] = !0;
    }
    enableNetConnect(C) {
      if (typeof C == "string" || typeof C == "function" || C instanceof RegExp)
        Array.isArray(this[a]) ? this[a].push(C) : this[a] = [C];
      else if (typeof C > "u")
        this[a] = !0;
      else
        throw new f("Unsupported matcher. Must be one of String|Function|RegExp.");
    }
    disableNetConnect() {
      this[a] = !1;
    }
    // This is required to bypass issues caused by using global symbols - see:
    // https://github.com/nodejs/undici/issues/1447
    get isMockActive() {
      return this[o];
    }
    [n](C, I) {
      this[t].set(C, I);
    }
    [l](C) {
      const I = Object.assign({ agent: this }, this[c]);
      return this[c] && this[c].connections === 1 ? new d(C, I) : new u(C, I);
    }
    [s](C) {
      const I = this[t].get(C);
      if (I)
        return I;
      if (typeof C != "string") {
        const x = this[l]("http://localhost:9999");
        return this[n](C, x), x;
      }
      for (const [x, g] of Array.from(this[t]))
        if (g && typeof x != "string" && m(x, C)) {
          const B = this[l](C);
          return this[n](C, B), B[i] = g[i], B;
        }
    }
    [A]() {
      return this[a];
    }
    pendingInterceptors() {
      const C = this[t];
      return Array.from(C.entries()).flatMap(([I, x]) => x[i].map((g) => ({ ...g, origin: I }))).filter(({ pending: I }) => I);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter: C = new R() } = {}) {
      const I = this.pendingInterceptors();
      if (I.length === 0)
        return;
      const x = new w("interceptor", "interceptors").pluralize(I.length);
      throw new p(`
${x.count} ${x.noun} ${x.is} pending:

${C.format(I)}
`.trim());
    }
  }
  return Ya = D, Ya;
}
var Ja, vu;
function Nl() {
  if (vu) return Ja;
  vu = 1;
  const t = /* @__PURE__ */ Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError: e } = it(), r = js();
  s() === void 0 && n(new r());
  function n(i) {
    if (!i || typeof i.dispatch != "function")
      throw new e("Argument agent must implement Agent");
    Object.defineProperty(globalThis, t, {
      value: i,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  function s() {
    return globalThis[t];
  }
  return Ja = {
    setGlobalDispatcher: n,
    getGlobalDispatcher: s
  }, Ja;
}
var Va, Lu;
function wl() {
  return Lu || (Lu = 1, Va = class {
    #e;
    constructor(e) {
      if (typeof e != "object" || e === null)
        throw new TypeError("handler must be an object");
      this.#e = e;
    }
    onConnect(...e) {
      return this.#e.onConnect?.(...e);
    }
    onError(...e) {
      return this.#e.onError?.(...e);
    }
    onUpgrade(...e) {
      return this.#e.onUpgrade?.(...e);
    }
    onResponseStarted(...e) {
      return this.#e.onResponseStarted?.(...e);
    }
    onHeaders(...e) {
      return this.#e.onHeaders?.(...e);
    }
    onData(...e) {
      return this.#e.onData?.(...e);
    }
    onComplete(...e) {
      return this.#e.onComplete?.(...e);
    }
    onBodySent(...e) {
      return this.#e.onBodySent?.(...e);
    }
  }), Va;
}
var _a, Uu;
function Zy() {
  if (Uu) return _a;
  Uu = 1;
  const t = Il();
  return _a = (e) => {
    const r = e?.maxRedirections;
    return (n) => function(i, o) {
      const { maxRedirections: a = r, ...A } = i;
      if (!a)
        return n(i, o);
      const c = new t(
        n,
        a,
        i,
        o
      );
      return n(A, c);
    };
  }, _a;
}
var Wa, Pu;
function Ky() {
  if (Pu) return Wa;
  Pu = 1;
  const t = Ql();
  return Wa = (e) => (r) => function(s, i) {
    return r(
      s,
      new t(
        { ...s, retryOptions: { ...e, ...s.retryOptions } },
        {
          handler: i,
          dispatch: r
        }
      )
    );
  }, Wa;
}
var $a, Hu;
function jy() {
  if (Hu) return $a;
  Hu = 1;
  const t = Xe(), { InvalidArgumentError: e, RequestAbortedError: r } = it(), n = wl();
  class s extends n {
    #e = 1024 * 1024;
    #t = null;
    #s = !1;
    #n = !1;
    #r = 0;
    #i = null;
    #o = null;
    constructor({ maxSize: a }, A) {
      if (super(A), a != null && (!Number.isFinite(a) || a < 1))
        throw new e("maxSize must be a number greater than 0");
      this.#e = a ?? this.#e, this.#o = A;
    }
    onConnect(a) {
      this.#t = a, this.#o.onConnect(this.#a.bind(this));
    }
    #a(a) {
      this.#n = !0, this.#i = a;
    }
    // TODO: will require adjustment after new hooks are out
    onHeaders(a, A, c, l) {
      const u = t.parseHeaders(A)["content-length"];
      if (u != null && u > this.#e)
        throw new r(
          `Response size (${u}) larger than maxSize (${this.#e})`
        );
      return this.#n ? !0 : this.#o.onHeaders(
        a,
        A,
        c,
        l
      );
    }
    onError(a) {
      this.#s || (a = this.#i ?? a, this.#o.onError(a));
    }
    onData(a) {
      return this.#r = this.#r + a.length, this.#r >= this.#e && (this.#s = !0, this.#n ? this.#o.onError(this.#i) : this.#o.onComplete([])), !0;
    }
    onComplete(a) {
      if (!this.#s) {
        if (this.#n) {
          this.#o.onError(this.reason);
          return;
        }
        this.#o.onComplete(a);
      }
    }
  }
  function i({ maxSize: o } = {
    maxSize: 1024 * 1024
  }) {
    return (a) => function(c, l) {
      const { dumpMaxSize: d = o } = c, u = new s(
        { maxSize: d },
        l
      );
      return a(c, u);
    };
  }
  return $a = i, $a;
}
var Xa, Ou;
function eQ() {
  if (Ou) return Xa;
  Ou = 1;
  const { isIP: t } = Xi, { lookup: e } = hy, r = wl(), { InvalidArgumentError: n, InformationalError: s } = it(), i = Math.pow(2, 31) - 1;
  class o {
    #e = 0;
    #t = 0;
    #s = /* @__PURE__ */ new Map();
    dualStack = !0;
    affinity = null;
    lookup = null;
    pick = null;
    constructor(c) {
      this.#e = c.maxTTL, this.#t = c.maxItems, this.dualStack = c.dualStack, this.affinity = c.affinity, this.lookup = c.lookup ?? this.#n, this.pick = c.pick ?? this.#r;
    }
    get full() {
      return this.#s.size === this.#t;
    }
    runLookup(c, l, d) {
      const u = this.#s.get(c.hostname);
      if (u == null && this.full) {
        d(null, c.origin);
        return;
      }
      const m = {
        affinity: this.affinity,
        dualStack: this.dualStack,
        lookup: this.lookup,
        pick: this.pick,
        ...l.dns,
        maxTTL: this.#e,
        maxItems: this.#t
      };
      if (u == null)
        this.lookup(c, m, (h, f) => {
          if (h || f == null || f.length === 0) {
            d(h ?? new s("No DNS entries found"));
            return;
          }
          this.setRecords(c, f);
          const p = this.#s.get(c.hostname), y = this.pick(
            c,
            p,
            m.affinity
          );
          let w;
          typeof y.port == "number" ? w = `:${y.port}` : c.port !== "" ? w = `:${c.port}` : w = "", d(
            null,
            `${c.protocol}//${y.family === 6 ? `[${y.address}]` : y.address}${w}`
          );
        });
      else {
        const h = this.pick(
          c,
          u,
          m.affinity
        );
        if (h == null) {
          this.#s.delete(c.hostname), this.runLookup(c, l, d);
          return;
        }
        let f;
        typeof h.port == "number" ? f = `:${h.port}` : c.port !== "" ? f = `:${c.port}` : f = "", d(
          null,
          `${c.protocol}//${h.family === 6 ? `[${h.address}]` : h.address}${f}`
        );
      }
    }
    #n(c, l, d) {
      e(
        c.hostname,
        {
          all: !0,
          family: this.dualStack === !1 ? this.affinity : 0,
          order: "ipv4first"
        },
        (u, m) => {
          if (u)
            return d(u);
          const h = /* @__PURE__ */ new Map();
          for (const f of m)
            h.set(`${f.address}:${f.family}`, f);
          d(null, h.values());
        }
      );
    }
    #r(c, l, d) {
      let u = null;
      const { records: m, offset: h } = l;
      let f;
      if (this.dualStack ? (d == null && (h == null || h === i ? (l.offset = 0, d = 4) : (l.offset++, d = (l.offset & 1) === 1 ? 6 : 4)), m[d] != null && m[d].ips.length > 0 ? f = m[d] : f = m[d === 4 ? 6 : 4]) : f = m[d], f == null || f.ips.length === 0)
        return u;
      f.offset == null || f.offset === i ? f.offset = 0 : f.offset++;
      const p = f.offset % f.ips.length;
      return u = f.ips[p] ?? null, u == null ? u : Date.now() - u.timestamp > u.ttl ? (f.ips.splice(p, 1), this.pick(c, l, d)) : u;
    }
    setRecords(c, l) {
      const d = Date.now(), u = { records: { 4: null, 6: null } };
      for (const m of l) {
        m.timestamp = d, typeof m.ttl == "number" ? m.ttl = Math.min(m.ttl, this.#e) : m.ttl = this.#e;
        const h = u.records[m.family] ?? { ips: [] };
        h.ips.push(m), u.records[m.family] = h;
      }
      this.#s.set(c.hostname, u);
    }
    getHandler(c, l) {
      return new a(this, c, l);
    }
  }
  class a extends r {
    #e = null;
    #t = null;
    #s = null;
    #n = null;
    #r = null;
    constructor(c, { origin: l, handler: d, dispatch: u }, m) {
      super(d), this.#r = l, this.#n = d, this.#t = { ...m }, this.#e = c, this.#s = u;
    }
    onError(c) {
      switch (c.code) {
        case "ETIMEDOUT":
        case "ECONNREFUSED": {
          if (this.#e.dualStack) {
            this.#e.runLookup(this.#r, this.#t, (l, d) => {
              if (l)
                return this.#n.onError(l);
              const u = {
                ...this.#t,
                origin: d
              };
              this.#s(u, this);
            });
            return;
          }
          this.#n.onError(c);
          return;
        }
        case "ENOTFOUND":
          this.#e.deleteRecord(this.#r);
        // eslint-disable-next-line no-fallthrough
        default:
          this.#n.onError(c);
          break;
      }
    }
  }
  return Xa = (A) => {
    if (A?.maxTTL != null && (typeof A?.maxTTL != "number" || A?.maxTTL < 0))
      throw new n("Invalid maxTTL. Must be a positive number");
    if (A?.maxItems != null && (typeof A?.maxItems != "number" || A?.maxItems < 1))
      throw new n(
        "Invalid maxItems. Must be a positive number and greater than zero"
      );
    if (A?.affinity != null && A?.affinity !== 4 && A?.affinity !== 6)
      throw new n("Invalid affinity. Must be either 4 or 6");
    if (A?.dualStack != null && typeof A?.dualStack != "boolean")
      throw new n("Invalid dualStack. Must be a boolean");
    if (A?.lookup != null && typeof A?.lookup != "function")
      throw new n("Invalid lookup. Must be a function");
    if (A?.pick != null && typeof A?.pick != "function")
      throw new n("Invalid pick. Must be a function");
    const c = A?.dualStack ?? !0;
    let l;
    c ? l = A?.affinity ?? null : l = A?.affinity ?? 4;
    const d = {
      maxTTL: A?.maxTTL ?? 1e4,
      // Expressed in ms
      lookup: A?.lookup ?? null,
      pick: A?.pick ?? null,
      dualStack: c,
      affinity: l,
      maxItems: A?.maxItems ?? 1 / 0
    }, u = new o(d);
    return (m) => function(f, p) {
      const y = f.origin.constructor === URL ? f.origin : new URL(f.origin);
      return t(y.hostname) !== 0 ? m(f, p) : (u.runLookup(y, f, (w, R) => {
        if (w)
          return p.onError(w);
        let D = null;
        D = {
          ...f,
          servername: y.hostname,
          // For SNI on TLS
          origin: R,
          headers: {
            host: y.hostname,
            ...f.headers
          }
        }, m(
          D,
          u.getHandler({ origin: y, dispatch: m, handler: p }, f)
        );
      }), !0);
    };
  }, Xa;
}
var Za, zu;
function Xn() {
  if (zu) return Za;
  zu = 1;
  const { kConstruct: t } = gt(), { kEnumerableProperty: e } = Xe(), {
    iteratorMixin: r,
    isValidHeaderName: n,
    isValidHeaderValue: s
  } = mr(), { webidl: i } = zt(), o = lt, a = _t, A = /* @__PURE__ */ Symbol("headers map"), c = /* @__PURE__ */ Symbol("headers map sorted");
  function l(L) {
    return L === 10 || L === 13 || L === 9 || L === 32;
  }
  function d(L) {
    let C = 0, I = L.length;
    for (; I > C && l(L.charCodeAt(I - 1)); ) --I;
    for (; I > C && l(L.charCodeAt(C)); ) ++C;
    return C === 0 && I === L.length ? L : L.substring(C, I);
  }
  function u(L, C) {
    if (Array.isArray(C))
      for (let I = 0; I < C.length; ++I) {
        const x = C[I];
        if (x.length !== 2)
          throw i.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${x.length}.`
          });
        m(L, x[0], x[1]);
      }
    else if (typeof C == "object" && C !== null) {
      const I = Object.keys(C);
      for (let x = 0; x < I.length; ++x)
        m(L, I[x], C[I[x]]);
    } else
      throw i.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
  }
  function m(L, C, I) {
    if (I = d(I), n(C)) {
      if (!s(I))
        throw i.errors.invalidArgument({
          prefix: "Headers.append",
          value: I,
          type: "header value"
        });
    } else throw i.errors.invalidArgument({
      prefix: "Headers.append",
      value: C,
      type: "header name"
    });
    if (y(L) === "immutable")
      throw new TypeError("immutable");
    return R(L).append(C, I, !1);
  }
  function h(L, C) {
    return L[0] < C[0] ? -1 : 1;
  }
  class f {
    /** @type {[string, string][]|null} */
    cookies = null;
    constructor(C) {
      C instanceof f ? (this[A] = new Map(C[A]), this[c] = C[c], this.cookies = C.cookies === null ? null : [...C.cookies]) : (this[A] = new Map(C), this[c] = null);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#header-list-contains
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    contains(C, I) {
      return this[A].has(I ? C : C.toLowerCase());
    }
    clear() {
      this[A].clear(), this[c] = null, this.cookies = null;
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-append
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    append(C, I, x) {
      this[c] = null;
      const g = x ? C : C.toLowerCase(), B = this[A].get(g);
      if (B) {
        const Q = g === "cookie" ? "; " : ", ";
        this[A].set(g, {
          name: B.name,
          value: `${B.value}${Q}${I}`
        });
      } else
        this[A].set(g, { name: C, value: I });
      g === "set-cookie" && (this.cookies ??= []).push(I);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-set
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    set(C, I, x) {
      this[c] = null;
      const g = x ? C : C.toLowerCase();
      g === "set-cookie" && (this.cookies = [I]), this[A].set(g, { name: C, value: I });
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    delete(C, I) {
      this[c] = null, I || (C = C.toLowerCase()), C === "set-cookie" && (this.cookies = null), this[A].delete(C);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-get
     * @param {string} name
     * @param {boolean} isLowerCase
     * @returns {string | null}
     */
    get(C, I) {
      return this[A].get(I ? C : C.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: C, 1: { value: I } } of this[A])
        yield [C, I];
    }
    get entries() {
      const C = {};
      if (this[A].size !== 0)
        for (const { name: I, value: x } of this[A].values())
          C[I] = x;
      return C;
    }
    rawValues() {
      return this[A].values();
    }
    get entriesList() {
      const C = [];
      if (this[A].size !== 0)
        for (const { 0: I, 1: { name: x, value: g } } of this[A])
          if (I === "set-cookie")
            for (const B of this.cookies)
              C.push([x, B]);
          else
            C.push([x, g]);
      return C;
    }
    // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
    toSortedArray() {
      const C = this[A].size, I = new Array(C);
      if (C <= 32) {
        if (C === 0)
          return I;
        const x = this[A][Symbol.iterator](), g = x.next().value;
        I[0] = [g[0], g[1].value], o(g[1].value !== null);
        for (let B = 1, Q = 0, E = 0, b = 0, N = 0, S, M; B < C; ++B) {
          for (M = x.next().value, S = I[B] = [M[0], M[1].value], o(S[1] !== null), b = 0, E = B; b < E; )
            N = b + (E - b >> 1), I[N][0] <= S[0] ? b = N + 1 : E = N;
          if (B !== N) {
            for (Q = B; Q > b; )
              I[Q] = I[--Q];
            I[b] = S;
          }
        }
        if (!x.next().done)
          throw new TypeError("Unreachable");
        return I;
      } else {
        let x = 0;
        for (const { 0: g, 1: { value: B } } of this[A])
          I[x++] = [g, B], o(B !== null);
        return I.sort(h);
      }
    }
  }
  class p {
    #e;
    #t;
    constructor(C = void 0) {
      i.util.markAsUncloneable(this), C !== t && (this.#t = new f(), this.#e = "none", C !== void 0 && (C = i.converters.HeadersInit(C, "Headers contructor", "init"), u(this, C)));
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(C, I) {
      i.brandCheck(this, p), i.argumentLengthCheck(arguments, 2, "Headers.append");
      const x = "Headers.append";
      return C = i.converters.ByteString(C, x, "name"), I = i.converters.ByteString(I, x, "value"), m(this, C, I);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(C) {
      if (i.brandCheck(this, p), i.argumentLengthCheck(arguments, 1, "Headers.delete"), C = i.converters.ByteString(C, "Headers.delete", "name"), !n(C))
        throw i.errors.invalidArgument({
          prefix: "Headers.delete",
          value: C,
          type: "header name"
        });
      if (this.#e === "immutable")
        throw new TypeError("immutable");
      this.#t.contains(C, !1) && this.#t.delete(C, !1);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(C) {
      i.brandCheck(this, p), i.argumentLengthCheck(arguments, 1, "Headers.get");
      const I = "Headers.get";
      if (C = i.converters.ByteString(C, I, "name"), !n(C))
        throw i.errors.invalidArgument({
          prefix: I,
          value: C,
          type: "header name"
        });
      return this.#t.get(C, !1);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(C) {
      i.brandCheck(this, p), i.argumentLengthCheck(arguments, 1, "Headers.has");
      const I = "Headers.has";
      if (C = i.converters.ByteString(C, I, "name"), !n(C))
        throw i.errors.invalidArgument({
          prefix: I,
          value: C,
          type: "header name"
        });
      return this.#t.contains(C, !1);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(C, I) {
      i.brandCheck(this, p), i.argumentLengthCheck(arguments, 2, "Headers.set");
      const x = "Headers.set";
      if (C = i.converters.ByteString(C, x, "name"), I = i.converters.ByteString(I, x, "value"), I = d(I), n(C)) {
        if (!s(I))
          throw i.errors.invalidArgument({
            prefix: x,
            value: I,
            type: "header value"
          });
      } else throw i.errors.invalidArgument({
        prefix: x,
        value: C,
        type: "header name"
      });
      if (this.#e === "immutable")
        throw new TypeError("immutable");
      this.#t.set(C, I, !1);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      i.brandCheck(this, p);
      const C = this.#t.cookies;
      return C ? [...C] : [];
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
    get [c]() {
      if (this.#t[c])
        return this.#t[c];
      const C = [], I = this.#t.toSortedArray(), x = this.#t.cookies;
      if (x === null || x.length === 1)
        return this.#t[c] = I;
      for (let g = 0; g < I.length; ++g) {
        const { 0: B, 1: Q } = I[g];
        if (B === "set-cookie")
          for (let E = 0; E < x.length; ++E)
            C.push([B, x[E]]);
        else
          C.push([B, Q]);
      }
      return this.#t[c] = C;
    }
    [a.inspect.custom](C, I) {
      return I.depth ??= C, `Headers ${a.formatWithOptions(I, this.#t.entries)}`;
    }
    static getHeadersGuard(C) {
      return C.#e;
    }
    static setHeadersGuard(C, I) {
      C.#e = I;
    }
    static getHeadersList(C) {
      return C.#t;
    }
    static setHeadersList(C, I) {
      C.#t = I;
    }
  }
  const { getHeadersGuard: y, setHeadersGuard: w, getHeadersList: R, setHeadersList: D } = p;
  return Reflect.deleteProperty(p, "getHeadersGuard"), Reflect.deleteProperty(p, "setHeadersGuard"), Reflect.deleteProperty(p, "getHeadersList"), Reflect.deleteProperty(p, "setHeadersList"), r("Headers", p, c, 0, 1), Object.defineProperties(p.prototype, {
    append: e,
    delete: e,
    get: e,
    has: e,
    set: e,
    getSetCookie: e,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: !0
    },
    [a.inspect.custom]: {
      enumerable: !1
    }
  }), i.converters.HeadersInit = function(L, C, I) {
    if (i.util.Type(L) === "Object") {
      const x = Reflect.get(L, Symbol.iterator);
      if (!a.types.isProxy(L) && x === p.prototype.entries)
        try {
          return R(L).entriesList;
        } catch {
        }
      return typeof x == "function" ? i.converters["sequence<sequence<ByteString>>"](L, C, I, x.bind(L)) : i.converters["record<ByteString, ByteString>"](L, C, I);
    }
    throw i.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  }, Za = {
    fill: u,
    // for test.
    compareHeaderName: h,
    Headers: p,
    HeadersList: f,
    getHeadersGuard: y,
    setHeadersGuard: w,
    setHeadersList: D,
    getHeadersList: R
  }, Za;
}
var Ka, qu;
function no() {
  if (qu) return Ka;
  qu = 1;
  const { Headers: t, HeadersList: e, fill: r, getHeadersGuard: n, setHeadersGuard: s, setHeadersList: i } = Xn(), { extractBody: o, cloneBody: a, mixinBody: A, hasFinalizationRegistry: c, streamRegistry: l, bodyUnusable: d } = Xs(), u = Xe(), m = _t, { kEnumerableProperty: h } = u, {
    isValidReasonPhrase: f,
    isCancelled: p,
    isAborted: y,
    isBlobLike: w,
    serializeJavascriptValueToJSONString: R,
    isErrorLike: D,
    isomorphicEncode: L,
    environmentSettingsObject: C
  } = mr(), {
    redirectStatusSet: I,
    nullBodyStatus: x
  } = ji(), { kState: g, kHeaders: B } = xn(), { webidl: Q } = zt(), { FormData: E } = eo(), { URLSerializer: b } = or(), { kConstruct: N } = gt(), S = lt, { types: M } = _t, k = new TextEncoder("utf-8");
  class F {
    // Creates network error Response.
    static error() {
      return Ce(te(), "immutable");
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(_, ne = {}) {
      Q.argumentLengthCheck(arguments, 1, "Response.json"), ne !== null && (ne = Q.converters.ResponseInit(ne));
      const H = k.encode(
        R(_)
      ), W = o(H), z = Ce(J({}), "response");
      return fe(z, ne, { body: W[0], type: "application/json" }), z;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(_, ne = 302) {
      Q.argumentLengthCheck(arguments, 1, "Response.redirect"), _ = Q.converters.USVString(_), ne = Q.converters["unsigned short"](ne);
      let H;
      try {
        H = new URL(_, C.settingsObject.baseUrl);
      } catch ($) {
        throw new TypeError(`Failed to parse URL from ${_}`, { cause: $ });
      }
      if (!I.has(ne))
        throw new RangeError(`Invalid status code ${ne}`);
      const W = Ce(J({}), "immutable");
      W[g].status = ne;
      const z = L(b(H));
      return W[g].headersList.append("location", z, !0), W;
    }
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(_ = null, ne = {}) {
      if (Q.util.markAsUncloneable(this), _ === N)
        return;
      _ !== null && (_ = Q.converters.BodyInit(_)), ne = Q.converters.ResponseInit(ne), this[g] = J({}), this[B] = new t(N), s(this[B], "response"), i(this[B], this[g].headersList);
      let H = null;
      if (_ != null) {
        const [W, z] = o(_);
        H = { body: W, type: z };
      }
      fe(this, ne, H);
    }
    // Returns responses type, e.g., "cors".
    get type() {
      return Q.brandCheck(this, F), this[g].type;
    }
    // Returns responses URL, if it has one; otherwise the empty string.
    get url() {
      Q.brandCheck(this, F);
      const _ = this[g].urlList, ne = _[_.length - 1] ?? null;
      return ne === null ? "" : b(ne, !0);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      return Q.brandCheck(this, F), this[g].urlList.length > 1;
    }
    // Returns responses status.
    get status() {
      return Q.brandCheck(this, F), this[g].status;
    }
    // Returns whether responses status is an ok status.
    get ok() {
      return Q.brandCheck(this, F), this[g].status >= 200 && this[g].status <= 299;
    }
    // Returns responses status message.
    get statusText() {
      return Q.brandCheck(this, F), this[g].statusText;
    }
    // Returns responses headers as Headers.
    get headers() {
      return Q.brandCheck(this, F), this[B];
    }
    get body() {
      return Q.brandCheck(this, F), this[g].body ? this[g].body.stream : null;
    }
    get bodyUsed() {
      return Q.brandCheck(this, F), !!this[g].body && u.isDisturbed(this[g].body.stream);
    }
    // Returns a clone of response.
    clone() {
      if (Q.brandCheck(this, F), d(this))
        throw Q.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      const _ = P(this[g]);
      return c && this[g].body?.stream && l.register(this, new WeakRef(this[g].body.stream)), Ce(_, n(this[B]));
    }
    [m.inspect.custom](_, ne) {
      ne.depth === null && (ne.depth = 2), ne.colors ??= !0;
      const H = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${m.formatWithOptions(ne, H)}`;
    }
  }
  A(F), Object.defineProperties(F.prototype, {
    type: h,
    url: h,
    status: h,
    ok: h,
    redirected: h,
    statusText: h,
    headers: h,
    clone: h,
    body: h,
    bodyUsed: h,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: !0
    }
  }), Object.defineProperties(F, {
    json: h,
    redirect: h,
    error: h
  });
  function P(Z) {
    if (Z.internalResponse)
      return ue(
        P(Z.internalResponse),
        Z.type
      );
    const _ = J({ ...Z, body: null });
    return Z.body != null && (_.body = a(_, Z.body)), _;
  }
  function J(Z) {
    return {
      aborted: !1,
      rangeRequested: !1,
      timingAllowPassed: !1,
      requestIncludesCredentials: !1,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...Z,
      headersList: Z?.headersList ? new e(Z?.headersList) : new e(),
      urlList: Z?.urlList ? [...Z.urlList] : []
    };
  }
  function te(Z) {
    const _ = D(Z);
    return J({
      type: "error",
      status: 0,
      error: _ ? Z : new Error(Z && String(Z)),
      aborted: Z && Z.name === "AbortError"
    });
  }
  function ee(Z) {
    return (
      // A network error is a response whose type is "error",
      Z.type === "error" && // status is 0
      Z.status === 0
    );
  }
  function de(Z, _) {
    return _ = {
      internalResponse: Z,
      ..._
    }, new Proxy(Z, {
      get(ne, H) {
        return H in _ ? _[H] : ne[H];
      },
      set(ne, H, W) {
        return S(!(H in _)), ne[H] = W, !0;
      }
    });
  }
  function ue(Z, _) {
    if (_ === "basic")
      return de(Z, {
        type: "basic",
        headersList: Z.headersList
      });
    if (_ === "cors")
      return de(Z, {
        type: "cors",
        headersList: Z.headersList
      });
    if (_ === "opaque")
      return de(Z, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    if (_ === "opaqueredirect")
      return de(Z, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    S(!1);
  }
  function ce(Z, _ = null) {
    return S(p(Z)), y(Z) ? te(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: _ })) : te(Object.assign(new DOMException("Request was cancelled."), { cause: _ }));
  }
  function fe(Z, _, ne) {
    if (_.status !== null && (_.status < 200 || _.status > 599))
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    if ("statusText" in _ && _.statusText != null && !f(String(_.statusText)))
      throw new TypeError("Invalid statusText");
    if ("status" in _ && _.status != null && (Z[g].status = _.status), "statusText" in _ && _.statusText != null && (Z[g].statusText = _.statusText), "headers" in _ && _.headers != null && r(Z[B], _.headers), ne) {
      if (x.includes(Z.status))
        throw Q.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${Z.status}`
        });
      Z[g].body = ne.body, ne.type != null && !Z[g].headersList.contains("content-type", !0) && Z[g].headersList.append("content-type", ne.type, !0);
    }
  }
  function Ce(Z, _) {
    const ne = new F(N);
    return ne[g] = Z, ne[B] = new t(N), i(ne[B], Z.headersList), s(ne[B], _), c && Z.body?.stream && l.register(ne, new WeakRef(Z.body.stream)), ne;
  }
  return Q.converters.ReadableStream = Q.interfaceConverter(
    ReadableStream
  ), Q.converters.FormData = Q.interfaceConverter(
    E
  ), Q.converters.URLSearchParams = Q.interfaceConverter(
    URLSearchParams
  ), Q.converters.XMLHttpRequestBodyInit = function(Z, _, ne) {
    return typeof Z == "string" ? Q.converters.USVString(Z, _, ne) : w(Z) ? Q.converters.Blob(Z, _, ne, { strict: !1 }) : ArrayBuffer.isView(Z) || M.isArrayBuffer(Z) ? Q.converters.BufferSource(Z, _, ne) : u.isFormDataLike(Z) ? Q.converters.FormData(Z, _, ne, { strict: !1 }) : Z instanceof URLSearchParams ? Q.converters.URLSearchParams(Z, _, ne) : Q.converters.DOMString(Z, _, ne);
  }, Q.converters.BodyInit = function(Z, _, ne) {
    return Z instanceof ReadableStream ? Q.converters.ReadableStream(Z, _, ne) : Z?.[Symbol.asyncIterator] ? Z : Q.converters.XMLHttpRequestBodyInit(Z, _, ne);
  }, Q.converters.ResponseInit = Q.dictionaryConverter([
    {
      key: "status",
      converter: Q.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: Q.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: Q.converters.HeadersInit
    }
  ]), Ka = {
    isNetworkError: ee,
    makeNetworkError: te,
    makeResponse: J,
    makeAppropriateNetworkError: ce,
    filterResponse: ue,
    Response: F,
    cloneResponse: P,
    fromInnerResponse: Ce
  }, Ka;
}
var ja, Gu;
function tQ() {
  if (Gu) return ja;
  Gu = 1;
  const { kConnected: t, kSize: e } = gt();
  class r {
    constructor(i) {
      this.value = i;
    }
    deref() {
      return this.value[t] === 0 && this.value[e] === 0 ? void 0 : this.value;
    }
  }
  class n {
    constructor(i) {
      this.finalizer = i;
    }
    register(i, o) {
      i.on && i.on("disconnect", () => {
        i[t] === 0 && i[e] === 0 && this.finalizer(o);
      });
    }
    unregister(i) {
    }
  }
  return ja = function() {
    return process.env.NODE_V8_COVERAGE && process.version.startsWith("v18") ? (process._rawDebug("Using compatibility WeakRef and FinalizationRegistry"), {
      WeakRef: r,
      FinalizationRegistry: n
    }) : { WeakRef, FinalizationRegistry };
  }, ja;
}
var eA, Yu;
function ti() {
  if (Yu) return eA;
  Yu = 1;
  const { extractBody: t, mixinBody: e, cloneBody: r, bodyUnusable: n } = Xs(), { Headers: s, fill: i, HeadersList: o, setHeadersGuard: a, getHeadersGuard: A, setHeadersList: c, getHeadersList: l } = Xn(), { FinalizationRegistry: d } = tQ()(), u = Xe(), m = _t, {
    isValidHTTPToken: h,
    sameOrigin: f,
    environmentSettingsObject: p
  } = mr(), {
    forbiddenMethodsSet: y,
    corsSafeListedMethodsSet: w,
    referrerPolicy: R,
    requestRedirect: D,
    requestMode: L,
    requestCredentials: C,
    requestCache: I,
    requestDuplex: x
  } = ji(), { kEnumerableProperty: g, normalizedMethodRecordsBase: B, normalizedMethodRecords: Q } = u, { kHeaders: E, kSignal: b, kState: N, kDispatcher: S } = xn(), { webidl: M } = zt(), { URLSerializer: k } = or(), { kConstruct: F } = gt(), P = lt, { getMaxListeners: J, setMaxListeners: te, getEventListeners: ee, defaultMaxListeners: de } = Vs, ue = /* @__PURE__ */ Symbol("abortController"), ce = new d(({ signal: z, abort: $ }) => {
    z.removeEventListener("abort", $);
  }), fe = /* @__PURE__ */ new WeakMap();
  function Ce(z) {
    return $;
    function $() {
      const Ae = z.deref();
      if (Ae !== void 0) {
        ce.unregister($), this.removeEventListener("abort", $), Ae.abort(this.reason);
        const pe = fe.get(Ae.signal);
        if (pe !== void 0) {
          if (pe.size !== 0) {
            for (const me of pe) {
              const xe = me.deref();
              xe !== void 0 && xe.abort(this.reason);
            }
            pe.clear();
          }
          fe.delete(Ae.signal);
        }
      }
    }
  }
  let Z = !1;
  class _ {
    // https://fetch.spec.whatwg.org/#dom-request
    constructor($, Ae = {}) {
      if (M.util.markAsUncloneable(this), $ === F)
        return;
      const pe = "Request constructor";
      M.argumentLengthCheck(arguments, 1, pe), $ = M.converters.RequestInfo($, pe, "input"), Ae = M.converters.RequestInit(Ae, pe, "init");
      let me = null, xe = null;
      const _e = p.settingsObject.baseUrl;
      let ke = null;
      if (typeof $ == "string") {
        this[S] = Ae.dispatcher;
        let X;
        try {
          X = new URL($, _e);
        } catch (he) {
          throw new TypeError("Failed to parse URL from " + $, { cause: he });
        }
        if (X.username || X.password)
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + $
          );
        me = ne({ urlList: [X] }), xe = "cors";
      } else
        this[S] = Ae.dispatcher || $[S], P($ instanceof _), me = $[N], ke = $[b];
      const We = p.settingsObject.origin;
      let ve = "client";
      if (me.window?.constructor?.name === "EnvironmentSettingsObject" && f(me.window, We) && (ve = me.window), Ae.window != null)
        throw new TypeError(`'window' option '${ve}' must be null`);
      "window" in Ae && (ve = "no-window"), me = ne({
        // URL requests URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method requests method.
        method: me.method,
        // header list A copy of requests header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: me.headersList,
        // unsafe-request flag Set.
        unsafeRequest: me.unsafeRequest,
        // client Thiss relevant settings object.
        client: p.settingsObject,
        // window window.
        window: ve,
        // priority requests priority.
        priority: me.priority,
        // origin requests origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: me.origin,
        // referrer requests referrer.
        referrer: me.referrer,
        // referrer policy requests referrer policy.
        referrerPolicy: me.referrerPolicy,
        // mode requests mode.
        mode: me.mode,
        // credentials mode requests credentials mode.
        credentials: me.credentials,
        // cache mode requests cache mode.
        cache: me.cache,
        // redirect mode requests redirect mode.
        redirect: me.redirect,
        // integrity metadata requests integrity metadata.
        integrity: me.integrity,
        // keepalive requests keepalive.
        keepalive: me.keepalive,
        // reload-navigation flag requests reload-navigation flag.
        reloadNavigation: me.reloadNavigation,
        // history-navigation flag requests history-navigation flag.
        historyNavigation: me.historyNavigation,
        // URL list A clone of requests URL list.
        urlList: [...me.urlList]
      });
      const He = Object.keys(Ae).length !== 0;
      if (He && (me.mode === "navigate" && (me.mode = "same-origin"), me.reloadNavigation = !1, me.historyNavigation = !1, me.origin = "client", me.referrer = "client", me.referrerPolicy = "", me.url = me.urlList[me.urlList.length - 1], me.urlList = [me.url]), Ae.referrer !== void 0) {
        const X = Ae.referrer;
        if (X === "")
          me.referrer = "no-referrer";
        else {
          let he;
          try {
            he = new URL(X, _e);
          } catch (Ee) {
            throw new TypeError(`Referrer "${X}" is not a valid URL.`, { cause: Ee });
          }
          he.protocol === "about:" && he.hostname === "client" || We && !f(he, p.settingsObject.baseUrl) ? me.referrer = "client" : me.referrer = he;
        }
      }
      Ae.referrerPolicy !== void 0 && (me.referrerPolicy = Ae.referrerPolicy);
      let Re;
      if (Ae.mode !== void 0 ? Re = Ae.mode : Re = xe, Re === "navigate")
        throw M.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      if (Re != null && (me.mode = Re), Ae.credentials !== void 0 && (me.credentials = Ae.credentials), Ae.cache !== void 0 && (me.cache = Ae.cache), me.cache === "only-if-cached" && me.mode !== "same-origin")
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      if (Ae.redirect !== void 0 && (me.redirect = Ae.redirect), Ae.integrity != null && (me.integrity = String(Ae.integrity)), Ae.keepalive !== void 0 && (me.keepalive = !!Ae.keepalive), Ae.method !== void 0) {
        let X = Ae.method;
        const he = Q[X];
        if (he !== void 0)
          me.method = he;
        else {
          if (!h(X))
            throw new TypeError(`'${X}' is not a valid HTTP method.`);
          const Ee = X.toUpperCase();
          if (y.has(Ee))
            throw new TypeError(`'${X}' HTTP method is unsupported.`);
          X = B[Ee] ?? X, me.method = X;
        }
        !Z && me.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
          code: "UNDICI-FETCH-patch"
        }), Z = !0);
      }
      Ae.signal !== void 0 && (ke = Ae.signal), this[N] = me;
      const ut = new AbortController();
      if (this[b] = ut.signal, ke != null) {
        if (!ke || typeof ke.aborted != "boolean" || typeof ke.addEventListener != "function")
          throw new TypeError(
            "Failed to construct 'Request': member signal is not of type AbortSignal."
          );
        if (ke.aborted)
          ut.abort(ke.reason);
        else {
          this[ue] = ut;
          const X = new WeakRef(ut), he = Ce(X);
          try {
            (typeof J == "function" && J(ke) === de || ee(ke, "abort").length >= de) && te(1500, ke);
          } catch {
          }
          u.addAbortListener(ke, he), ce.register(ut, { signal: ke, abort: he }, he);
        }
      }
      if (this[E] = new s(F), c(this[E], me.headersList), a(this[E], "request"), Re === "no-cors") {
        if (!w.has(me.method))
          throw new TypeError(
            `'${me.method} is unsupported in no-cors mode.`
          );
        a(this[E], "request-no-cors");
      }
      if (He) {
        const X = l(this[E]), he = Ae.headers !== void 0 ? Ae.headers : new o(X);
        if (X.clear(), he instanceof o) {
          for (const { name: Ee, value: be } of he.rawValues())
            X.append(Ee, be, !1);
          X.cookies = he.cookies;
        } else
          i(this[E], he);
      }
      const At = $ instanceof _ ? $[N].body : null;
      if ((Ae.body != null || At != null) && (me.method === "GET" || me.method === "HEAD"))
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      let rt = null;
      if (Ae.body != null) {
        const [X, he] = t(
          Ae.body,
          me.keepalive
        );
        rt = X, he && !l(this[E]).contains("content-type", !0) && this[E].append("content-type", he);
      }
      const re = rt ?? At;
      if (re != null && re.source == null) {
        if (rt != null && Ae.duplex == null)
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        if (me.mode !== "same-origin" && me.mode !== "cors")
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        me.useCORSPreflightFlag = !0;
      }
      let T = re;
      if (rt == null && At != null) {
        if (n($))
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        const X = new TransformStream();
        At.stream.pipeThrough(X), T = {
          source: At.source,
          length: At.length,
          stream: X.readable
        };
      }
      this[N].body = T;
    }
    // Returns requests HTTP method, which is "GET" by default.
    get method() {
      return M.brandCheck(this, _), this[N].method;
    }
    // Returns the URL of request as a string.
    get url() {
      return M.brandCheck(this, _), k(this[N].url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      return M.brandCheck(this, _), this[E];
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      return M.brandCheck(this, _), this[N].destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the globals default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      return M.brandCheck(this, _), this[N].referrer === "no-referrer" ? "" : this[N].referrer === "client" ? "about:client" : this[N].referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the requests
    // referrer.
    get referrerPolicy() {
      return M.brandCheck(this, _), this[N].referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      return M.brandCheck(this, _), this[N].mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      return this[N].credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browsers cache when fetching.
    get cache() {
      return M.brandCheck(this, _), this[N].cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      return M.brandCheck(this, _), this[N].redirect;
    }
    // Returns requests subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      return M.brandCheck(this, _), this[N].integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      return M.brandCheck(this, _), this[N].keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      return M.brandCheck(this, _), this[N].reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-forward navigation).
    get isHistoryNavigation() {
      return M.brandCheck(this, _), this[N].historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      return M.brandCheck(this, _), this[b];
    }
    get body() {
      return M.brandCheck(this, _), this[N].body ? this[N].body.stream : null;
    }
    get bodyUsed() {
      return M.brandCheck(this, _), !!this[N].body && u.isDisturbed(this[N].body.stream);
    }
    get duplex() {
      return M.brandCheck(this, _), "half";
    }
    // Returns a clone of request.
    clone() {
      if (M.brandCheck(this, _), n(this))
        throw new TypeError("unusable");
      const $ = H(this[N]), Ae = new AbortController();
      if (this.signal.aborted)
        Ae.abort(this.signal.reason);
      else {
        let pe = fe.get(this.signal);
        pe === void 0 && (pe = /* @__PURE__ */ new Set(), fe.set(this.signal, pe));
        const me = new WeakRef(Ae);
        pe.add(me), u.addAbortListener(
          Ae.signal,
          Ce(me)
        );
      }
      return W($, Ae.signal, A(this[E]));
    }
    [m.inspect.custom]($, Ae) {
      Ae.depth === null && (Ae.depth = 2), Ae.colors ??= !0;
      const pe = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${m.formatWithOptions(Ae, pe)}`;
    }
  }
  e(_);
  function ne(z) {
    return {
      method: z.method ?? "GET",
      localURLsOnly: z.localURLsOnly ?? !1,
      unsafeRequest: z.unsafeRequest ?? !1,
      body: z.body ?? null,
      client: z.client ?? null,
      reservedClient: z.reservedClient ?? null,
      replacesClientId: z.replacesClientId ?? "",
      window: z.window ?? "client",
      keepalive: z.keepalive ?? !1,
      serviceWorkers: z.serviceWorkers ?? "all",
      initiator: z.initiator ?? "",
      destination: z.destination ?? "",
      priority: z.priority ?? null,
      origin: z.origin ?? "client",
      policyContainer: z.policyContainer ?? "client",
      referrer: z.referrer ?? "client",
      referrerPolicy: z.referrerPolicy ?? "",
      mode: z.mode ?? "no-cors",
      useCORSPreflightFlag: z.useCORSPreflightFlag ?? !1,
      credentials: z.credentials ?? "same-origin",
      useCredentials: z.useCredentials ?? !1,
      cache: z.cache ?? "default",
      redirect: z.redirect ?? "follow",
      integrity: z.integrity ?? "",
      cryptoGraphicsNonceMetadata: z.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: z.parserMetadata ?? "",
      reloadNavigation: z.reloadNavigation ?? !1,
      historyNavigation: z.historyNavigation ?? !1,
      userActivation: z.userActivation ?? !1,
      taintedOrigin: z.taintedOrigin ?? !1,
      redirectCount: z.redirectCount ?? 0,
      responseTainting: z.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: z.preventNoCacheCacheControlHeaderModification ?? !1,
      done: z.done ?? !1,
      timingAllowFailed: z.timingAllowFailed ?? !1,
      urlList: z.urlList,
      url: z.urlList[0],
      headersList: z.headersList ? new o(z.headersList) : new o()
    };
  }
  function H(z) {
    const $ = ne({ ...z, body: null });
    return z.body != null && ($.body = r($, z.body)), $;
  }
  function W(z, $, Ae) {
    const pe = new _(F);
    return pe[N] = z, pe[b] = $, pe[E] = new s(F), c(pe[E], z.headersList), a(pe[E], Ae), pe;
  }
  return Object.defineProperties(_.prototype, {
    method: g,
    url: g,
    headers: g,
    redirect: g,
    clone: g,
    signal: g,
    duplex: g,
    destination: g,
    body: g,
    bodyUsed: g,
    isHistoryNavigation: g,
    isReloadNavigation: g,
    keepalive: g,
    integrity: g,
    cache: g,
    credentials: g,
    attribute: g,
    referrerPolicy: g,
    referrer: g,
    mode: g,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: !0
    }
  }), M.converters.Request = M.interfaceConverter(
    _
  ), M.converters.RequestInfo = function(z, $, Ae) {
    return typeof z == "string" ? M.converters.USVString(z, $, Ae) : z instanceof _ ? M.converters.Request(z, $, Ae) : M.converters.USVString(z, $, Ae);
  }, M.converters.AbortSignal = M.interfaceConverter(
    AbortSignal
  ), M.converters.RequestInit = M.dictionaryConverter([
    {
      key: "method",
      converter: M.converters.ByteString
    },
    {
      key: "headers",
      converter: M.converters.HeadersInit
    },
    {
      key: "body",
      converter: M.nullableConverter(
        M.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: M.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: M.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: R
    },
    {
      key: "mode",
      converter: M.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: L
    },
    {
      key: "credentials",
      converter: M.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: C
    },
    {
      key: "cache",
      converter: M.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: I
    },
    {
      key: "redirect",
      converter: M.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: D
    },
    {
      key: "integrity",
      converter: M.converters.DOMString
    },
    {
      key: "keepalive",
      converter: M.converters.boolean
    },
    {
      key: "signal",
      converter: M.nullableConverter(
        (z) => M.converters.AbortSignal(
          z,
          "RequestInit",
          "signal",
          { strict: !1 }
        )
      )
    },
    {
      key: "window",
      converter: M.converters.any
    },
    {
      key: "duplex",
      converter: M.converters.DOMString,
      allowedValues: x
    },
    {
      key: "dispatcher",
      // undici specific option
      converter: M.converters.any
    }
  ]), eA = { Request: _, makeRequest: ne, fromInnerRequest: W, cloneRequest: H }, eA;
}
var tA, Ju;
function so() {
  if (Ju) return tA;
  Ju = 1;
  const {
    makeNetworkError: t,
    makeAppropriateNetworkError: e,
    filterResponse: r,
    makeResponse: n,
    fromInnerResponse: s
  } = no(), { HeadersList: i } = Xn(), { Request: o, cloneRequest: a } = ti(), A = Hs, {
    bytesMatch: c,
    makePolicyContainer: l,
    clonePolicyContainer: d,
    requestBadPort: u,
    TAOCheck: m,
    appendRequestOriginHeader: h,
    responseLocationURL: f,
    requestCurrentURL: p,
    setRequestReferrerPolicyOnRedirect: y,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: w,
    createOpaqueTimingInfo: R,
    appendFetchMetadata: D,
    corsCheck: L,
    crossOriginResourcePolicyCheck: C,
    determineRequestsReferrer: I,
    coarsenedSharedCurrentTime: x,
    createDeferredPromise: g,
    isBlobLike: B,
    sameOrigin: Q,
    isCancelled: E,
    isAborted: b,
    isErrorLike: N,
    fullyReadBody: S,
    readableStreamClose: M,
    isomorphicEncode: k,
    urlIsLocal: F,
    urlIsHttpHttpsScheme: P,
    urlHasHttpsScheme: J,
    clampAndCoarsenConnectionTimingInfo: te,
    simpleRangeHeaderValue: ee,
    buildContentRange: de,
    createInflate: ue,
    extractMimeType: ce
  } = mr(), { kState: fe, kDispatcher: Ce } = xn(), Z = lt, { safelyExtractBody: _, extractBody: ne } = Xs(), {
    redirectStatusSet: H,
    nullBodyStatus: W,
    safeMethodsSet: z,
    requestBodyHeader: $,
    subresourceSet: Ae
  } = ji(), pe = Vs, { Readable: me, pipeline: xe, finished: _e } = dr, { addAbortListener: ke, isErrored: We, isReadable: ve, bufferToLowerCasedHeaderName: He } = Xe(), { dataURLProcessor: Re, serializeAMimeType: ut, minimizeSupportedMimeType: At } = or(), { getGlobalDispatcher: rt } = Nl(), { webidl: re } = zt(), { STATUS_CODES: T } = Bn, X = ["GET", "HEAD"], he = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici";
  let Ee;
  class be extends pe {
    constructor(G) {
      super(), this.dispatcher = G, this.connection = null, this.dump = !1, this.state = "ongoing";
    }
    terminate(G) {
      this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(G), this.emit("terminated", G));
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(G) {
      this.state === "ongoing" && (this.state = "aborted", G || (G = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = G, this.connection?.destroy(G), this.emit("terminated", G));
    }
  }
  function Le(v) {
    Bt(v, "fetch");
  }
  function st(v, G = void 0) {
    re.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let q = g(), Y;
    try {
      Y = new o(v, G);
    } catch (ht) {
      return q.reject(ht), q.promise;
    }
    const oe = Y[fe];
    if (Y.signal.aborted)
      return Se(q, oe, null, Y.signal.reason), q.promise;
    oe.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (oe.serviceWorkers = "none");
    let ge = null, ze = !1, je = null;
    return ke(
      Y.signal,
      () => {
        ze = !0, Z(je != null), je.abort(Y.signal.reason);
        const ht = ge?.deref();
        Se(q, oe, ht, Y.signal.reason);
      }
    ), je = O({
      request: oe,
      processResponseEndOfBody: Le,
      processResponse: (ht) => {
        if (!ze) {
          if (ht.aborted) {
            Se(q, oe, ge, je.serializedAbortReason);
            return;
          }
          if (ht.type === "error") {
            q.reject(new TypeError("fetch failed", { cause: ht.error }));
            return;
          }
          ge = new WeakRef(s(ht, "immutable")), q.resolve(ge.deref()), q = null;
        }
      },
      dispatcher: Y[Ce]
      // undici
    }), q.promise;
  }
  function Bt(v, G = "other") {
    if (v.type === "error" && v.aborted || !v.urlList?.length)
      return;
    const q = v.urlList[0];
    let Y = v.timingInfo, oe = v.cacheState;
    P(q) && Y !== null && (v.timingAllowPassed || (Y = R({
      startTime: Y.startTime
    }), oe = ""), Y.endTime = x(), v.timingInfo = Y, wt(
      Y,
      q.href,
      G,
      globalThis,
      oe
    ));
  }
  const wt = performance.markResourceTiming;
  function Se(v, G, q, Y) {
    if (v && v.reject(Y), G.body != null && ve(G.body?.stream) && G.body.stream.cancel(Y).catch((K) => {
      if (K.code !== "ERR_INVALID_STATE")
        throw K;
    }), q == null)
      return;
    const oe = q[fe];
    oe.body != null && ve(oe.body?.stream) && oe.body.stream.cancel(Y).catch((K) => {
      if (K.code !== "ERR_INVALID_STATE")
        throw K;
    });
  }
  function O({
    request: v,
    processRequestBodyChunkLength: G,
    processRequestEndOfBody: q,
    processResponse: Y,
    processResponseEndOfBody: oe,
    processResponseConsumeBody: K,
    useParallelQueue: ge = !1,
    dispatcher: ze = rt()
    // undici
  }) {
    Z(ze);
    let je = null, Ze = !1;
    v.client != null && (je = v.client.globalObject, Ze = v.client.crossOriginIsolatedCapability);
    const ht = x(Ze), Qr = R({
      startTime: ht
    }), qe = {
      controller: new be(ze),
      request: v,
      timingInfo: Qr,
      processRequestBodyChunkLength: G,
      processRequestEndOfBody: q,
      processResponse: Y,
      processResponseConsumeBody: K,
      processResponseEndOfBody: oe,
      taskDestination: je,
      crossOriginIsolatedCapability: Ze
    };
    return Z(!v.body || v.body.stream), v.window === "client" && (v.window = v.client?.globalObject?.constructor?.name === "Window" ? v.client : "no-window"), v.origin === "client" && (v.origin = v.client.origin), v.policyContainer === "client" && (v.client != null ? v.policyContainer = d(
      v.client.policyContainer
    ) : v.policyContainer = l()), v.headersList.contains("accept", !0) || v.headersList.append("accept", "*/*", !0), v.headersList.contains("accept-language", !0) || v.headersList.append("accept-language", "*", !0), v.priority, Ae.has(v.destination), se(qe).catch((bt) => {
      qe.controller.terminate(bt);
    }), qe.controller;
  }
  async function se(v, G = !1) {
    const q = v.request;
    let Y = null;
    if (q.localURLsOnly && !F(p(q)) && (Y = t("local URLs only")), w(q), u(q) === "blocked" && (Y = t("bad port")), q.referrerPolicy === "" && (q.referrerPolicy = q.policyContainer.referrerPolicy), q.referrer !== "no-referrer" && (q.referrer = I(q)), Y === null && (Y = await (async () => {
      const K = p(q);
      return (
        // - requests current URLs origin is same origin with requests origin,
        //   and requests response tainting is "basic"
        Q(K, q.url) && q.responseTainting === "basic" || // requests current URLs scheme is "data"
        K.protocol === "data:" || // - requests mode is "navigate" or "websocket"
        q.mode === "navigate" || q.mode === "websocket" ? (q.responseTainting = "basic", await j(v)) : q.mode === "same-origin" ? t('request mode cannot be "same-origin"') : q.mode === "no-cors" ? q.redirect !== "follow" ? t(
          'redirect mode cannot be "follow" for "no-cors" request'
        ) : (q.responseTainting = "opaque", await j(v)) : P(p(q)) ? (q.responseTainting = "cors", await Pe(v)) : t("URL scheme must be a HTTP(S) scheme")
      );
    })()), G)
      return Y;
    Y.status !== 0 && !Y.internalResponse && (q.responseTainting, q.responseTainting === "basic" ? Y = r(Y, "basic") : q.responseTainting === "cors" ? Y = r(Y, "cors") : q.responseTainting === "opaque" ? Y = r(Y, "opaque") : Z(!1));
    let oe = Y.status === 0 ? Y : Y.internalResponse;
    if (oe.urlList.length === 0 && oe.urlList.push(...q.urlList), q.timingAllowFailed || (Y.timingAllowPassed = !0), Y.type === "opaque" && oe.status === 206 && oe.rangeRequested && !q.headers.contains("range", !0) && (Y = oe = t()), Y.status !== 0 && (q.method === "HEAD" || q.method === "CONNECT" || W.includes(oe.status)) && (oe.body = null, v.controller.dump = !0), q.integrity) {
      const K = (ze) => Be(v, t(ze));
      if (q.responseTainting === "opaque" || Y.body == null) {
        K(Y.error);
        return;
      }
      const ge = (ze) => {
        if (!c(ze, q.integrity)) {
          K("integrity mismatch");
          return;
        }
        Y.body = _(ze)[0], Be(v, Y);
      };
      await S(Y.body, ge, K);
    } else
      Be(v, Y);
  }
  function j(v) {
    if (E(v) && v.request.redirectCount === 0)
      return Promise.resolve(e(v));
    const { request: G } = v, { protocol: q } = p(G);
    switch (q) {
      case "about:":
        return Promise.resolve(t("about scheme is not supported"));
      case "blob:": {
        Ee || (Ee = ur.resolveObjectURL);
        const Y = p(G);
        if (Y.search.length !== 0)
          return Promise.resolve(t("NetworkError when attempting to fetch resource."));
        const oe = Ee(Y.toString());
        if (G.method !== "GET" || !B(oe))
          return Promise.resolve(t("invalid method"));
        const K = n(), ge = oe.size, ze = k(`${ge}`), je = oe.type;
        if (G.headersList.contains("range", !0)) {
          K.rangeRequested = !0;
          const Ze = G.headersList.get("range", !0), ht = ee(Ze, !0);
          if (ht === "failure")
            return Promise.resolve(t("failed to fetch the data URL"));
          let { rangeStartValue: Qr, rangeEndValue: qe } = ht;
          if (Qr === null)
            Qr = ge - qe, qe = Qr + qe - 1;
          else {
            if (Qr >= ge)
              return Promise.resolve(t("Range start is greater than the blob's size."));
            (qe === null || qe >= ge) && (qe = ge - 1);
          }
          const bt = oe.slice(Qr, qe, je), Ar = ne(bt);
          K.body = Ar[0];
          const ft = k(`${bt.size}`), Fr = de(Qr, qe, ge);
          K.status = 206, K.statusText = "Partial Content", K.headersList.set("content-length", ft, !0), K.headersList.set("content-type", je, !0), K.headersList.set("content-range", Fr, !0);
        } else {
          const Ze = ne(oe);
          K.statusText = "OK", K.body = Ze[0], K.headersList.set("content-length", ze, !0), K.headersList.set("content-type", je, !0);
        }
        return Promise.resolve(K);
      }
      case "data:": {
        const Y = p(G), oe = Re(Y);
        if (oe === "failure")
          return Promise.resolve(t("failed to fetch the data URL"));
        const K = ut(oe.mimeType);
        return Promise.resolve(n({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: K }]
          ],
          body: _(oe.body)[0]
        }));
      }
      case "file:":
        return Promise.resolve(t("not implemented... yet..."));
      case "http:":
      case "https:":
        return Pe(v).catch((Y) => t(Y));
      default:
        return Promise.resolve(t("unknown scheme"));
    }
  }
  function ie(v, G) {
    v.request.done = !0, v.processResponseDone != null && queueMicrotask(() => v.processResponseDone(G));
  }
  function Be(v, G) {
    let q = v.timingInfo;
    const Y = () => {
      const K = Date.now();
      v.request.destination === "document" && (v.controller.fullTimingInfo = q), v.controller.reportTimingSteps = () => {
        if (v.request.url.protocol !== "https:")
          return;
        q.endTime = K;
        let ze = G.cacheState;
        const je = G.bodyInfo;
        G.timingAllowPassed || (q = R(q), ze = "");
        let Ze = 0;
        if (v.request.mode !== "navigator" || !G.hasCrossOriginRedirects) {
          Ze = G.status;
          const ht = ce(G.headersList);
          ht !== "failure" && (je.contentType = At(ht));
        }
        v.request.initiatorType != null && wt(q, v.request.url.href, v.request.initiatorType, globalThis, ze, je, Ze);
      };
      const ge = () => {
        v.request.done = !0, v.processResponseEndOfBody != null && queueMicrotask(() => v.processResponseEndOfBody(G)), v.request.initiatorType != null && v.controller.reportTimingSteps();
      };
      queueMicrotask(() => ge());
    };
    v.processResponse != null && queueMicrotask(() => {
      v.processResponse(G), v.processResponse = null;
    });
    const oe = G.type === "error" ? G : G.internalResponse ?? G;
    oe.body == null ? Y() : _e(oe.body.stream, () => {
      Y();
    });
  }
  async function Pe(v) {
    const G = v.request;
    let q = null, Y = null;
    const oe = v.timingInfo;
    if (G.serviceWorkers, q === null) {
      if (G.redirect === "follow" && (G.serviceWorkers = "none"), Y = q = await U(v), G.responseTainting === "cors" && L(G, q) === "failure")
        return t("cors failure");
      m(G, q) === "failure" && (G.timingAllowFailed = !0);
    }
    return (G.responseTainting === "opaque" || q.type === "opaque") && C(
      G.origin,
      G.client,
      G.destination,
      Y
    ) === "blocked" ? t("blocked") : (H.has(Y.status) && (G.redirect !== "manual" && v.controller.connection.destroy(void 0, !1), G.redirect === "error" ? q = t("unexpected redirect") : G.redirect === "manual" ? q = Y : G.redirect === "follow" ? q = await Ye(v, q) : Z(!1)), q.timingInfo = oe, q);
  }
  function Ye(v, G) {
    const q = v.request, Y = G.internalResponse ? G.internalResponse : G;
    let oe;
    try {
      if (oe = f(
        Y,
        p(q).hash
      ), oe == null)
        return G;
    } catch (ge) {
      return Promise.resolve(t(ge));
    }
    if (!P(oe))
      return Promise.resolve(t("URL scheme must be a HTTP(S) scheme"));
    if (q.redirectCount === 20)
      return Promise.resolve(t("redirect count exceeded"));
    if (q.redirectCount += 1, q.mode === "cors" && (oe.username || oe.password) && !Q(q, oe))
      return Promise.resolve(t('cross origin not allowed for request mode "cors"'));
    if (q.responseTainting === "cors" && (oe.username || oe.password))
      return Promise.resolve(t(
        'URL cannot contain credentials for request mode "cors"'
      ));
    if (Y.status !== 303 && q.body != null && q.body.source == null)
      return Promise.resolve(t());
    if ([301, 302].includes(Y.status) && q.method === "POST" || Y.status === 303 && !X.includes(q.method)) {
      q.method = "GET", q.body = null;
      for (const ge of $)
        q.headersList.delete(ge);
    }
    Q(p(q), oe) || (q.headersList.delete("authorization", !0), q.headersList.delete("proxy-authorization", !0), q.headersList.delete("cookie", !0), q.headersList.delete("host", !0)), q.body != null && (Z(q.body.source != null), q.body = _(q.body.source)[0]);
    const K = v.timingInfo;
    return K.redirectEndTime = K.postRedirectStartTime = x(v.crossOriginIsolatedCapability), K.redirectStartTime === 0 && (K.redirectStartTime = K.startTime), q.urlList.push(oe), y(q, Y), se(v, !0);
  }
  async function U(v, G = !1, q = !1) {
    const Y = v.request;
    let oe = null, K = null, ge = null;
    Y.window === "no-window" && Y.redirect === "error" ? (oe = v, K = Y) : (K = a(Y), oe = { ...v }, oe.request = K);
    const ze = Y.credentials === "include" || Y.credentials === "same-origin" && Y.responseTainting === "basic", je = K.body ? K.body.length : null;
    let Ze = null;
    if (K.body == null && ["POST", "PUT"].includes(K.method) && (Ze = "0"), je != null && (Ze = k(`${je}`)), Ze != null && K.headersList.append("content-length", Ze, !0), je != null && K.keepalive, K.referrer instanceof URL && K.headersList.append("referer", k(K.referrer.href), !0), h(K), D(K), K.headersList.contains("user-agent", !0) || K.headersList.append("user-agent", he), K.cache === "default" && (K.headersList.contains("if-modified-since", !0) || K.headersList.contains("if-none-match", !0) || K.headersList.contains("if-unmodified-since", !0) || K.headersList.contains("if-match", !0) || K.headersList.contains("if-range", !0)) && (K.cache = "no-store"), K.cache === "no-cache" && !K.preventNoCacheCacheControlHeaderModification && !K.headersList.contains("cache-control", !0) && K.headersList.append("cache-control", "max-age=0", !0), (K.cache === "no-store" || K.cache === "reload") && (K.headersList.contains("pragma", !0) || K.headersList.append("pragma", "no-cache", !0), K.headersList.contains("cache-control", !0) || K.headersList.append("cache-control", "no-cache", !0)), K.headersList.contains("range", !0) && K.headersList.append("accept-encoding", "identity", !0), K.headersList.contains("accept-encoding", !0) || (J(p(K)) ? K.headersList.append("accept-encoding", "br, gzip, deflate", !0) : K.headersList.append("accept-encoding", "gzip, deflate", !0)), K.headersList.delete("host", !0), K.cache = "no-store", K.cache !== "no-store" && K.cache, ge == null) {
      if (K.cache === "only-if-cached")
        return t("only if cached");
      const ht = await V(
        oe,
        ze,
        q
      );
      !z.has(K.method) && ht.status >= 200 && ht.status <= 399, ge == null && (ge = ht);
    }
    if (ge.urlList = [...K.urlList], K.headersList.contains("range", !0) && (ge.rangeRequested = !0), ge.requestIncludesCredentials = ze, ge.status === 407)
      return Y.window === "no-window" ? t() : E(v) ? e(v) : t("proxy authentication required");
    if (
      // responses status is 421
      ge.status === 421 && // isNewConnectionFetch is false
      !q && // requests body is null, or requests body is non-null and requests bodys source is non-null
      (Y.body == null || Y.body.source != null)
    ) {
      if (E(v))
        return e(v);
      v.controller.connection.destroy(), ge = await U(
        v,
        G,
        !0
      );
    }
    return ge;
  }
  async function V(v, G = !1, q = !1) {
    Z(!v.controller.connection || v.controller.connection.destroyed), v.controller.connection = {
      abort: null,
      destroyed: !1,
      destroy(qe, bt = !0) {
        this.destroyed || (this.destroyed = !0, bt && this.abort?.(qe ?? new DOMException("The operation was aborted.", "AbortError")));
      }
    };
    const Y = v.request;
    let oe = null;
    const K = v.timingInfo;
    Y.cache = "no-store", Y.mode;
    let ge = null;
    if (Y.body == null && v.processRequestEndOfBody)
      queueMicrotask(() => v.processRequestEndOfBody());
    else if (Y.body != null) {
      const qe = async function* (ft) {
        E(v) || (yield ft, v.processRequestBodyChunkLength?.(ft.byteLength));
      }, bt = () => {
        E(v) || v.processRequestEndOfBody && v.processRequestEndOfBody();
      }, Ar = (ft) => {
        E(v) || (ft.name === "AbortError" ? v.controller.abort() : v.controller.terminate(ft));
      };
      ge = (async function* () {
        try {
          for await (const ft of Y.body.stream)
            yield* qe(ft);
          bt();
        } catch (ft) {
          Ar(ft);
        }
      })();
    }
    try {
      const { body: qe, status: bt, statusText: Ar, headersList: ft, socket: Fr } = await Qr({ body: ge });
      if (Fr)
        oe = n({ status: bt, statusText: Ar, headersList: ft, socket: Fr });
      else {
        const It = qe[Symbol.asyncIterator]();
        v.controller.next = () => It.next(), oe = n({ status: bt, statusText: Ar, headersList: ft });
      }
    } catch (qe) {
      return qe.name === "AbortError" ? (v.controller.connection.destroy(), e(v, qe)) : t(qe);
    }
    const ze = async () => {
      await v.controller.resume();
    }, je = (qe) => {
      E(v) || v.controller.abort(qe);
    }, Ze = new ReadableStream(
      {
        async start(qe) {
          v.controller.controller = qe;
        },
        async pull(qe) {
          await ze();
        },
        async cancel(qe) {
          await je(qe);
        },
        type: "bytes"
      }
    );
    oe.body = { stream: Ze, source: null, length: null }, v.controller.onAborted = ht, v.controller.on("terminated", ht), v.controller.resume = async () => {
      for (; ; ) {
        let qe, bt;
        try {
          const { done: ft, value: Fr } = await v.controller.next();
          if (b(v))
            break;
          qe = ft ? void 0 : Fr;
        } catch (ft) {
          v.controller.ended && !K.encodedBodySize ? qe = void 0 : (qe = ft, bt = !0);
        }
        if (qe === void 0) {
          M(v.controller.controller), ie(v, oe);
          return;
        }
        if (K.decodedBodySize += qe?.byteLength ?? 0, bt) {
          v.controller.terminate(qe);
          return;
        }
        const Ar = new Uint8Array(qe);
        if (Ar.byteLength && v.controller.controller.enqueue(Ar), We(Ze)) {
          v.controller.terminate();
          return;
        }
        if (v.controller.controller.desiredSize <= 0)
          return;
      }
    };
    function ht(qe) {
      b(v) ? (oe.aborted = !0, ve(Ze) && v.controller.controller.error(
        v.controller.serializedAbortReason
      )) : ve(Ze) && v.controller.controller.error(new TypeError("terminated", {
        cause: N(qe) ? qe : void 0
      })), v.controller.connection.destroy();
    }
    return oe;
    function Qr({ body: qe }) {
      const bt = p(Y), Ar = v.controller.dispatcher;
      return new Promise((ft, Fr) => Ar.dispatch(
        {
          path: bt.pathname + bt.search,
          origin: bt.origin,
          method: Y.method,
          body: Ar.isMockActive ? Y.body && (Y.body.source || Y.body.stream) : qe,
          headers: Y.headersList.entries,
          maxRedirections: 0,
          upgrade: Y.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(It) {
            const { connection: jt } = v.controller;
            K.finalConnectionTimingInfo = te(void 0, K.postRedirectStartTime, v.crossOriginIsolatedCapability), jt.destroyed ? It(new DOMException("The operation was aborted.", "AbortError")) : (v.controller.on("terminated", It), this.abort = jt.abort = It), K.finalNetworkRequestStartTime = x(v.crossOriginIsolatedCapability);
          },
          onResponseStarted() {
            K.finalNetworkResponseStartTime = x(v.crossOriginIsolatedCapability);
          },
          onHeaders(It, jt, Ho, ui) {
            if (It < 200)
              return;
            let cn = "";
            const mi = new i();
            for (let Nr = 0; Nr < jt.length; Nr += 2)
              mi.append(He(jt[Nr]), jt[Nr + 1].toString("latin1"), !0);
            cn = mi.get("location", !0), this.body = new me({ read: Ho });
            const On = [], XI = cn && Y.redirect === "follow" && H.has(It);
            if (Y.method !== "HEAD" && Y.method !== "CONNECT" && !W.includes(It) && !XI) {
              const Nr = mi.get("content-encoding", !0), hi = Nr ? Nr.toLowerCase().split(",") : [], yd = 5;
              if (hi.length > yd)
                return Fr(new Error(`too many content-encodings in response: ${hi.length}, maximum allowed is ${yd}`)), !0;
              for (let Oo = hi.length - 1; Oo >= 0; --Oo) {
                const gi = hi[Oo].trim();
                if (gi === "x-gzip" || gi === "gzip")
                  On.push(A.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: A.constants.Z_SYNC_FLUSH,
                    finishFlush: A.constants.Z_SYNC_FLUSH
                  }));
                else if (gi === "deflate")
                  On.push(ue({
                    flush: A.constants.Z_SYNC_FLUSH,
                    finishFlush: A.constants.Z_SYNC_FLUSH
                  }));
                else if (gi === "br")
                  On.push(A.createBrotliDecompress({
                    flush: A.constants.BROTLI_OPERATION_FLUSH,
                    finishFlush: A.constants.BROTLI_OPERATION_FLUSH
                  }));
                else {
                  On.length = 0;
                  break;
                }
              }
            }
            const Id = this.onError.bind(this);
            return ft({
              status: It,
              statusText: ui,
              headersList: mi,
              body: On.length ? xe(this.body, ...On, (Nr) => {
                Nr && this.onError(Nr);
              }).on("error", Id) : this.body.on("error", Id)
            }), !0;
          },
          onData(It) {
            if (v.controller.dump)
              return;
            const jt = It;
            return K.encodedBodySize += jt.byteLength, this.body.push(jt);
          },
          onComplete() {
            this.abort && v.controller.off("terminated", this.abort), v.controller.onAborted && v.controller.off("terminated", v.controller.onAborted), v.controller.ended = !0, this.body.push(null);
          },
          onError(It) {
            this.abort && v.controller.off("terminated", this.abort), this.body?.destroy(It), v.controller.terminate(It), Fr(It);
          },
          onUpgrade(It, jt, Ho) {
            if (It !== 101)
              return;
            const ui = new i();
            for (let cn = 0; cn < jt.length; cn += 2)
              ui.append(He(jt[cn]), jt[cn + 1].toString("latin1"), !0);
            return ft({
              status: It,
              statusText: T[It],
              headersList: ui,
              socket: Ho
            }), !0;
          }
        }
      ));
    }
  }
  return tA = {
    fetch: st,
    Fetch: be,
    fetching: O,
    finalizeAndReportTiming: Bt
  }, tA;
}
var rA, Vu;
function gf() {
  return Vu || (Vu = 1, rA = {
    kState: /* @__PURE__ */ Symbol("FileReader state"),
    kResult: /* @__PURE__ */ Symbol("FileReader result"),
    kError: /* @__PURE__ */ Symbol("FileReader error"),
    kLastProgressEventFired: /* @__PURE__ */ Symbol("FileReader last progress event fired timestamp"),
    kEvents: /* @__PURE__ */ Symbol("FileReader events"),
    kAborted: /* @__PURE__ */ Symbol("FileReader aborted")
  }), rA;
}
var nA, _u;
function rQ() {
  if (_u) return nA;
  _u = 1;
  const { webidl: t } = zt(), e = /* @__PURE__ */ Symbol("ProgressEvent state");
  class r extends Event {
    constructor(s, i = {}) {
      s = t.converters.DOMString(s, "ProgressEvent constructor", "type"), i = t.converters.ProgressEventInit(i ?? {}), super(s, i), this[e] = {
        lengthComputable: i.lengthComputable,
        loaded: i.loaded,
        total: i.total
      };
    }
    get lengthComputable() {
      return t.brandCheck(this, r), this[e].lengthComputable;
    }
    get loaded() {
      return t.brandCheck(this, r), this[e].loaded;
    }
    get total() {
      return t.brandCheck(this, r), this[e].total;
    }
  }
  return t.converters.ProgressEventInit = t.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: t.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "loaded",
      converter: t.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "total",
      converter: t.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "bubbles",
      converter: t.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "cancelable",
      converter: t.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "composed",
      converter: t.converters.boolean,
      defaultValue: () => !1
    }
  ]), nA = {
    ProgressEvent: r
  }, nA;
}
var sA, Wu;
function nQ() {
  if (Wu) return sA;
  Wu = 1;
  function t(e) {
    if (!e)
      return "failure";
    switch (e.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  return sA = {
    getEncoding: t
  }, sA;
}
var iA, $u;
function sQ() {
  if ($u) return iA;
  $u = 1;
  const {
    kState: t,
    kError: e,
    kResult: r,
    kAborted: n,
    kLastProgressEventFired: s
  } = gf(), { ProgressEvent: i } = rQ(), { getEncoding: o } = nQ(), { serializeAMimeType: a, parseMIMEType: A } = or(), { types: c } = _t, { StringDecoder: l } = gy, { btoa: d } = ur, u = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  };
  function m(R, D, L, C) {
    if (R[t] === "loading")
      throw new DOMException("Invalid state", "InvalidStateError");
    R[t] = "loading", R[r] = null, R[e] = null;
    const x = D.stream().getReader(), g = [];
    let B = x.read(), Q = !0;
    (async () => {
      for (; !R[n]; )
        try {
          const { done: E, value: b } = await B;
          if (Q && !R[n] && queueMicrotask(() => {
            h("loadstart", R);
          }), Q = !1, !E && c.isUint8Array(b))
            g.push(b), (R[s] === void 0 || Date.now() - R[s] >= 50) && !R[n] && (R[s] = Date.now(), queueMicrotask(() => {
              h("progress", R);
            })), B = x.read();
          else if (E) {
            queueMicrotask(() => {
              R[t] = "done";
              try {
                const N = f(g, L, D.type, C);
                if (R[n])
                  return;
                R[r] = N, h("load", R);
              } catch (N) {
                R[e] = N, h("error", R);
              }
              R[t] !== "loading" && h("loadend", R);
            });
            break;
          }
        } catch (E) {
          if (R[n])
            return;
          queueMicrotask(() => {
            R[t] = "done", R[e] = E, h("error", R), R[t] !== "loading" && h("loadend", R);
          });
          break;
        }
    })();
  }
  function h(R, D) {
    const L = new i(R, {
      bubbles: !1,
      cancelable: !1
    });
    D.dispatchEvent(L);
  }
  function f(R, D, L, C) {
    switch (D) {
      case "DataURL": {
        let I = "data:";
        const x = A(L || "application/octet-stream");
        x !== "failure" && (I += a(x)), I += ";base64,";
        const g = new l("latin1");
        for (const B of R)
          I += d(g.write(B));
        return I += d(g.end()), I;
      }
      case "Text": {
        let I = "failure";
        if (C && (I = o(C)), I === "failure" && L) {
          const x = A(L);
          x !== "failure" && (I = o(x.parameters.get("charset")));
        }
        return I === "failure" && (I = "UTF-8"), p(R, I);
      }
      case "ArrayBuffer":
        return w(R).buffer;
      case "BinaryString": {
        let I = "";
        const x = new l("latin1");
        for (const g of R)
          I += x.write(g);
        return I += x.end(), I;
      }
    }
  }
  function p(R, D) {
    const L = w(R), C = y(L);
    let I = 0;
    C !== null && (D = C, I = C === "UTF-8" ? 3 : 2);
    const x = L.slice(I);
    return new TextDecoder(D).decode(x);
  }
  function y(R) {
    const [D, L, C] = R;
    return D === 239 && L === 187 && C === 191 ? "UTF-8" : D === 254 && L === 255 ? "UTF-16BE" : D === 255 && L === 254 ? "UTF-16LE" : null;
  }
  function w(R) {
    const D = R.reduce((C, I) => C + I.byteLength, 0);
    let L = 0;
    return R.reduce((C, I) => (C.set(I, L), L += I.byteLength, C), new Uint8Array(D));
  }
  return iA = {
    staticPropertyDescriptors: u,
    readOperation: m,
    fireAProgressEvent: h
  }, iA;
}
var oA, Xu;
function iQ() {
  if (Xu) return oA;
  Xu = 1;
  const {
    staticPropertyDescriptors: t,
    readOperation: e,
    fireAProgressEvent: r
  } = sQ(), {
    kState: n,
    kError: s,
    kResult: i,
    kEvents: o,
    kAborted: a
  } = gf(), { webidl: A } = zt(), { kEnumerableProperty: c } = Xe();
  class l extends EventTarget {
    constructor() {
      super(), this[n] = "empty", this[i] = null, this[s] = null, this[o] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
     * @param {import('buffer').Blob} blob
     */
    readAsArrayBuffer(u) {
      A.brandCheck(this, l), A.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer"), u = A.converters.Blob(u, { strict: !1 }), e(this, u, "ArrayBuffer");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsBinaryString
     * @param {import('buffer').Blob} blob
     */
    readAsBinaryString(u) {
      A.brandCheck(this, l), A.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString"), u = A.converters.Blob(u, { strict: !1 }), e(this, u, "BinaryString");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsDataText
     * @param {import('buffer').Blob} blob
     * @param {string?} encoding
     */
    readAsText(u, m = void 0) {
      A.brandCheck(this, l), A.argumentLengthCheck(arguments, 1, "FileReader.readAsText"), u = A.converters.Blob(u, { strict: !1 }), m !== void 0 && (m = A.converters.DOMString(m, "FileReader.readAsText", "encoding")), e(this, u, "Text", m);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
     * @param {import('buffer').Blob} blob
     */
    readAsDataURL(u) {
      A.brandCheck(this, l), A.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL"), u = A.converters.Blob(u, { strict: !1 }), e(this, u, "DataURL");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-abort
     */
    abort() {
      if (this[n] === "empty" || this[n] === "done") {
        this[i] = null;
        return;
      }
      this[n] === "loading" && (this[n] = "done", this[i] = null), this[a] = !0, r("abort", this), this[n] !== "loading" && r("loadend", this);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
     */
    get readyState() {
      switch (A.brandCheck(this, l), this[n]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-result
     */
    get result() {
      return A.brandCheck(this, l), this[i];
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-error
     */
    get error() {
      return A.brandCheck(this, l), this[s];
    }
    get onloadend() {
      return A.brandCheck(this, l), this[o].loadend;
    }
    set onloadend(u) {
      A.brandCheck(this, l), this[o].loadend && this.removeEventListener("loadend", this[o].loadend), typeof u == "function" ? (this[o].loadend = u, this.addEventListener("loadend", u)) : this[o].loadend = null;
    }
    get onerror() {
      return A.brandCheck(this, l), this[o].error;
    }
    set onerror(u) {
      A.brandCheck(this, l), this[o].error && this.removeEventListener("error", this[o].error), typeof u == "function" ? (this[o].error = u, this.addEventListener("error", u)) : this[o].error = null;
    }
    get onloadstart() {
      return A.brandCheck(this, l), this[o].loadstart;
    }
    set onloadstart(u) {
      A.brandCheck(this, l), this[o].loadstart && this.removeEventListener("loadstart", this[o].loadstart), typeof u == "function" ? (this[o].loadstart = u, this.addEventListener("loadstart", u)) : this[o].loadstart = null;
    }
    get onprogress() {
      return A.brandCheck(this, l), this[o].progress;
    }
    set onprogress(u) {
      A.brandCheck(this, l), this[o].progress && this.removeEventListener("progress", this[o].progress), typeof u == "function" ? (this[o].progress = u, this.addEventListener("progress", u)) : this[o].progress = null;
    }
    get onload() {
      return A.brandCheck(this, l), this[o].load;
    }
    set onload(u) {
      A.brandCheck(this, l), this[o].load && this.removeEventListener("load", this[o].load), typeof u == "function" ? (this[o].load = u, this.addEventListener("load", u)) : this[o].load = null;
    }
    get onabort() {
      return A.brandCheck(this, l), this[o].abort;
    }
    set onabort(u) {
      A.brandCheck(this, l), this[o].abort && this.removeEventListener("abort", this[o].abort), typeof u == "function" ? (this[o].abort = u, this.addEventListener("abort", u)) : this[o].abort = null;
    }
  }
  return l.EMPTY = l.prototype.EMPTY = 0, l.LOADING = l.prototype.LOADING = 1, l.DONE = l.prototype.DONE = 2, Object.defineProperties(l.prototype, {
    EMPTY: t,
    LOADING: t,
    DONE: t,
    readAsArrayBuffer: c,
    readAsBinaryString: c,
    readAsText: c,
    readAsDataURL: c,
    abort: c,
    readyState: c,
    result: c,
    error: c,
    onloadstart: c,
    onprogress: c,
    onload: c,
    onabort: c,
    onerror: c,
    onloadend: c,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  }), Object.defineProperties(l, {
    EMPTY: t,
    LOADING: t,
    DONE: t
  }), oA = {
    FileReader: l
  }, oA;
}
var aA, Zu;
function bl() {
  return Zu || (Zu = 1, aA = {
    kConstruct: gt().kConstruct
  }), aA;
}
var AA, Ku;
function oQ() {
  if (Ku) return AA;
  Ku = 1;
  const t = lt, { URLSerializer: e } = or(), { isValidHeaderName: r } = mr();
  function n(i, o, a = !1) {
    const A = e(i, a), c = e(o, a);
    return A === c;
  }
  function s(i) {
    t(i !== null);
    const o = [];
    for (let a of i.split(","))
      a = a.trim(), r(a) && o.push(a);
    return o;
  }
  return AA = {
    urlEquals: n,
    getFieldValues: s
  }, AA;
}
var cA, ju;
function aQ() {
  if (ju) return cA;
  ju = 1;
  const { kConstruct: t } = bl(), { urlEquals: e, getFieldValues: r } = oQ(), { kEnumerableProperty: n, isDisturbed: s } = Xe(), { webidl: i } = zt(), { Response: o, cloneResponse: a, fromInnerResponse: A } = no(), { Request: c, fromInnerRequest: l } = ti(), { kState: d } = xn(), { fetching: u } = so(), { urlIsHttpHttpsScheme: m, createDeferredPromise: h, readAllBytes: f } = mr(), p = lt;
  class y {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
     * @type {requestResponseList}
     */
    #e;
    constructor() {
      arguments[0] !== t && i.illegalConstructor(), i.util.markAsUncloneable(this), this.#e = arguments[1];
    }
    async match(D, L = {}) {
      i.brandCheck(this, y);
      const C = "Cache.match";
      i.argumentLengthCheck(arguments, 1, C), D = i.converters.RequestInfo(D, C, "request"), L = i.converters.CacheQueryOptions(L, C, "options");
      const I = this.#r(D, L, 1);
      if (I.length !== 0)
        return I[0];
    }
    async matchAll(D = void 0, L = {}) {
      i.brandCheck(this, y);
      const C = "Cache.matchAll";
      return D !== void 0 && (D = i.converters.RequestInfo(D, C, "request")), L = i.converters.CacheQueryOptions(L, C, "options"), this.#r(D, L);
    }
    async add(D) {
      i.brandCheck(this, y);
      const L = "Cache.add";
      i.argumentLengthCheck(arguments, 1, L), D = i.converters.RequestInfo(D, L, "request");
      const C = [D];
      return await this.addAll(C);
    }
    async addAll(D) {
      i.brandCheck(this, y);
      const L = "Cache.addAll";
      i.argumentLengthCheck(arguments, 1, L);
      const C = [], I = [];
      for (let S of D) {
        if (S === void 0)
          throw i.errors.conversionFailed({
            prefix: L,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        if (S = i.converters.RequestInfo(S), typeof S == "string")
          continue;
        const M = S[d];
        if (!m(M.url) || M.method !== "GET")
          throw i.errors.exception({
            header: L,
            message: "Expected http/s scheme when method is not GET."
          });
      }
      const x = [];
      for (const S of D) {
        const M = new c(S)[d];
        if (!m(M.url))
          throw i.errors.exception({
            header: L,
            message: "Expected http/s scheme."
          });
        M.initiator = "fetch", M.destination = "subresource", I.push(M);
        const k = h();
        x.push(u({
          request: M,
          processResponse(F) {
            if (F.type === "error" || F.status === 206 || F.status < 200 || F.status > 299)
              k.reject(i.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            else if (F.headersList.contains("vary")) {
              const P = r(F.headersList.get("vary"));
              for (const J of P)
                if (J === "*") {
                  k.reject(i.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const te of x)
                    te.abort();
                  return;
                }
            }
          },
          processResponseEndOfBody(F) {
            if (F.aborted) {
              k.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            k.resolve(F);
          }
        })), C.push(k.promise);
      }
      const B = await Promise.all(C), Q = [];
      let E = 0;
      for (const S of B) {
        const M = {
          type: "put",
          // 7.3.2
          request: I[E],
          // 7.3.3
          response: S
          // 7.3.4
        };
        Q.push(M), E++;
      }
      const b = h();
      let N = null;
      try {
        this.#t(Q);
      } catch (S) {
        N = S;
      }
      return queueMicrotask(() => {
        N === null ? b.resolve(void 0) : b.reject(N);
      }), b.promise;
    }
    async put(D, L) {
      i.brandCheck(this, y);
      const C = "Cache.put";
      i.argumentLengthCheck(arguments, 2, C), D = i.converters.RequestInfo(D, C, "request"), L = i.converters.Response(L, C, "response");
      let I = null;
      if (D instanceof c ? I = D[d] : I = new c(D)[d], !m(I.url) || I.method !== "GET")
        throw i.errors.exception({
          header: C,
          message: "Expected an http/s scheme when method is not GET"
        });
      const x = L[d];
      if (x.status === 206)
        throw i.errors.exception({
          header: C,
          message: "Got 206 status"
        });
      if (x.headersList.contains("vary")) {
        const M = r(x.headersList.get("vary"));
        for (const k of M)
          if (k === "*")
            throw i.errors.exception({
              header: C,
              message: "Got * vary field value"
            });
      }
      if (x.body && (s(x.body.stream) || x.body.stream.locked))
        throw i.errors.exception({
          header: C,
          message: "Response body is locked or disturbed"
        });
      const g = a(x), B = h();
      if (x.body != null) {
        const k = x.body.stream.getReader();
        f(k).then(B.resolve, B.reject);
      } else
        B.resolve(void 0);
      const Q = [], E = {
        type: "put",
        // 14.
        request: I,
        // 15.
        response: g
        // 16.
      };
      Q.push(E);
      const b = await B.promise;
      g.body != null && (g.body.source = b);
      const N = h();
      let S = null;
      try {
        this.#t(Q);
      } catch (M) {
        S = M;
      }
      return queueMicrotask(() => {
        S === null ? N.resolve() : N.reject(S);
      }), N.promise;
    }
    async delete(D, L = {}) {
      i.brandCheck(this, y);
      const C = "Cache.delete";
      i.argumentLengthCheck(arguments, 1, C), D = i.converters.RequestInfo(D, C, "request"), L = i.converters.CacheQueryOptions(L, C, "options");
      let I = null;
      if (D instanceof c) {
        if (I = D[d], I.method !== "GET" && !L.ignoreMethod)
          return !1;
      } else
        p(typeof D == "string"), I = new c(D)[d];
      const x = [], g = {
        type: "delete",
        request: I,
        options: L
      };
      x.push(g);
      const B = h();
      let Q = null, E;
      try {
        E = this.#t(x);
      } catch (b) {
        Q = b;
      }
      return queueMicrotask(() => {
        Q === null ? B.resolve(!!E?.length) : B.reject(Q);
      }), B.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @returns {Promise<readonly Request[]>}
     */
    async keys(D = void 0, L = {}) {
      i.brandCheck(this, y);
      const C = "Cache.keys";
      D !== void 0 && (D = i.converters.RequestInfo(D, C, "request")), L = i.converters.CacheQueryOptions(L, C, "options");
      let I = null;
      if (D !== void 0)
        if (D instanceof c) {
          if (I = D[d], I.method !== "GET" && !L.ignoreMethod)
            return [];
        } else typeof D == "string" && (I = new c(D)[d]);
      const x = h(), g = [];
      if (D === void 0)
        for (const B of this.#e)
          g.push(B[0]);
      else {
        const B = this.#s(I, L);
        for (const Q of B)
          g.push(Q[0]);
      }
      return queueMicrotask(() => {
        const B = [];
        for (const Q of g) {
          const E = l(
            Q,
            new AbortController().signal,
            "immutable"
          );
          B.push(E);
        }
        x.resolve(Object.freeze(B));
      }), x.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    #t(D) {
      const L = this.#e, C = [...L], I = [], x = [];
      try {
        for (const g of D) {
          if (g.type !== "delete" && g.type !== "put")
            throw i.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          if (g.type === "delete" && g.response != null)
            throw i.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          if (this.#s(g.request, g.options, I).length)
            throw new DOMException("???", "InvalidStateError");
          let B;
          if (g.type === "delete") {
            if (B = this.#s(g.request, g.options), B.length === 0)
              return [];
            for (const Q of B) {
              const E = L.indexOf(Q);
              p(E !== -1), L.splice(E, 1);
            }
          } else if (g.type === "put") {
            if (g.response == null)
              throw i.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            const Q = g.request;
            if (!m(Q.url))
              throw i.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            if (Q.method !== "GET")
              throw i.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            if (g.options != null)
              throw i.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            B = this.#s(g.request);
            for (const E of B) {
              const b = L.indexOf(E);
              p(b !== -1), L.splice(b, 1);
            }
            L.push([g.request, g.response]), I.push([g.request, g.response]);
          }
          x.push([g.request, g.response]);
        }
        return x;
      } catch (g) {
        throw this.#e.length = 0, this.#e = C, g;
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    #s(D, L, C) {
      const I = [], x = C ?? this.#e;
      for (const g of x) {
        const [B, Q] = g;
        this.#n(D, B, Q, L) && I.push(g);
      }
      return I;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    #n(D, L, C = null, I) {
      const x = new URL(D.url), g = new URL(L.url);
      if (I?.ignoreSearch && (g.search = "", x.search = ""), !e(x, g, !0))
        return !1;
      if (C == null || I?.ignoreVary || !C.headersList.contains("vary"))
        return !0;
      const B = r(C.headersList.get("vary"));
      for (const Q of B) {
        if (Q === "*")
          return !1;
        const E = L.headersList.get(Q), b = D.headersList.get(Q);
        if (E !== b)
          return !1;
      }
      return !0;
    }
    #r(D, L, C = 1 / 0) {
      let I = null;
      if (D !== void 0)
        if (D instanceof c) {
          if (I = D[d], I.method !== "GET" && !L.ignoreMethod)
            return [];
        } else typeof D == "string" && (I = new c(D)[d]);
      const x = [];
      if (D === void 0)
        for (const B of this.#e)
          x.push(B[1]);
      else {
        const B = this.#s(I, L);
        for (const Q of B)
          x.push(Q[1]);
      }
      const g = [];
      for (const B of x) {
        const Q = A(B, "immutable");
        if (g.push(Q.clone()), g.length >= C)
          break;
      }
      return Object.freeze(g);
    }
  }
  Object.defineProperties(y.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: !0
    },
    match: n,
    matchAll: n,
    add: n,
    addAll: n,
    put: n,
    delete: n,
    keys: n
  });
  const w = [
    {
      key: "ignoreSearch",
      converter: i.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "ignoreMethod",
      converter: i.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "ignoreVary",
      converter: i.converters.boolean,
      defaultValue: () => !1
    }
  ];
  return i.converters.CacheQueryOptions = i.dictionaryConverter(w), i.converters.MultiCacheQueryOptions = i.dictionaryConverter([
    ...w,
    {
      key: "cacheName",
      converter: i.converters.DOMString
    }
  ]), i.converters.Response = i.interfaceConverter(o), i.converters["sequence<RequestInfo>"] = i.sequenceConverter(
    i.converters.RequestInfo
  ), cA = {
    Cache: y
  }, cA;
}
var lA, em;
function AQ() {
  if (em) return lA;
  em = 1;
  const { kConstruct: t } = bl(), { Cache: e } = aQ(), { webidl: r } = zt(), { kEnumerableProperty: n } = Xe();
  class s {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
     * @type {Map<string, import('./cache').requestResponseList}
     */
    #e = /* @__PURE__ */ new Map();
    constructor() {
      arguments[0] !== t && r.illegalConstructor(), r.util.markAsUncloneable(this);
    }
    async match(o, a = {}) {
      if (r.brandCheck(this, s), r.argumentLengthCheck(arguments, 1, "CacheStorage.match"), o = r.converters.RequestInfo(o), a = r.converters.MultiCacheQueryOptions(a), a.cacheName != null) {
        if (this.#e.has(a.cacheName)) {
          const A = this.#e.get(a.cacheName);
          return await new e(t, A).match(o, a);
        }
      } else
        for (const A of this.#e.values()) {
          const l = await new e(t, A).match(o, a);
          if (l !== void 0)
            return l;
        }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(o) {
      r.brandCheck(this, s);
      const a = "CacheStorage.has";
      return r.argumentLengthCheck(arguments, 1, a), o = r.converters.DOMString(o, a, "cacheName"), this.#e.has(o);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(o) {
      r.brandCheck(this, s);
      const a = "CacheStorage.open";
      if (r.argumentLengthCheck(arguments, 1, a), o = r.converters.DOMString(o, a, "cacheName"), this.#e.has(o)) {
        const c = this.#e.get(o);
        return new e(t, c);
      }
      const A = [];
      return this.#e.set(o, A), new e(t, A);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(o) {
      r.brandCheck(this, s);
      const a = "CacheStorage.delete";
      return r.argumentLengthCheck(arguments, 1, a), o = r.converters.DOMString(o, a, "cacheName"), this.#e.delete(o);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {Promise<string[]>}
     */
    async keys() {
      return r.brandCheck(this, s), [...this.#e.keys()];
    }
  }
  return Object.defineProperties(s.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: !0
    },
    match: n,
    has: n,
    open: n,
    delete: n,
    keys: n
  }), lA = {
    CacheStorage: s
  }, lA;
}
var dA, tm;
function cQ() {
  return tm || (tm = 1, dA = {
    maxAttributeValueSize: 1024,
    maxNameValuePairSize: 4096
  }), dA;
}
var uA, rm;
function ff() {
  if (rm) return uA;
  rm = 1;
  function t(d) {
    for (let u = 0; u < d.length; ++u) {
      const m = d.charCodeAt(u);
      if (m >= 0 && m <= 8 || m >= 10 && m <= 31 || m === 127)
        return !0;
    }
    return !1;
  }
  function e(d) {
    for (let u = 0; u < d.length; ++u) {
      const m = d.charCodeAt(u);
      if (m < 33 || // exclude CTLs (0-31), SP and HT
      m > 126 || // exclude non-ascii and DEL
      m === 34 || // "
      m === 40 || // (
      m === 41 || // )
      m === 60 || // <
      m === 62 || // >
      m === 64 || // @
      m === 44 || // ,
      m === 59 || // ;
      m === 58 || // :
      m === 92 || // \
      m === 47 || // /
      m === 91 || // [
      m === 93 || // ]
      m === 63 || // ?
      m === 61 || // =
      m === 123 || // {
      m === 125)
        throw new Error("Invalid cookie name");
    }
  }
  function r(d) {
    let u = d.length, m = 0;
    if (d[0] === '"') {
      if (u === 1 || d[u - 1] !== '"')
        throw new Error("Invalid cookie value");
      --u, ++m;
    }
    for (; m < u; ) {
      const h = d.charCodeAt(m++);
      if (h < 33 || // exclude CTLs (0-31)
      h > 126 || // non-ascii and DEL (127)
      h === 34 || // "
      h === 44 || // ,
      h === 59 || // ;
      h === 92)
        throw new Error("Invalid cookie value");
    }
  }
  function n(d) {
    for (let u = 0; u < d.length; ++u) {
      const m = d.charCodeAt(u);
      if (m < 32 || // exclude CTLs (0-31)
      m === 127 || // DEL
      m === 59)
        throw new Error("Invalid cookie path");
    }
  }
  function s(d) {
    if (d.startsWith("-") || d.endsWith(".") || d.endsWith("-"))
      throw new Error("Invalid cookie domain");
  }
  const i = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ], o = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ], a = Array(61).fill(0).map((d, u) => u.toString().padStart(2, "0"));
  function A(d) {
    return typeof d == "number" && (d = new Date(d)), `${i[d.getUTCDay()]}, ${a[d.getUTCDate()]} ${o[d.getUTCMonth()]} ${d.getUTCFullYear()} ${a[d.getUTCHours()]}:${a[d.getUTCMinutes()]}:${a[d.getUTCSeconds()]} GMT`;
  }
  function c(d) {
    if (d < 0)
      throw new Error("Invalid cookie max-age");
  }
  function l(d) {
    if (d.name.length === 0)
      return null;
    e(d.name), r(d.value);
    const u = [`${d.name}=${d.value}`];
    d.name.startsWith("__Secure-") && (d.secure = !0), d.name.startsWith("__Host-") && (d.secure = !0, d.domain = null, d.path = "/"), d.secure && u.push("Secure"), d.httpOnly && u.push("HttpOnly"), typeof d.maxAge == "number" && (c(d.maxAge), u.push(`Max-Age=${d.maxAge}`)), d.domain && (s(d.domain), u.push(`Domain=${d.domain}`)), d.path && (n(d.path), u.push(`Path=${d.path}`)), d.expires && d.expires.toString() !== "Invalid Date" && u.push(`Expires=${A(d.expires)}`), d.sameSite && u.push(`SameSite=${d.sameSite}`);
    for (const m of d.unparsed) {
      if (!m.includes("="))
        throw new Error("Invalid unparsed");
      const [h, ...f] = m.split("=");
      u.push(`${h.trim()}=${f.join("=")}`);
    }
    return u.join("; ");
  }
  return uA = {
    isCTLExcludingHtab: t,
    validateCookieName: e,
    validateCookiePath: n,
    validateCookieValue: r,
    toIMFDate: A,
    stringify: l
  }, uA;
}
var mA, nm;
function lQ() {
  if (nm) return mA;
  nm = 1;
  const { maxNameValuePairSize: t, maxAttributeValueSize: e } = cQ(), { isCTLExcludingHtab: r } = ff(), { collectASequenceOfCodePointsFast: n } = or(), s = lt;
  function i(a) {
    if (r(a))
      return null;
    let A = "", c = "", l = "", d = "";
    if (a.includes(";")) {
      const u = { position: 0 };
      A = n(";", a, u), c = a.slice(u.position);
    } else
      A = a;
    if (!A.includes("="))
      d = A;
    else {
      const u = { position: 0 };
      l = n(
        "=",
        A,
        u
      ), d = A.slice(u.position + 1);
    }
    return l = l.trim(), d = d.trim(), l.length + d.length > t ? null : {
      name: l,
      value: d,
      ...o(c)
    };
  }
  function o(a, A = {}) {
    if (a.length === 0)
      return A;
    s(a[0] === ";"), a = a.slice(1);
    let c = "";
    a.includes(";") ? (c = n(
      ";",
      a,
      { position: 0 }
    ), a = a.slice(c.length)) : (c = a, a = "");
    let l = "", d = "";
    if (c.includes("=")) {
      const m = { position: 0 };
      l = n(
        "=",
        c,
        m
      ), d = c.slice(m.position + 1);
    } else
      l = c;
    if (l = l.trim(), d = d.trim(), d.length > e)
      return o(a, A);
    const u = l.toLowerCase();
    if (u === "expires") {
      const m = new Date(d);
      A.expires = m;
    } else if (u === "max-age") {
      const m = d.charCodeAt(0);
      if ((m < 48 || m > 57) && d[0] !== "-" || !/^\d+$/.test(d))
        return o(a, A);
      const h = Number(d);
      A.maxAge = h;
    } else if (u === "domain") {
      let m = d;
      m[0] === "." && (m = m.slice(1)), m = m.toLowerCase(), A.domain = m;
    } else if (u === "path") {
      let m = "";
      d.length === 0 || d[0] !== "/" ? m = "/" : m = d, A.path = m;
    } else if (u === "secure")
      A.secure = !0;
    else if (u === "httponly")
      A.httpOnly = !0;
    else if (u === "samesite") {
      let m = "Default";
      const h = d.toLowerCase();
      h.includes("none") && (m = "None"), h.includes("strict") && (m = "Strict"), h.includes("lax") && (m = "Lax"), A.sameSite = m;
    } else
      A.unparsed ??= [], A.unparsed.push(`${l}=${d}`);
    return o(a, A);
  }
  return mA = {
    parseSetCookie: i,
    parseUnparsedAttributes: o
  }, mA;
}
var hA, sm;
function dQ() {
  if (sm) return hA;
  sm = 1;
  const { parseSetCookie: t } = lQ(), { stringify: e } = ff(), { webidl: r } = zt(), { Headers: n } = Xn();
  function s(A) {
    r.argumentLengthCheck(arguments, 1, "getCookies"), r.brandCheck(A, n, { strict: !1 });
    const c = A.get("cookie"), l = {};
    if (!c)
      return l;
    for (const d of c.split(";")) {
      const [u, ...m] = d.split("=");
      l[u.trim()] = m.join("=");
    }
    return l;
  }
  function i(A, c, l) {
    r.brandCheck(A, n, { strict: !1 });
    const d = "deleteCookie";
    r.argumentLengthCheck(arguments, 2, d), c = r.converters.DOMString(c, d, "name"), l = r.converters.DeleteCookieAttributes(l), a(A, {
      name: c,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...l
    });
  }
  function o(A) {
    r.argumentLengthCheck(arguments, 1, "getSetCookies"), r.brandCheck(A, n, { strict: !1 });
    const c = A.getSetCookie();
    return c ? c.map((l) => t(l)) : [];
  }
  function a(A, c) {
    r.argumentLengthCheck(arguments, 2, "setCookie"), r.brandCheck(A, n, { strict: !1 }), c = r.converters.Cookie(c);
    const l = e(c);
    l && A.append("Set-Cookie", l);
  }
  return r.converters.DeleteCookieAttributes = r.dictionaryConverter([
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]), r.converters.Cookie = r.dictionaryConverter([
    {
      converter: r.converters.DOMString,
      key: "name"
    },
    {
      converter: r.converters.DOMString,
      key: "value"
    },
    {
      converter: r.nullableConverter((A) => typeof A == "number" ? r.converters["unsigned long long"](A) : new Date(A)),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: r.nullableConverter(r.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: r.nullableConverter(r.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: r.nullableConverter(r.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: r.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: r.sequenceConverter(r.converters.DOMString),
      key: "unparsed",
      defaultValue: () => new Array(0)
    }
  ]), hA = {
    getCookies: s,
    deleteCookie: i,
    getSetCookies: o,
    setCookie: a
  }, hA;
}
var gA, im;
function ri() {
  if (im) return gA;
  im = 1;
  const { webidl: t } = zt(), { kEnumerableProperty: e } = Xe(), { kConstruct: r } = gt(), { MessagePort: n } = Xg;
  class s extends Event {
    #e;
    constructor(l, d = {}) {
      if (l === r) {
        super(arguments[1], arguments[2]), t.util.markAsUncloneable(this);
        return;
      }
      const u = "MessageEvent constructor";
      t.argumentLengthCheck(arguments, 1, u), l = t.converters.DOMString(l, u, "type"), d = t.converters.MessageEventInit(d, u, "eventInitDict"), super(l, d), this.#e = d, t.util.markAsUncloneable(this);
    }
    get data() {
      return t.brandCheck(this, s), this.#e.data;
    }
    get origin() {
      return t.brandCheck(this, s), this.#e.origin;
    }
    get lastEventId() {
      return t.brandCheck(this, s), this.#e.lastEventId;
    }
    get source() {
      return t.brandCheck(this, s), this.#e.source;
    }
    get ports() {
      return t.brandCheck(this, s), Object.isFrozen(this.#e.ports) || Object.freeze(this.#e.ports), this.#e.ports;
    }
    initMessageEvent(l, d = !1, u = !1, m = null, h = "", f = "", p = null, y = []) {
      return t.brandCheck(this, s), t.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent"), new s(l, {
        bubbles: d,
        cancelable: u,
        data: m,
        origin: h,
        lastEventId: f,
        source: p,
        ports: y
      });
    }
    static createFastMessageEvent(l, d) {
      const u = new s(r, l, d);
      return u.#e = d, u.#e.data ??= null, u.#e.origin ??= "", u.#e.lastEventId ??= "", u.#e.source ??= null, u.#e.ports ??= [], u;
    }
  }
  const { createFastMessageEvent: i } = s;
  delete s.createFastMessageEvent;
  class o extends Event {
    #e;
    constructor(l, d = {}) {
      const u = "CloseEvent constructor";
      t.argumentLengthCheck(arguments, 1, u), l = t.converters.DOMString(l, u, "type"), d = t.converters.CloseEventInit(d), super(l, d), this.#e = d, t.util.markAsUncloneable(this);
    }
    get wasClean() {
      return t.brandCheck(this, o), this.#e.wasClean;
    }
    get code() {
      return t.brandCheck(this, o), this.#e.code;
    }
    get reason() {
      return t.brandCheck(this, o), this.#e.reason;
    }
  }
  class a extends Event {
    #e;
    constructor(l, d) {
      const u = "ErrorEvent constructor";
      t.argumentLengthCheck(arguments, 1, u), super(l, d), t.util.markAsUncloneable(this), l = t.converters.DOMString(l, u, "type"), d = t.converters.ErrorEventInit(d ?? {}), this.#e = d;
    }
    get message() {
      return t.brandCheck(this, a), this.#e.message;
    }
    get filename() {
      return t.brandCheck(this, a), this.#e.filename;
    }
    get lineno() {
      return t.brandCheck(this, a), this.#e.lineno;
    }
    get colno() {
      return t.brandCheck(this, a), this.#e.colno;
    }
    get error() {
      return t.brandCheck(this, a), this.#e.error;
    }
  }
  Object.defineProperties(s.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: !0
    },
    data: e,
    origin: e,
    lastEventId: e,
    source: e,
    ports: e,
    initMessageEvent: e
  }), Object.defineProperties(o.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: !0
    },
    reason: e,
    code: e,
    wasClean: e
  }), Object.defineProperties(a.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: !0
    },
    message: e,
    filename: e,
    lineno: e,
    colno: e,
    error: e
  }), t.converters.MessagePort = t.interfaceConverter(n), t.converters["sequence<MessagePort>"] = t.sequenceConverter(
    t.converters.MessagePort
  );
  const A = [
    {
      key: "bubbles",
      converter: t.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "cancelable",
      converter: t.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "composed",
      converter: t.converters.boolean,
      defaultValue: () => !1
    }
  ];
  return t.converters.MessageEventInit = t.dictionaryConverter([
    ...A,
    {
      key: "data",
      converter: t.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: t.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: t.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: t.nullableConverter(t.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: t.converters["sequence<MessagePort>"],
      defaultValue: () => new Array(0)
    }
  ]), t.converters.CloseEventInit = t.dictionaryConverter([
    ...A,
    {
      key: "wasClean",
      converter: t.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "code",
      converter: t.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: t.converters.USVString,
      defaultValue: () => ""
    }
  ]), t.converters.ErrorEventInit = t.dictionaryConverter([
    ...A,
    {
      key: "message",
      converter: t.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: t.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: t.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: t.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: t.converters.any
    }
  ]), gA = {
    MessageEvent: s,
    CloseEvent: o,
    ErrorEvent: a,
    createFastMessageEvent: i
  }, gA;
}
var fA, om;
function Zn() {
  if (om) return fA;
  om = 1;
  const t = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", e = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  }, r = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  }, n = {
    NOT_SENT: 0,
    PROCESSING: 1,
    SENT: 2
  }, s = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  }, i = 2 ** 16 - 1, o = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  }, a = Buffer.allocUnsafe(0);
  return fA = {
    uid: t,
    sentCloseFrameState: n,
    staticPropertyDescriptors: e,
    states: r,
    opcodes: s,
    maxUnsigned16Bit: i,
    parserStates: o,
    emptyBuffer: a,
    sendHints: {
      string: 1,
      typedArray: 2,
      arrayBuffer: 3,
      blob: 4
    }
  }, fA;
}
var pA, am;
function io() {
  return am || (am = 1, pA = {
    kWebSocketURL: /* @__PURE__ */ Symbol("url"),
    kReadyState: /* @__PURE__ */ Symbol("ready state"),
    kController: /* @__PURE__ */ Symbol("controller"),
    kResponse: /* @__PURE__ */ Symbol("response"),
    kBinaryType: /* @__PURE__ */ Symbol("binary type"),
    kSentClose: /* @__PURE__ */ Symbol("sent close"),
    kReceivedClose: /* @__PURE__ */ Symbol("received close"),
    kByteParser: /* @__PURE__ */ Symbol("byte parser")
  }), pA;
}
var EA, Am;
function oo() {
  if (Am) return EA;
  Am = 1;
  const { kReadyState: t, kController: e, kResponse: r, kBinaryType: n, kWebSocketURL: s } = io(), { states: i, opcodes: o } = Zn(), { ErrorEvent: a, createFastMessageEvent: A } = ri(), { isUtf8: c } = ur, { collectASequenceOfCodePointsFast: l, removeHTTPWhitespace: d } = or();
  function u(S) {
    return S[t] === i.CONNECTING;
  }
  function m(S) {
    return S[t] === i.OPEN;
  }
  function h(S) {
    return S[t] === i.CLOSING;
  }
  function f(S) {
    return S[t] === i.CLOSED;
  }
  function p(S, M, k = (P, J) => new Event(P, J), F = {}) {
    const P = k(S, F);
    M.dispatchEvent(P);
  }
  function y(S, M, k) {
    if (S[t] !== i.OPEN)
      return;
    let F;
    if (M === o.TEXT)
      try {
        F = N(k);
      } catch {
        L(S, "Received invalid UTF-8 in text frame.");
        return;
      }
    else M === o.BINARY && (S[n] === "blob" ? F = new Blob([k]) : F = w(k));
    p("message", S, A, {
      origin: S[s].origin,
      data: F
    });
  }
  function w(S) {
    return S.byteLength === S.buffer.byteLength ? S.buffer : S.buffer.slice(S.byteOffset, S.byteOffset + S.byteLength);
  }
  function R(S) {
    if (S.length === 0)
      return !1;
    for (let M = 0; M < S.length; ++M) {
      const k = S.charCodeAt(M);
      if (k < 33 || // CTL, contains SP (0x20) and HT (0x09)
      k > 126 || k === 34 || // "
      k === 40 || // (
      k === 41 || // )
      k === 44 || // ,
      k === 47 || // /
      k === 58 || // :
      k === 59 || // ;
      k === 60 || // <
      k === 61 || // =
      k === 62 || // >
      k === 63 || // ?
      k === 64 || // @
      k === 91 || // [
      k === 92 || // \
      k === 93 || // ]
      k === 123 || // {
      k === 125)
        return !1;
    }
    return !0;
  }
  function D(S) {
    return S >= 1e3 && S < 1015 ? S !== 1004 && // reserved
    S !== 1005 && // "MUST NOT be set as a status code"
    S !== 1006 : S >= 3e3 && S <= 4999;
  }
  function L(S, M) {
    const { [e]: k, [r]: F } = S;
    k.abort(), F?.socket && !F.socket.destroyed && F.socket.destroy(), M && p("error", S, (P, J) => new a(P, J), {
      error: new Error(M),
      message: M
    });
  }
  function C(S) {
    return S === o.CLOSE || S === o.PING || S === o.PONG;
  }
  function I(S) {
    return S === o.CONTINUATION;
  }
  function x(S) {
    return S === o.TEXT || S === o.BINARY;
  }
  function g(S) {
    return x(S) || I(S) || C(S);
  }
  function B(S) {
    const M = { position: 0 }, k = /* @__PURE__ */ new Map();
    for (; M.position < S.length; ) {
      const F = l(";", S, M), [P, J = ""] = F.split("=");
      k.set(
        d(P, !0, !1),
        d(J, !1, !0)
      ), M.position++;
    }
    return k;
  }
  function Q(S) {
    for (let M = 0; M < S.length; M++) {
      const k = S.charCodeAt(M);
      if (k < 48 || k > 57)
        return !1;
    }
    return !0;
  }
  const E = typeof process.versions.icu == "string", b = E ? new TextDecoder("utf-8", { fatal: !0 }) : void 0, N = E ? b.decode.bind(b) : function(S) {
    if (c(S))
      return S.toString("utf-8");
    throw new TypeError("Invalid utf-8 received.");
  };
  return EA = {
    isConnecting: u,
    isEstablished: m,
    isClosing: h,
    isClosed: f,
    fireEvent: p,
    isValidSubprotocol: R,
    isValidStatusCode: D,
    failWebsocketConnection: L,
    websocketMessageReceived: y,
    utf8Decode: N,
    isControlFrame: C,
    isContinuationFrame: I,
    isTextBinaryFrame: x,
    isValidOpcode: g,
    parseExtensions: B,
    isValidClientWindowBits: Q
  }, EA;
}
var CA, cm;
function xl() {
  if (cm) return CA;
  cm = 1;
  const { maxUnsigned16Bit: t } = Zn(), e = 16386;
  let r, n = null, s = e;
  try {
    r = Wn("node:crypto");
  } catch {
    r = {
      // not full compatibility, but minimum.
      randomFillSync: function(A, c, l) {
        for (let d = 0; d < A.length; ++d)
          A[d] = Math.random() * 255 | 0;
        return A;
      }
    };
  }
  function i() {
    return s === e && (s = 0, r.randomFillSync(n ??= Buffer.allocUnsafe(e), 0, e)), [n[s++], n[s++], n[s++], n[s++]];
  }
  class o {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(A) {
      this.frameData = A;
    }
    createFrame(A) {
      const c = this.frameData, l = i(), d = c?.byteLength ?? 0;
      let u = d, m = 6;
      d > t ? (m += 8, u = 127) : d > 125 && (m += 2, u = 126);
      const h = Buffer.allocUnsafe(d + m);
      h[0] = h[1] = 0, h[0] |= 128, h[0] = (h[0] & 240) + A;
      h[m - 4] = l[0], h[m - 3] = l[1], h[m - 2] = l[2], h[m - 1] = l[3], h[1] = u, u === 126 ? h.writeUInt16BE(d, 2) : u === 127 && (h[2] = h[3] = 0, h.writeUIntBE(d, 4, 6)), h[1] |= 128;
      for (let f = 0; f < d; ++f)
        h[m + f] = c[f] ^ l[f & 3];
      return h;
    }
  }
  return CA = {
    WebsocketFrameSend: o
  }, CA;
}
var BA, lm;
function pf() {
  if (lm) return BA;
  lm = 1;
  const { uid: t, states: e, sentCloseFrameState: r, emptyBuffer: n, opcodes: s } = Zn(), {
    kReadyState: i,
    kSentClose: o,
    kByteParser: a,
    kReceivedClose: A,
    kResponse: c
  } = io(), { fireEvent: l, failWebsocketConnection: d, isClosing: u, isClosed: m, isEstablished: h, parseExtensions: f } = oo(), { channels: p } = Ws(), { CloseEvent: y } = ri(), { makeRequest: w } = ti(), { fetching: R } = so(), { Headers: D, getHeadersList: L } = Xn(), { getDecodeSplit: C } = mr(), { WebsocketFrameSend: I } = xl();
  let x;
  try {
    x = Wn("node:crypto");
  } catch {
  }
  function g(N, S, M, k, F, P) {
    const J = N;
    J.protocol = N.protocol === "ws:" ? "http:" : "https:";
    const te = w({
      urlList: [J],
      client: M,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (P.headers) {
      const ce = L(new D(P.headers));
      te.headersList = ce;
    }
    const ee = x.randomBytes(16).toString("base64");
    te.headersList.append("sec-websocket-key", ee), te.headersList.append("sec-websocket-version", "13");
    for (const ce of S)
      te.headersList.append("sec-websocket-protocol", ce);
    return te.headersList.append("sec-websocket-extensions", "permessage-deflate; client_max_window_bits"), R({
      request: te,
      useParallelQueue: !0,
      dispatcher: P.dispatcher,
      processResponse(ce) {
        if (ce.type === "error" || ce.status !== 101) {
          d(k, "Received network error or non-101 status code.");
          return;
        }
        if (S.length !== 0 && !ce.headersList.get("Sec-WebSocket-Protocol")) {
          d(k, "Server did not respond with sent protocols.");
          return;
        }
        if (ce.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          d(k, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (ce.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          d(k, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const fe = ce.headersList.get("Sec-WebSocket-Accept"), Ce = x.createHash("sha1").update(ee + t).digest("base64");
        if (fe !== Ce) {
          d(k, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const Z = ce.headersList.get("Sec-WebSocket-Extensions");
        let _;
        if (Z !== null && (_ = f(Z), !_.has("permessage-deflate"))) {
          d(k, "Sec-WebSocket-Extensions header does not match.");
          return;
        }
        const ne = ce.headersList.get("Sec-WebSocket-Protocol");
        if (ne !== null && !C("sec-websocket-protocol", te.headersList).includes(ne)) {
          d(k, "Protocol was not set in the opening handshake.");
          return;
        }
        ce.socket.on("data", Q), ce.socket.on("close", E), ce.socket.on("error", b), p.open.hasSubscribers && p.open.publish({
          address: ce.socket.address(),
          protocol: ne,
          extensions: Z
        }), F(ce, _);
      }
    });
  }
  function B(N, S, M, k) {
    if (!(u(N) || m(N))) if (!h(N))
      d(N, "Connection was closed before it was established."), N[i] = e.CLOSING;
    else if (N[o] === r.NOT_SENT) {
      N[o] = r.PROCESSING;
      const F = new I();
      S !== void 0 && M === void 0 ? (F.frameData = Buffer.allocUnsafe(2), F.frameData.writeUInt16BE(S, 0)) : S !== void 0 && M !== void 0 ? (F.frameData = Buffer.allocUnsafe(2 + k), F.frameData.writeUInt16BE(S, 0), F.frameData.write(M, 2, "utf-8")) : F.frameData = n, N[c].socket.write(F.createFrame(s.CLOSE)), N[o] = r.SENT, N[i] = e.CLOSING;
    } else
      N[i] = e.CLOSING;
  }
  function Q(N) {
    this.ws[a].write(N) || this.pause();
  }
  function E() {
    const { ws: N } = this, { [c]: S } = N;
    S.socket.off("data", Q), S.socket.off("close", E), S.socket.off("error", b);
    const M = N[o] === r.SENT && N[A];
    let k = 1005, F = "";
    const P = N[a].closingInfo;
    P && !P.error ? (k = P.code ?? 1005, F = P.reason) : N[A] || (k = 1006), N[i] = e.CLOSED, l("close", N, (J, te) => new y(J, te), {
      wasClean: M,
      code: k,
      reason: F
    }), p.close.hasSubscribers && p.close.publish({
      websocket: N,
      code: k,
      reason: F
    });
  }
  function b(N) {
    const { ws: S } = this;
    S[i] = e.CLOSING, p.socketError.hasSubscribers && p.socketError.publish(N), this.destroy();
  }
  return BA = {
    establishWebSocketConnection: g,
    closeWebSocketConnection: B
  }, BA;
}
var IA, dm;
function uQ() {
  if (dm) return IA;
  dm = 1;
  const { createInflateRaw: t, Z_DEFAULT_WINDOWBITS: e } = Hs, { isValidClientWindowBits: r } = oo(), n = Buffer.from([0, 0, 255, 255]), s = /* @__PURE__ */ Symbol("kBuffer"), i = /* @__PURE__ */ Symbol("kLength");
  class o {
    /** @type {import('node:zlib').InflateRaw} */
    #e;
    #t = {};
    constructor(A) {
      this.#t.serverNoContextTakeover = A.has("server_no_context_takeover"), this.#t.serverMaxWindowBits = A.get("server_max_window_bits");
    }
    decompress(A, c, l) {
      if (!this.#e) {
        let d = e;
        if (this.#t.serverMaxWindowBits) {
          if (!r(this.#t.serverMaxWindowBits)) {
            l(new Error("Invalid server_max_window_bits"));
            return;
          }
          d = Number.parseInt(this.#t.serverMaxWindowBits);
        }
        this.#e = t({ windowBits: d }), this.#e[s] = [], this.#e[i] = 0, this.#e.on("data", (u) => {
          this.#e[s].push(u), this.#e[i] += u.length;
        }), this.#e.on("error", (u) => {
          this.#e = null, l(u);
        });
      }
      this.#e.write(A), c && this.#e.write(n), this.#e.flush(() => {
        const d = Buffer.concat(this.#e[s], this.#e[i]);
        this.#e[s].length = 0, this.#e[i] = 0, l(null, d);
      });
    }
  }
  return IA = { PerMessageDeflate: o }, IA;
}
var yA, um;
function mQ() {
  if (um) return yA;
  um = 1;
  const { Writable: t } = dr, e = lt, { parserStates: r, opcodes: n, states: s, emptyBuffer: i, sentCloseFrameState: o } = Zn(), { kReadyState: a, kSentClose: A, kResponse: c, kReceivedClose: l } = io(), { channels: d } = Ws(), {
    isValidStatusCode: u,
    isValidOpcode: m,
    failWebsocketConnection: h,
    websocketMessageReceived: f,
    utf8Decode: p,
    isControlFrame: y,
    isTextBinaryFrame: w,
    isContinuationFrame: R
  } = oo(), { WebsocketFrameSend: D } = xl(), { closeWebSocketConnection: L } = pf(), { PerMessageDeflate: C } = uQ();
  class I extends t {
    #e = [];
    #t = 0;
    #s = !1;
    #n = r.INFO;
    #r = {};
    #i = [];
    /** @type {Map<string, PerMessageDeflate>} */
    #o;
    constructor(g, B) {
      super(), this.ws = g, this.#o = B ?? /* @__PURE__ */ new Map(), this.#o.has("permessage-deflate") && this.#o.set("permessage-deflate", new C(B));
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(g, B, Q) {
      this.#e.push(g), this.#t += g.length, this.#s = !0, this.run(Q);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(g) {
      for (; this.#s; )
        if (this.#n === r.INFO) {
          if (this.#t < 2)
            return g();
          const B = this.consume(2), Q = (B[0] & 128) !== 0, E = B[0] & 15, b = (B[1] & 128) === 128, N = !Q && E !== n.CONTINUATION, S = B[1] & 127, M = B[0] & 64, k = B[0] & 32, F = B[0] & 16;
          if (!m(E))
            return h(this.ws, "Invalid opcode received"), g();
          if (b)
            return h(this.ws, "Frame cannot be masked"), g();
          if (M !== 0 && !this.#o.has("permessage-deflate")) {
            h(this.ws, "Expected RSV1 to be clear.");
            return;
          }
          if (k !== 0 || F !== 0) {
            h(this.ws, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (N && !w(E)) {
            h(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          if (w(E) && this.#i.length > 0) {
            h(this.ws, "Expected continuation frame");
            return;
          }
          if (this.#r.fragmented && N) {
            h(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((S > 125 || N) && y(E)) {
            h(this.ws, "Control frame either too large or fragmented");
            return;
          }
          if (R(E) && this.#i.length === 0 && !this.#r.compressed) {
            h(this.ws, "Unexpected continuation frame");
            return;
          }
          S <= 125 ? (this.#r.payloadLength = S, this.#n = r.READ_DATA) : S === 126 ? this.#n = r.PAYLOADLENGTH_16 : S === 127 && (this.#n = r.PAYLOADLENGTH_64), w(E) && (this.#r.binaryType = E, this.#r.compressed = M !== 0), this.#r.opcode = E, this.#r.masked = b, this.#r.fin = Q, this.#r.fragmented = N;
        } else if (this.#n === r.PAYLOADLENGTH_16) {
          if (this.#t < 2)
            return g();
          const B = this.consume(2);
          this.#r.payloadLength = B.readUInt16BE(0), this.#n = r.READ_DATA;
        } else if (this.#n === r.PAYLOADLENGTH_64) {
          if (this.#t < 8)
            return g();
          const B = this.consume(8), Q = B.readUInt32BE(0);
          if (Q > 2 ** 31 - 1) {
            h(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const E = B.readUInt32BE(4);
          this.#r.payloadLength = (Q << 8) + E, this.#n = r.READ_DATA;
        } else if (this.#n === r.READ_DATA) {
          if (this.#t < this.#r.payloadLength)
            return g();
          const B = this.consume(this.#r.payloadLength);
          if (y(this.#r.opcode))
            this.#s = this.parseControlFrame(B), this.#n = r.INFO;
          else if (this.#r.compressed) {
            this.#o.get("permessage-deflate").decompress(B, this.#r.fin, (Q, E) => {
              if (Q) {
                L(this.ws, 1007, Q.message, Q.message.length);
                return;
              }
              if (this.#i.push(E), !this.#r.fin) {
                this.#n = r.INFO, this.#s = !0, this.run(g);
                return;
              }
              f(this.ws, this.#r.binaryType, Buffer.concat(this.#i)), this.#s = !0, this.#n = r.INFO, this.#i.length = 0, this.run(g);
            }), this.#s = !1;
            break;
          } else {
            if (this.#i.push(B), !this.#r.fragmented && this.#r.fin) {
              const Q = Buffer.concat(this.#i);
              f(this.ws, this.#r.binaryType, Q), this.#i.length = 0;
            }
            this.#n = r.INFO;
          }
        }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer}
     */
    consume(g) {
      if (g > this.#t)
        throw new Error("Called consume() before buffers satiated.");
      if (g === 0)
        return i;
      if (this.#e[0].length === g)
        return this.#t -= this.#e[0].length, this.#e.shift();
      const B = Buffer.allocUnsafe(g);
      let Q = 0;
      for (; Q !== g; ) {
        const E = this.#e[0], { length: b } = E;
        if (b + Q === g) {
          B.set(this.#e.shift(), Q);
          break;
        } else if (b + Q > g) {
          B.set(E.subarray(0, g - Q), Q), this.#e[0] = E.subarray(g - Q);
          break;
        } else
          B.set(this.#e.shift(), Q), Q += E.length;
      }
      return this.#t -= g, B;
    }
    parseCloseBody(g) {
      e(g.length !== 1);
      let B;
      if (g.length >= 2 && (B = g.readUInt16BE(0)), B !== void 0 && !u(B))
        return { code: 1002, reason: "Invalid status code", error: !0 };
      let Q = g.subarray(2);
      Q[0] === 239 && Q[1] === 187 && Q[2] === 191 && (Q = Q.subarray(3));
      try {
        Q = p(Q);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: !0 };
      }
      return { code: B, reason: Q, error: !1 };
    }
    /**
     * Parses control frames.
     * @param {Buffer} body
     */
    parseControlFrame(g) {
      const { opcode: B, payloadLength: Q } = this.#r;
      if (B === n.CLOSE) {
        if (Q === 1)
          return h(this.ws, "Received close frame with a 1-byte body."), !1;
        if (this.#r.closeInfo = this.parseCloseBody(g), this.#r.closeInfo.error) {
          const { code: E, reason: b } = this.#r.closeInfo;
          return L(this.ws, E, b, b.length), h(this.ws, b), !1;
        }
        if (this.ws[A] !== o.SENT) {
          let E = i;
          this.#r.closeInfo.code && (E = Buffer.allocUnsafe(2), E.writeUInt16BE(this.#r.closeInfo.code, 0));
          const b = new D(E);
          this.ws[c].socket.write(
            b.createFrame(n.CLOSE),
            (N) => {
              N || (this.ws[A] = o.SENT);
            }
          );
        }
        return this.ws[a] = s.CLOSING, this.ws[l] = !0, !1;
      } else if (B === n.PING) {
        if (!this.ws[l]) {
          const E = new D(g);
          this.ws[c].socket.write(E.createFrame(n.PONG)), d.ping.hasSubscribers && d.ping.publish({
            payload: g
          });
        }
      } else B === n.PONG && d.pong.hasSubscribers && d.pong.publish({
        payload: g
      });
      return !0;
    }
    get closingInfo() {
      return this.#r.closeInfo;
    }
  }
  return yA = {
    ByteParser: I
  }, yA;
}
var QA, mm;
function hQ() {
  if (mm) return QA;
  mm = 1;
  const { WebsocketFrameSend: t } = xl(), { opcodes: e, sendHints: r } = Zn(), n = of(), s = Buffer[Symbol.species];
  class i {
    /**
     * @type {FixedQueue}
     */
    #e = new n();
    /**
     * @type {boolean}
     */
    #t = !1;
    /** @type {import('node:net').Socket} */
    #s;
    constructor(c) {
      this.#s = c;
    }
    add(c, l, d) {
      if (d !== r.blob) {
        const m = o(c, d);
        if (!this.#t)
          this.#s.write(m, l);
        else {
          const h = {
            promise: null,
            callback: l,
            frame: m
          };
          this.#e.push(h);
        }
        return;
      }
      const u = {
        promise: c.arrayBuffer().then((m) => {
          u.promise = null, u.frame = o(m, d);
        }),
        callback: l,
        frame: null
      };
      this.#e.push(u), this.#t || this.#n();
    }
    async #n() {
      this.#t = !0;
      const c = this.#e;
      for (; !c.isEmpty(); ) {
        const l = c.shift();
        l.promise !== null && await l.promise, this.#s.write(l.frame, l.callback), l.callback = l.frame = null;
      }
      this.#t = !1;
    }
  }
  function o(A, c) {
    return new t(a(A, c)).createFrame(c === r.string ? e.TEXT : e.BINARY);
  }
  function a(A, c) {
    switch (c) {
      case r.string:
        return Buffer.from(A);
      case r.arrayBuffer:
      case r.blob:
        return new s(A);
      case r.typedArray:
        return new s(A.buffer, A.byteOffset, A.byteLength);
    }
  }
  return QA = { SendQueue: i }, QA;
}
var NA, hm;
function gQ() {
  if (hm) return NA;
  hm = 1;
  const { webidl: t } = zt(), { URLSerializer: e } = or(), { environmentSettingsObject: r } = mr(), { staticPropertyDescriptors: n, states: s, sentCloseFrameState: i, sendHints: o } = Zn(), {
    kWebSocketURL: a,
    kReadyState: A,
    kController: c,
    kBinaryType: l,
    kResponse: d,
    kSentClose: u,
    kByteParser: m
  } = io(), {
    isConnecting: h,
    isEstablished: f,
    isClosing: p,
    isValidSubprotocol: y,
    fireEvent: w
  } = oo(), { establishWebSocketConnection: R, closeWebSocketConnection: D } = pf(), { ByteParser: L } = mQ(), { kEnumerableProperty: C, isBlobLike: I } = Xe(), { getGlobalDispatcher: x } = Nl(), { types: g } = _t, { ErrorEvent: B, CloseEvent: Q } = ri(), { SendQueue: E } = hQ();
  class b extends EventTarget {
    #e = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #t = 0;
    #s = "";
    #n = "";
    /** @type {SendQueue} */
    #r;
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(k, F = []) {
      super(), t.util.markAsUncloneable(this);
      const P = "WebSocket constructor";
      t.argumentLengthCheck(arguments, 1, P);
      const J = t.converters["DOMString or sequence<DOMString> or WebSocketInit"](F, P, "options");
      k = t.converters.USVString(k, P, "url"), F = J.protocols;
      const te = r.settingsObject.baseUrl;
      let ee;
      try {
        ee = new URL(k, te);
      } catch (ue) {
        throw new DOMException(ue, "SyntaxError");
      }
      if (ee.protocol === "http:" ? ee.protocol = "ws:" : ee.protocol === "https:" && (ee.protocol = "wss:"), ee.protocol !== "ws:" && ee.protocol !== "wss:")
        throw new DOMException(
          `Expected a ws: or wss: protocol, got ${ee.protocol}`,
          "SyntaxError"
        );
      if (ee.hash || ee.href.endsWith("#"))
        throw new DOMException("Got fragment", "SyntaxError");
      if (typeof F == "string" && (F = [F]), F.length !== new Set(F.map((ue) => ue.toLowerCase())).size)
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      if (F.length > 0 && !F.every((ue) => y(ue)))
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      this[a] = new URL(ee.href);
      const de = r.settingsObject;
      this[c] = R(
        ee,
        F,
        de,
        this,
        (ue, ce) => this.#i(ue, ce),
        J
      ), this[A] = b.CONNECTING, this[u] = i.NOT_SENT, this[l] = "blob";
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(k = void 0, F = void 0) {
      t.brandCheck(this, b);
      const P = "WebSocket.close";
      if (k !== void 0 && (k = t.converters["unsigned short"](k, P, "code", { clamp: !0 })), F !== void 0 && (F = t.converters.USVString(F, P, "reason")), k !== void 0 && k !== 1e3 && (k < 3e3 || k > 4999))
        throw new DOMException("invalid code", "InvalidAccessError");
      let J = 0;
      if (F !== void 0 && (J = Buffer.byteLength(F), J > 123))
        throw new DOMException(
          `Reason must be less than 123 bytes; received ${J}`,
          "SyntaxError"
        );
      D(this, k, F, J);
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(k) {
      t.brandCheck(this, b);
      const F = "WebSocket.send";
      if (t.argumentLengthCheck(arguments, 1, F), k = t.converters.WebSocketSendData(k, F, "data"), h(this))
        throw new DOMException("Sent before connected.", "InvalidStateError");
      if (!(!f(this) || p(this)))
        if (typeof k == "string") {
          const P = Buffer.byteLength(k);
          this.#t += P, this.#r.add(k, () => {
            this.#t -= P;
          }, o.string);
        } else g.isArrayBuffer(k) ? (this.#t += k.byteLength, this.#r.add(k, () => {
          this.#t -= k.byteLength;
        }, o.arrayBuffer)) : ArrayBuffer.isView(k) ? (this.#t += k.byteLength, this.#r.add(k, () => {
          this.#t -= k.byteLength;
        }, o.typedArray)) : I(k) && (this.#t += k.size, this.#r.add(k, () => {
          this.#t -= k.size;
        }, o.blob));
    }
    get readyState() {
      return t.brandCheck(this, b), this[A];
    }
    get bufferedAmount() {
      return t.brandCheck(this, b), this.#t;
    }
    get url() {
      return t.brandCheck(this, b), e(this[a]);
    }
    get extensions() {
      return t.brandCheck(this, b), this.#n;
    }
    get protocol() {
      return t.brandCheck(this, b), this.#s;
    }
    get onopen() {
      return t.brandCheck(this, b), this.#e.open;
    }
    set onopen(k) {
      t.brandCheck(this, b), this.#e.open && this.removeEventListener("open", this.#e.open), typeof k == "function" ? (this.#e.open = k, this.addEventListener("open", k)) : this.#e.open = null;
    }
    get onerror() {
      return t.brandCheck(this, b), this.#e.error;
    }
    set onerror(k) {
      t.brandCheck(this, b), this.#e.error && this.removeEventListener("error", this.#e.error), typeof k == "function" ? (this.#e.error = k, this.addEventListener("error", k)) : this.#e.error = null;
    }
    get onclose() {
      return t.brandCheck(this, b), this.#e.close;
    }
    set onclose(k) {
      t.brandCheck(this, b), this.#e.close && this.removeEventListener("close", this.#e.close), typeof k == "function" ? (this.#e.close = k, this.addEventListener("close", k)) : this.#e.close = null;
    }
    get onmessage() {
      return t.brandCheck(this, b), this.#e.message;
    }
    set onmessage(k) {
      t.brandCheck(this, b), this.#e.message && this.removeEventListener("message", this.#e.message), typeof k == "function" ? (this.#e.message = k, this.addEventListener("message", k)) : this.#e.message = null;
    }
    get binaryType() {
      return t.brandCheck(this, b), this[l];
    }
    set binaryType(k) {
      t.brandCheck(this, b), k !== "blob" && k !== "arraybuffer" ? this[l] = "blob" : this[l] = k;
    }
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    #i(k, F) {
      this[d] = k;
      const P = new L(this, F);
      P.on("drain", N), P.on("error", S.bind(this)), k.socket.ws = this, this[m] = P, this.#r = new E(k.socket), this[A] = s.OPEN;
      const J = k.headersList.get("sec-websocket-extensions");
      J !== null && (this.#n = J);
      const te = k.headersList.get("sec-websocket-protocol");
      te !== null && (this.#s = te), w("open", this);
    }
  }
  b.CONNECTING = b.prototype.CONNECTING = s.CONNECTING, b.OPEN = b.prototype.OPEN = s.OPEN, b.CLOSING = b.prototype.CLOSING = s.CLOSING, b.CLOSED = b.prototype.CLOSED = s.CLOSED, Object.defineProperties(b.prototype, {
    CONNECTING: n,
    OPEN: n,
    CLOSING: n,
    CLOSED: n,
    url: C,
    readyState: C,
    bufferedAmount: C,
    onopen: C,
    onerror: C,
    onclose: C,
    close: C,
    onmessage: C,
    binaryType: C,
    send: C,
    extensions: C,
    protocol: C,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  }), Object.defineProperties(b, {
    CONNECTING: n,
    OPEN: n,
    CLOSING: n,
    CLOSED: n
  }), t.converters["sequence<DOMString>"] = t.sequenceConverter(
    t.converters.DOMString
  ), t.converters["DOMString or sequence<DOMString>"] = function(M, k, F) {
    return t.util.Type(M) === "Object" && Symbol.iterator in M ? t.converters["sequence<DOMString>"](M) : t.converters.DOMString(M, k, F);
  }, t.converters.WebSocketInit = t.dictionaryConverter([
    {
      key: "protocols",
      converter: t.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => new Array(0)
    },
    {
      key: "dispatcher",
      converter: t.converters.any,
      defaultValue: () => x()
    },
    {
      key: "headers",
      converter: t.nullableConverter(t.converters.HeadersInit)
    }
  ]), t.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(M) {
    return t.util.Type(M) === "Object" && !(Symbol.iterator in M) ? t.converters.WebSocketInit(M) : { protocols: t.converters["DOMString or sequence<DOMString>"](M) };
  }, t.converters.WebSocketSendData = function(M) {
    if (t.util.Type(M) === "Object") {
      if (I(M))
        return t.converters.Blob(M, { strict: !1 });
      if (ArrayBuffer.isView(M) || g.isArrayBuffer(M))
        return t.converters.BufferSource(M);
    }
    return t.converters.USVString(M);
  };
  function N() {
    this.ws[d].socket.resume();
  }
  function S(M) {
    let k, F;
    M instanceof Q ? (k = M.reason, F = M.code) : k = M.message, w("error", this, () => new B("error", { error: M, message: k })), D(this, F);
  }
  return NA = {
    WebSocket: b
  }, NA;
}
var wA, gm;
function Ef() {
  if (gm) return wA;
  gm = 1;
  function t(n) {
    return n.indexOf("\0") === -1;
  }
  function e(n) {
    if (n.length === 0) return !1;
    for (let s = 0; s < n.length; s++)
      if (n.charCodeAt(s) < 48 || n.charCodeAt(s) > 57) return !1;
    return !0;
  }
  function r(n) {
    return new Promise((s) => {
      setTimeout(s, n).unref();
    });
  }
  return wA = {
    isValidLastEventId: t,
    isASCIINumber: e,
    delay: r
  }, wA;
}
var bA, fm;
function fQ() {
  if (fm) return bA;
  fm = 1;
  const { Transform: t } = dr, { isASCIINumber: e, isValidLastEventId: r } = Ef(), n = [239, 187, 191], s = 10, i = 13, o = 58, a = 32;
  class A extends t {
    /**
     * @type {eventSourceSettings}
     */
    state = null;
    /**
     * Leading byte-order-mark check.
     * @type {boolean}
     */
    checkBOM = !0;
    /**
     * @type {boolean}
     */
    crlfCheck = !1;
    /**
     * @type {boolean}
     */
    eventEndCheck = !1;
    /**
     * @type {Buffer}
     */
    buffer = null;
    pos = 0;
    event = {
      data: void 0,
      event: void 0,
      id: void 0,
      retry: void 0
    };
    /**
     * @param {object} options
     * @param {eventSourceSettings} options.eventSourceSettings
     * @param {Function} [options.push]
     */
    constructor(l = {}) {
      l.readableObjectMode = !0, super(l), this.state = l.eventSourceSettings || {}, l.push && (this.push = l.push);
    }
    /**
     * @param {Buffer} chunk
     * @param {string} _encoding
     * @param {Function} callback
     * @returns {void}
     */
    _transform(l, d, u) {
      if (l.length === 0) {
        u();
        return;
      }
      if (this.buffer ? this.buffer = Buffer.concat([this.buffer, l]) : this.buffer = l, this.checkBOM)
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === n[0]) {
              u();
              return;
            }
            this.checkBOM = !1, u();
            return;
          case 2:
            if (this.buffer[0] === n[0] && this.buffer[1] === n[1]) {
              u();
              return;
            }
            this.checkBOM = !1;
            break;
          case 3:
            if (this.buffer[0] === n[0] && this.buffer[1] === n[1] && this.buffer[2] === n[2]) {
              this.buffer = Buffer.alloc(0), this.checkBOM = !1, u();
              return;
            }
            this.checkBOM = !1;
            break;
          default:
            this.buffer[0] === n[0] && this.buffer[1] === n[1] && this.buffer[2] === n[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = !1;
            break;
        }
      for (; this.pos < this.buffer.length; ) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === s) {
              this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = !1;
              continue;
            }
            this.crlfCheck = !1;
          }
          if (this.buffer[this.pos] === s || this.buffer[this.pos] === i) {
            this.buffer[this.pos] === i && (this.crlfCheck = !0), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
            continue;
          }
          this.eventEndCheck = !1;
          continue;
        }
        if (this.buffer[this.pos] === s || this.buffer[this.pos] === i) {
          this.buffer[this.pos] === i && (this.crlfCheck = !0), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = !0;
          continue;
        }
        this.pos++;
      }
      u();
    }
    /**
     * @param {Buffer} line
     * @param {EventStreamEvent} event
     */
    parseLine(l, d) {
      if (l.length === 0)
        return;
      const u = l.indexOf(o);
      if (u === 0)
        return;
      let m = "", h = "";
      if (u !== -1) {
        m = l.subarray(0, u).toString("utf8");
        let f = u + 1;
        l[f] === a && ++f, h = l.subarray(f).toString("utf8");
      } else
        m = l.toString("utf8"), h = "";
      switch (m) {
        case "data":
          d[m] === void 0 ? d[m] = h : d[m] += `
${h}`;
          break;
        case "retry":
          e(h) && (d[m] = h);
          break;
        case "id":
          r(h) && (d[m] = h);
          break;
        case "event":
          h.length > 0 && (d[m] = h);
          break;
      }
    }
    /**
     * @param {EventSourceStreamEvent} event
     */
    processEvent(l) {
      l.retry && e(l.retry) && (this.state.reconnectionTime = parseInt(l.retry, 10)), l.id && r(l.id) && (this.state.lastEventId = l.id), l.data !== void 0 && this.push({
        type: l.event || "message",
        options: {
          data: l.data,
          lastEventId: this.state.lastEventId,
          origin: this.state.origin
        }
      });
    }
    clearEvent() {
      this.event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
    }
  }
  return bA = {
    EventSourceStream: A
  }, bA;
}
var xA, pm;
function pQ() {
  if (pm) return xA;
  pm = 1;
  const { pipeline: t } = dr, { fetching: e } = so(), { makeRequest: r } = ti(), { webidl: n } = zt(), { EventSourceStream: s } = fQ(), { parseMIMEType: i } = or(), { createFastMessageEvent: o } = ri(), { isNetworkError: a } = no(), { delay: A } = Ef(), { kEnumerableProperty: c } = Xe(), { environmentSettingsObject: l } = mr();
  let d = !1;
  const u = 3e3, m = 0, h = 1, f = 2, p = "anonymous", y = "use-credentials";
  class w extends EventTarget {
    #e = {
      open: null,
      error: null,
      message: null
    };
    #t = null;
    #s = !1;
    #n = m;
    #r = null;
    #i = null;
    #o;
    /**
     * @type {import('./eventsource-stream').eventSourceSettings}
     */
    #a;
    /**
     * Creates a new EventSource object.
     * @param {string} url
     * @param {EventSourceInit} [eventSourceInitDict]
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
     */
    constructor(L, C = {}) {
      super(), n.util.markAsUncloneable(this);
      const I = "EventSource constructor";
      n.argumentLengthCheck(arguments, 1, I), d || (d = !0, process.emitWarning("EventSource is experimental, expect them to change at any time.", {
        code: "UNDICI-ES"
      })), L = n.converters.USVString(L, I, "url"), C = n.converters.EventSourceInitDict(C, I, "eventSourceInitDict"), this.#o = C.dispatcher, this.#a = {
        lastEventId: "",
        reconnectionTime: u
      };
      const x = l;
      let g;
      try {
        g = new URL(L, x.settingsObject.baseUrl), this.#a.origin = g.origin;
      } catch (E) {
        throw new DOMException(E, "SyntaxError");
      }
      this.#t = g.href;
      let B = p;
      C.withCredentials && (B = y, this.#s = !0);
      const Q = {
        redirect: "follow",
        keepalive: !0,
        // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
        mode: "cors",
        credentials: B === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      Q.client = l.settingsObject, Q.headersList = [["accept", { name: "accept", value: "text/event-stream" }]], Q.cache = "no-store", Q.initiator = "other", Q.urlList = [new URL(this.#t)], this.#r = r(Q), this.#A();
    }
    /**
     * Returns the state of this EventSource object's connection. It can have the
     * values described below.
     * @returns {0|1|2}
     * @readonly
     */
    get readyState() {
      return this.#n;
    }
    /**
     * Returns the URL providing the event stream.
     * @readonly
     * @returns {string}
     */
    get url() {
      return this.#t;
    }
    /**
     * Returns a boolean indicating whether the EventSource object was
     * instantiated with CORS credentials set (true), or not (false, the default).
     */
    get withCredentials() {
      return this.#s;
    }
    #A() {
      if (this.#n === f) return;
      this.#n = m;
      const L = {
        request: this.#r,
        dispatcher: this.#o
      }, C = (I) => {
        a(I) && (this.dispatchEvent(new Event("error")), this.close()), this.#c();
      };
      L.processResponseEndOfBody = C, L.processResponse = (I) => {
        if (a(I))
          if (I.aborted) {
            this.close(), this.dispatchEvent(new Event("error"));
            return;
          } else {
            this.#c();
            return;
          }
        const x = I.headersList.get("content-type", !0), g = x !== null ? i(x) : "failure", B = g !== "failure" && g.essence === "text/event-stream";
        if (I.status !== 200 || B === !1) {
          this.close(), this.dispatchEvent(new Event("error"));
          return;
        }
        this.#n = h, this.dispatchEvent(new Event("open")), this.#a.origin = I.urlList[I.urlList.length - 1].origin;
        const Q = new s({
          eventSourceSettings: this.#a,
          push: (E) => {
            this.dispatchEvent(o(
              E.type,
              E.options
            ));
          }
        });
        t(
          I.body.stream,
          Q,
          (E) => {
            E?.aborted === !1 && (this.close(), this.dispatchEvent(new Event("error")));
          }
        );
      }, this.#i = e(L);
    }
    /**
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
     * @returns {Promise<void>}
     */
    async #c() {
      this.#n !== f && (this.#n = m, this.dispatchEvent(new Event("error")), await A(this.#a.reconnectionTime), this.#n === m && (this.#a.lastEventId.length && this.#r.headersList.set("last-event-id", this.#a.lastEventId, !0), this.#A()));
    }
    /**
     * Closes the connection, if any, and sets the readyState attribute to
     * CLOSED.
     */
    close() {
      n.brandCheck(this, w), this.#n !== f && (this.#n = f, this.#i.abort(), this.#r = null);
    }
    get onopen() {
      return this.#e.open;
    }
    set onopen(L) {
      this.#e.open && this.removeEventListener("open", this.#e.open), typeof L == "function" ? (this.#e.open = L, this.addEventListener("open", L)) : this.#e.open = null;
    }
    get onmessage() {
      return this.#e.message;
    }
    set onmessage(L) {
      this.#e.message && this.removeEventListener("message", this.#e.message), typeof L == "function" ? (this.#e.message = L, this.addEventListener("message", L)) : this.#e.message = null;
    }
    get onerror() {
      return this.#e.error;
    }
    set onerror(L) {
      this.#e.error && this.removeEventListener("error", this.#e.error), typeof L == "function" ? (this.#e.error = L, this.addEventListener("error", L)) : this.#e.error = null;
    }
  }
  const R = {
    CONNECTING: {
      __proto__: null,
      configurable: !1,
      enumerable: !0,
      value: m,
      writable: !1
    },
    OPEN: {
      __proto__: null,
      configurable: !1,
      enumerable: !0,
      value: h,
      writable: !1
    },
    CLOSED: {
      __proto__: null,
      configurable: !1,
      enumerable: !0,
      value: f,
      writable: !1
    }
  };
  return Object.defineProperties(w, R), Object.defineProperties(w.prototype, R), Object.defineProperties(w.prototype, {
    close: c,
    onerror: c,
    onmessage: c,
    onopen: c,
    readyState: c,
    url: c,
    withCredentials: c
  }), n.converters.EventSourceInitDict = n.dictionaryConverter([
    {
      key: "withCredentials",
      converter: n.converters.boolean,
      defaultValue: () => !1
    },
    {
      key: "dispatcher",
      // undici only
      converter: n.converters.any
    }
  ]), xA = {
    EventSource: w,
    defaultReconnectionTime: u
  }, xA;
}
var Em;
function EQ() {
  if (Em) return Fe;
  Em = 1;
  const t = Zs(), e = Zi(), r = Ks(), n = Hy(), s = js(), i = Af(), o = Oy(), a = zy(), A = it(), c = Xe(), { InvalidArgumentError: l } = A, d = _y(), u = Ki(), m = mf(), h = Xy(), f = hf(), p = df(), y = Ql(), { getGlobalDispatcher: w, setGlobalDispatcher: R } = Nl(), D = wl(), L = Il(), C = yl();
  Object.assign(e.prototype, d), Fe.Dispatcher = e, Fe.Client = t, Fe.Pool = r, Fe.BalancedPool = n, Fe.Agent = s, Fe.ProxyAgent = i, Fe.EnvHttpProxyAgent = o, Fe.RetryAgent = a, Fe.RetryHandler = y, Fe.DecoratorHandler = D, Fe.RedirectHandler = L, Fe.createRedirectInterceptor = C, Fe.interceptors = {
    redirect: Zy(),
    retry: Ky(),
    dump: jy(),
    dns: eQ()
  }, Fe.buildConnector = u, Fe.errors = A, Fe.util = {
    parseHeaders: c.parseHeaders,
    headerNameToString: c.headerNameToString
  };
  function I(de) {
    return (ue, ce, fe) => {
      if (typeof ce == "function" && (fe = ce, ce = null), !ue || typeof ue != "string" && typeof ue != "object" && !(ue instanceof URL))
        throw new l("invalid url");
      if (ce != null && typeof ce != "object")
        throw new l("invalid opts");
      if (ce && ce.path != null) {
        if (typeof ce.path != "string")
          throw new l("invalid opts.path");
        let _ = ce.path;
        ce.path.startsWith("/") || (_ = `/${_}`), ue = new URL(c.parseOrigin(ue).origin + _);
      } else
        ce || (ce = typeof ue == "object" ? ue : {}), ue = c.parseURL(ue);
      const { agent: Ce, dispatcher: Z = w() } = ce;
      if (Ce)
        throw new l("unsupported opts.agent. Did you mean opts.client?");
      return de.call(Z, {
        ...ce,
        origin: ue.origin,
        path: ue.search ? `${ue.pathname}${ue.search}` : ue.pathname,
        method: ce.method || (ce.body ? "PUT" : "GET")
      }, fe);
    };
  }
  Fe.setGlobalDispatcher = R, Fe.getGlobalDispatcher = w;
  const x = so().fetch;
  Fe.fetch = async function(ue, ce = void 0) {
    try {
      return await x(ue, ce);
    } catch (fe) {
      throw fe && typeof fe == "object" && Error.captureStackTrace(fe), fe;
    }
  }, Fe.Headers = Xn().Headers, Fe.Response = no().Response, Fe.Request = ti().Request, Fe.FormData = eo().FormData, Fe.File = globalThis.File ?? ur.File, Fe.FileReader = iQ().FileReader;
  const { setGlobalOrigin: g, getGlobalOrigin: B } = nf();
  Fe.setGlobalOrigin = g, Fe.getGlobalOrigin = B;
  const { CacheStorage: Q } = AQ(), { kConstruct: E } = bl();
  Fe.caches = new Q(E);
  const { deleteCookie: b, getCookies: N, getSetCookies: S, setCookie: M } = dQ();
  Fe.deleteCookie = b, Fe.getCookies = N, Fe.getSetCookies = S, Fe.setCookie = M;
  const { parseMIMEType: k, serializeAMimeType: F } = or();
  Fe.parseMIMEType = k, Fe.serializeAMimeType = F;
  const { CloseEvent: P, ErrorEvent: J, MessageEvent: te } = ri();
  Fe.WebSocket = gQ().WebSocket, Fe.CloseEvent = P, Fe.ErrorEvent = J, Fe.MessageEvent = te, Fe.request = I(d.request), Fe.stream = I(d.stream), Fe.pipeline = I(d.pipeline), Fe.connect = I(d.connect), Fe.upgrade = I(d.upgrade), Fe.MockClient = m, Fe.MockPool = f, Fe.MockAgent = h, Fe.mockErrors = p;
  const { EventSource: ee } = pQ();
  return Fe.EventSource = ee, Fe;
}
var CQ = EQ(), pt = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
}, Qt;
(function(t) {
  t[t.OK = 200] = "OK", t[t.MultipleChoices = 300] = "MultipleChoices", t[t.MovedPermanently = 301] = "MovedPermanently", t[t.ResourceMoved = 302] = "ResourceMoved", t[t.SeeOther = 303] = "SeeOther", t[t.NotModified = 304] = "NotModified", t[t.UseProxy = 305] = "UseProxy", t[t.SwitchProxy = 306] = "SwitchProxy", t[t.TemporaryRedirect = 307] = "TemporaryRedirect", t[t.PermanentRedirect = 308] = "PermanentRedirect", t[t.BadRequest = 400] = "BadRequest", t[t.Unauthorized = 401] = "Unauthorized", t[t.PaymentRequired = 402] = "PaymentRequired", t[t.Forbidden = 403] = "Forbidden", t[t.NotFound = 404] = "NotFound", t[t.MethodNotAllowed = 405] = "MethodNotAllowed", t[t.NotAcceptable = 406] = "NotAcceptable", t[t.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", t[t.RequestTimeout = 408] = "RequestTimeout", t[t.Conflict = 409] = "Conflict", t[t.Gone = 410] = "Gone", t[t.TooManyRequests = 429] = "TooManyRequests", t[t.InternalServerError = 500] = "InternalServerError", t[t.NotImplemented = 501] = "NotImplemented", t[t.BadGateway = 502] = "BadGateway", t[t.ServiceUnavailable = 503] = "ServiceUnavailable", t[t.GatewayTimeout = 504] = "GatewayTimeout";
})(Qt || (Qt = {}));
var Jt;
(function(t) {
  t.Accept = "accept", t.ContentType = "content-type";
})(Jt || (Jt = {}));
var Lr;
(function(t) {
  t.ApplicationJson = "application/json";
})(Lr || (Lr = {}));
const BQ = [
  Qt.MovedPermanently,
  Qt.ResourceMoved,
  Qt.SeeOther,
  Qt.TemporaryRedirect,
  Qt.PermanentRedirect
], IQ = [
  Qt.BadGateway,
  Qt.ServiceUnavailable,
  Qt.GatewayTimeout
], yQ = ["OPTIONS", "GET", "DELETE", "HEAD"], QQ = 10, NQ = 5;
class en extends Error {
  constructor(e, r) {
    super(e), this.name = "HttpClientError", this.statusCode = r, Object.setPrototypeOf(this, en.prototype);
  }
}
class wQ {
  constructor(e) {
    this.message = e;
  }
  readBody() {
    return pt(this, void 0, void 0, function* () {
      return new Promise((e) => pt(this, void 0, void 0, function* () {
        let r = Buffer.alloc(0);
        this.message.on("data", (n) => {
          r = Buffer.concat([r, n]);
        }), this.message.on("end", () => {
          e(r.toString());
        });
      }));
    });
  }
  readBodyBuffer() {
    return pt(this, void 0, void 0, function* () {
      return new Promise((e) => pt(this, void 0, void 0, function* () {
        const r = [];
        this.message.on("data", (n) => {
          r.push(n);
        }), this.message.on("end", () => {
          e(Buffer.concat(r));
        });
      }));
    });
  }
}
class Kn {
  constructor(e, r, n) {
    this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = this._getUserAgentWithOrchestrationId(e), this.handlers = r || [], this.requestOptions = n, n && (n.ignoreSslError != null && (this._ignoreSslError = n.ignoreSslError), this._socketTimeout = n.socketTimeout, n.allowRedirects != null && (this._allowRedirects = n.allowRedirects), n.allowRedirectDowngrade != null && (this._allowRedirectDowngrade = n.allowRedirectDowngrade), n.maxRedirects != null && (this._maxRedirects = Math.max(n.maxRedirects, 0)), n.keepAlive != null && (this._keepAlive = n.keepAlive), n.allowRetries != null && (this._allowRetries = n.allowRetries), n.maxRetries != null && (this._maxRetries = n.maxRetries));
  }
  options(e, r) {
    return pt(this, void 0, void 0, function* () {
      return this.request("OPTIONS", e, null, r || {});
    });
  }
  get(e, r) {
    return pt(this, void 0, void 0, function* () {
      return this.request("GET", e, null, r || {});
    });
  }
  del(e, r) {
    return pt(this, void 0, void 0, function* () {
      return this.request("DELETE", e, null, r || {});
    });
  }
  post(e, r, n) {
    return pt(this, void 0, void 0, function* () {
      return this.request("POST", e, r, n || {});
    });
  }
  patch(e, r, n) {
    return pt(this, void 0, void 0, function* () {
      return this.request("PATCH", e, r, n || {});
    });
  }
  put(e, r, n) {
    return pt(this, void 0, void 0, function* () {
      return this.request("PUT", e, r, n || {});
    });
  }
  head(e, r) {
    return pt(this, void 0, void 0, function* () {
      return this.request("HEAD", e, null, r || {});
    });
  }
  sendStream(e, r, n, s) {
    return pt(this, void 0, void 0, function* () {
      return this.request(e, r, n, s);
    });
  }
  /**
   * Gets a typed object from an endpoint
   * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
   */
  getJson(e) {
    return pt(this, arguments, void 0, function* (r, n = {}) {
      n[Jt.Accept] = this._getExistingOrDefaultHeader(n, Jt.Accept, Lr.ApplicationJson);
      const s = yield this.get(r, n);
      return this._processResponse(s, this.requestOptions);
    });
  }
  postJson(e, r) {
    return pt(this, arguments, void 0, function* (n, s, i = {}) {
      const o = JSON.stringify(s, null, 2);
      i[Jt.Accept] = this._getExistingOrDefaultHeader(i, Jt.Accept, Lr.ApplicationJson), i[Jt.ContentType] = this._getExistingOrDefaultContentTypeHeader(i, Lr.ApplicationJson);
      const a = yield this.post(n, o, i);
      return this._processResponse(a, this.requestOptions);
    });
  }
  putJson(e, r) {
    return pt(this, arguments, void 0, function* (n, s, i = {}) {
      const o = JSON.stringify(s, null, 2);
      i[Jt.Accept] = this._getExistingOrDefaultHeader(i, Jt.Accept, Lr.ApplicationJson), i[Jt.ContentType] = this._getExistingOrDefaultContentTypeHeader(i, Lr.ApplicationJson);
      const a = yield this.put(n, o, i);
      return this._processResponse(a, this.requestOptions);
    });
  }
  patchJson(e, r) {
    return pt(this, arguments, void 0, function* (n, s, i = {}) {
      const o = JSON.stringify(s, null, 2);
      i[Jt.Accept] = this._getExistingOrDefaultHeader(i, Jt.Accept, Lr.ApplicationJson), i[Jt.ContentType] = this._getExistingOrDefaultContentTypeHeader(i, Lr.ApplicationJson);
      const a = yield this.patch(n, o, i);
      return this._processResponse(a, this.requestOptions);
    });
  }
  /**
   * Makes a raw http request.
   * All other methods such as get, post, patch, and request ultimately call this.
   * Prefer get, del, post and patch
   */
  request(e, r, n, s) {
    return pt(this, void 0, void 0, function* () {
      if (this._disposed)
        throw new Error("Client has already been disposed.");
      const i = new URL(r);
      let o = this._prepareRequest(e, i, s);
      const a = this._allowRetries && yQ.includes(e) ? this._maxRetries + 1 : 1;
      let A = 0, c;
      do {
        if (c = yield this.requestRaw(o, n), c && c.message && c.message.statusCode === Qt.Unauthorized) {
          let d;
          for (const u of this.handlers)
            if (u.canHandleAuthentication(c)) {
              d = u;
              break;
            }
          return d ? d.handleAuthentication(this, o, n) : c;
        }
        let l = this._maxRedirects;
        for (; c.message.statusCode && BQ.includes(c.message.statusCode) && this._allowRedirects && l > 0; ) {
          const d = c.message.headers.location;
          if (!d)
            break;
          const u = new URL(d);
          if (i.protocol === "https:" && i.protocol !== u.protocol && !this._allowRedirectDowngrade)
            throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
          if (yield c.readBody(), u.hostname !== i.hostname)
            for (const m in s)
              m.toLowerCase() === "authorization" && delete s[m];
          o = this._prepareRequest(e, u, s), c = yield this.requestRaw(o, n), l--;
        }
        if (!c.message.statusCode || !IQ.includes(c.message.statusCode))
          return c;
        A += 1, A < a && (yield c.readBody(), yield this._performExponentialBackoff(A));
      } while (A < a);
      return c;
    });
  }
  /**
   * Needs to be called if keepAlive is set to true in request options.
   */
  dispose() {
    this._agent && this._agent.destroy(), this._disposed = !0;
  }
  /**
   * Raw request.
   * @param info
   * @param data
   */
  requestRaw(e, r) {
    return pt(this, void 0, void 0, function* () {
      return new Promise((n, s) => {
        function i(o, a) {
          o ? s(o) : a ? n(a) : s(new Error("Unknown error"));
        }
        this.requestRawWithCallback(e, r, i);
      });
    });
  }
  /**
   * Raw request with callback.
   * @param info
   * @param data
   * @param onResult
   */
  requestRawWithCallback(e, r, n) {
    typeof r == "string" && (e.options.headers || (e.options.headers = {}), e.options.headers["Content-Length"] = Buffer.byteLength(r, "utf8"));
    let s = !1;
    function i(A, c) {
      s || (s = !0, n(A, c));
    }
    const o = e.httpModule.request(e.options, (A) => {
      const c = new wQ(A);
      i(void 0, c);
    });
    let a;
    o.on("socket", (A) => {
      a = A;
    }), o.setTimeout(this._socketTimeout || 3 * 6e4, () => {
      a && a.end(), i(new Error(`Request timeout: ${e.options.path}`));
    }), o.on("error", function(A) {
      i(A);
    }), r && typeof r == "string" && o.write(r, "utf8"), r && typeof r != "string" ? (r.on("close", function() {
      o.end();
    }), r.pipe(o)) : o.end();
  }
  /**
   * Gets an http agent. This function is useful when you need an http agent that handles
   * routing through a proxy server - depending upon the url and proxy environment variables.
   * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
   */
  getAgent(e) {
    const r = new URL(e);
    return this._getAgent(r);
  }
  getAgentDispatcher(e) {
    const r = new URL(e), n = wd(r);
    if (n && n.hostname)
      return this._getProxyAgentDispatcher(r, n);
  }
  _prepareRequest(e, r, n) {
    const s = {};
    s.parsedUrl = r;
    const i = s.parsedUrl.protocol === "https:";
    s.httpModule = i ? Qd : zo;
    const o = i ? 443 : 80;
    if (s.options = {}, s.options.host = s.parsedUrl.hostname, s.options.port = s.parsedUrl.port ? parseInt(s.parsedUrl.port) : o, s.options.path = (s.parsedUrl.pathname || "") + (s.parsedUrl.search || ""), s.options.method = e, s.options.headers = this._mergeHeaders(n), this.userAgent != null && (s.options.headers["user-agent"] = this.userAgent), s.options.agent = this._getAgent(s.parsedUrl), this.handlers)
      for (const a of this.handlers)
        a.prepareRequest(s.options);
    return s;
  }
  _mergeHeaders(e) {
    return this.requestOptions && this.requestOptions.headers ? Object.assign({}, ws(this.requestOptions.headers), ws(e || {})) : ws(e || {});
  }
  /**
   * Gets an existing header value or returns a default.
   * Handles converting number header values to strings since HTTP headers must be strings.
   * Note: This returns string | string[] since some headers can have multiple values.
   * For headers that must always be a single string (like Content-Type), use the
   * specialized _getExistingOrDefaultContentTypeHeader method instead.
   */
  _getExistingOrDefaultHeader(e, r, n) {
    let s;
    if (this.requestOptions && this.requestOptions.headers) {
      const o = ws(this.requestOptions.headers)[r];
      o && (s = typeof o == "number" ? o.toString() : o);
    }
    const i = e[r];
    return i !== void 0 ? typeof i == "number" ? i.toString() : i : s !== void 0 ? s : n;
  }
  /**
   * Specialized version of _getExistingOrDefaultHeader for Content-Type header.
   * Always returns a single string (not an array) since Content-Type should be a single value.
   * Converts arrays to comma-separated strings and numbers to strings to ensure type safety.
   * This was split from _getExistingOrDefaultHeader to provide stricter typing for callers
   * that assign the result to places expecting a string (e.g., additionalHeaders[Headers.ContentType]).
   */
  _getExistingOrDefaultContentTypeHeader(e, r) {
    let n;
    if (this.requestOptions && this.requestOptions.headers) {
      const i = ws(this.requestOptions.headers)[Jt.ContentType];
      i && (typeof i == "number" ? n = String(i) : Array.isArray(i) ? n = i.join(", ") : n = i);
    }
    const s = e[Jt.ContentType];
    return s !== void 0 ? typeof s == "number" ? String(s) : Array.isArray(s) ? s.join(", ") : s : n !== void 0 ? n : r;
  }
  _getAgent(e) {
    let r;
    const n = wd(e), s = n && n.hostname;
    if (this._keepAlive && s && (r = this._proxyAgent), s || (r = this._agent), r)
      return r;
    const i = e.protocol === "https:";
    let o = 100;
    if (this.requestOptions && (o = this.requestOptions.maxSockets || zo.globalAgent.maxSockets), n && n.hostname) {
      const a = {
        maxSockets: o,
        keepAlive: this._keepAlive,
        proxy: Object.assign(Object.assign({}, (n.username || n.password) && {
          proxyAuth: `${n.username}:${n.password}`
        }), { host: n.hostname, port: n.port })
      };
      let A;
      const c = n.protocol === "https:";
      i ? A = c ? fi.httpsOverHttps : fi.httpsOverHttp : A = c ? fi.httpOverHttps : fi.httpOverHttp, r = A(a), this._proxyAgent = r;
    }
    if (!r) {
      const a = { keepAlive: this._keepAlive, maxSockets: o };
      r = i ? new Qd.Agent(a) : new zo.Agent(a), this._agent = r;
    }
    return i && this._ignoreSslError && (r.options = Object.assign(r.options || {}, {
      rejectUnauthorized: !1
    })), r;
  }
  _getProxyAgentDispatcher(e, r) {
    let n;
    if (this._keepAlive && (n = this._proxyAgentDispatcher), n)
      return n;
    const s = e.protocol === "https:";
    return n = new CQ.ProxyAgent(Object.assign({ uri: r.href, pipelining: this._keepAlive ? 1 : 0 }, (r.username || r.password) && {
      token: `Basic ${Buffer.from(`${r.username}:${r.password}`).toString("base64")}`
    })), this._proxyAgentDispatcher = n, s && this._ignoreSslError && (n.options = Object.assign(n.options.requestTls || {}, {
      rejectUnauthorized: !1
    })), n;
  }
  _getUserAgentWithOrchestrationId(e) {
    const r = e || "actions/http-client", n = process.env.ACTIONS_ORCHESTRATION_ID;
    if (n) {
      const s = n.replace(/[^a-z0-9_.-]/gi, "_");
      return `${r} actions_orchestration_id/${s}`;
    }
    return r;
  }
  _performExponentialBackoff(e) {
    return pt(this, void 0, void 0, function* () {
      e = Math.min(QQ, e);
      const r = NQ * Math.pow(2, e);
      return new Promise((n) => setTimeout(() => n(), r));
    });
  }
  _processResponse(e, r) {
    return pt(this, void 0, void 0, function* () {
      return new Promise((n, s) => pt(this, void 0, void 0, function* () {
        const i = e.message.statusCode || 0, o = {
          statusCode: i,
          result: null,
          headers: {}
        };
        i === Qt.NotFound && n(o);
        function a(l, d) {
          if (typeof d == "string") {
            const u = new Date(d);
            if (!isNaN(u.valueOf()))
              return u;
          }
          return d;
        }
        let A, c;
        try {
          c = yield e.readBody(), c && c.length > 0 && (r && r.deserializeDates ? A = JSON.parse(c, a) : A = JSON.parse(c), o.result = A), o.headers = e.message.headers;
        } catch {
        }
        if (i > 299) {
          let l;
          A && A.message ? l = A.message : c && c.length > 0 ? l = c : l = `Failed request: (${i})`;
          const d = new en(l, i);
          d.result = o.result, s(d);
        } else
          n(o);
      }));
    });
  }
}
const ws = (t) => Object.keys(t).reduce((e, r) => (e[r.toLowerCase()] = t[r], e), {});
var bQ = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
class Cf {
  constructor(e) {
    this.token = e;
  }
  // currently implements pre-authorization
  // TODO: support preAuth = false where it hooks on 401
  prepareRequest(e) {
    if (!e.headers)
      throw Error("The request has no headers");
    e.headers.Authorization = `Bearer ${this.token}`;
  }
  // This handler cannot handle 401
  canHandleAuthentication() {
    return !1;
  }
  handleAuthentication() {
    return bQ(this, void 0, void 0, function* () {
      throw new Error("not implemented");
    });
  }
}
const { access: eL, appendFile: tL, writeFile: rL } = ry;
var Rl = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
const { chmod: Bf, copyFile: xQ, lstat: Hc, mkdir: RQ, open: nL, readdir: If, rename: sL, rm: SQ, rmdir: iL, stat: Vn, symlink: DQ, unlink: Cm } = tt.promises, zr = process.platform === "win32";
function kQ(t) {
  return Rl(this, void 0, void 0, function* () {
    const e = yield tt.promises.readlink(t);
    return zr && !e.endsWith("\\") ? `${e}\\` : e;
  });
}
tt.constants.O_RDONLY;
function vi(t) {
  return Rl(this, void 0, void 0, function* () {
    try {
      yield Vn(t);
    } catch (e) {
      if (e.code === "ENOENT")
        return !1;
      throw e;
    }
    return !0;
  });
}
function yf(t) {
  if (t = MQ(t), !t)
    throw new Error('isRooted() parameter "p" cannot be empty');
  return zr ? t.startsWith("\\") || /^[A-Z]:/i.test(t) : t.startsWith("/");
}
function Bm(t, e) {
  return Rl(this, void 0, void 0, function* () {
    let r;
    try {
      r = yield Vn(t);
    } catch (s) {
      s.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${t}': ${s}`);
    }
    if (r && r.isFile()) {
      if (zr) {
        const s = De.extname(t).toUpperCase();
        if (e.some((i) => i.toUpperCase() === s))
          return t;
      } else if (Im(r))
        return t;
    }
    const n = t;
    for (const s of e) {
      t = n + s, r = void 0;
      try {
        r = yield Vn(t);
      } catch (i) {
        i.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${t}': ${i}`);
      }
      if (r && r.isFile()) {
        if (zr) {
          try {
            const i = De.dirname(t), o = De.basename(t).toUpperCase();
            for (const a of yield If(i))
              if (o === a.toUpperCase()) {
                t = De.join(i, a);
                break;
              }
          } catch (i) {
            console.log(`Unexpected error attempting to determine the actual case of the file '${t}': ${i}`);
          }
          return t;
        } else if (Im(r))
          return t;
      }
    }
    return "";
  });
}
function MQ(t) {
  return t = t || "", zr ? (t = t.replace(/\//g, "\\"), t.replace(/\\\\+/g, "\\")) : t.replace(/\/\/+/g, "/");
}
function Im(t) {
  return (t.mode & 1) > 0 || (t.mode & 8) > 0 && process.getgid !== void 0 && t.gid === process.getgid() || (t.mode & 64) > 0 && process.getuid !== void 0 && t.uid === process.getuid();
}
var Rn = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
function TQ(t, e) {
  return Rn(this, arguments, void 0, function* (r, n, s = {}) {
    const { force: i, recursive: o, copySourceDirectory: a } = vQ(s), A = (yield vi(n)) ? yield Vn(n) : null;
    if (A && A.isFile() && !i)
      return;
    const c = A && A.isDirectory() && a ? De.join(n, De.basename(r)) : n;
    if (!(yield vi(r)))
      throw new Error(`no such file or directory: ${r}`);
    if ((yield Vn(r)).isDirectory())
      if (o)
        yield Qf(r, c, 0, i);
      else
        throw new Error(`Failed to copy. ${r} is a directory, but tried to copy without recursive flag.`);
    else {
      if (De.relative(r, c) === "")
        throw new Error(`'${c}' and '${r}' are the same file`);
      yield Nf(r, c, i);
    }
  });
}
function Oc(t) {
  return Rn(this, void 0, void 0, function* () {
    if (zr && /[*"<>|]/.test(t))
      throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
    try {
      yield SQ(t, {
        force: !0,
        maxRetries: 3,
        recursive: !0,
        retryDelay: 300
      });
    } catch (e) {
      throw new Error(`File was unable to be removed ${e}`);
    }
  });
}
function jn(t) {
  return Rn(this, void 0, void 0, function* () {
    Ps(t, "a path argument must be provided"), yield RQ(t, { recursive: !0 });
  });
}
function br(t, e) {
  return Rn(this, void 0, void 0, function* () {
    if (!t)
      throw new Error("parameter 'tool' is required");
    if (e) {
      const n = yield br(t, !1);
      if (!n)
        throw zr ? new Error(`Unable to locate executable file: ${t}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`) : new Error(`Unable to locate executable file: ${t}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
      return n;
    }
    const r = yield FQ(t);
    return r && r.length > 0 ? r[0] : "";
  });
}
function FQ(t) {
  return Rn(this, void 0, void 0, function* () {
    if (!t)
      throw new Error("parameter 'tool' is required");
    const e = [];
    if (zr && process.env.PATHEXT)
      for (const s of process.env.PATHEXT.split(De.delimiter))
        s && e.push(s);
    if (yf(t)) {
      const s = yield Bm(t, e);
      return s ? [s] : [];
    }
    if (t.includes(De.sep))
      return [];
    const r = [];
    if (process.env.PATH)
      for (const s of process.env.PATH.split(De.delimiter))
        s && r.push(s);
    const n = [];
    for (const s of r) {
      const i = yield Bm(De.join(s, t), e);
      i && n.push(i);
    }
    return n;
  });
}
function vQ(t) {
  const e = t.force == null ? !0 : t.force, r = !!t.recursive, n = t.copySourceDirectory == null ? !0 : !!t.copySourceDirectory;
  return { force: e, recursive: r, copySourceDirectory: n };
}
function Qf(t, e, r, n) {
  return Rn(this, void 0, void 0, function* () {
    if (r >= 255)
      return;
    r++, yield jn(e);
    const s = yield If(t);
    for (const i of s) {
      const o = `${t}/${i}`, a = `${e}/${i}`;
      (yield Hc(o)).isDirectory() ? yield Qf(o, a, r, n) : yield Nf(o, a, n);
    }
    yield Bf(e, (yield Vn(t)).mode);
  });
}
function Nf(t, e, r) {
  return Rn(this, void 0, void 0, function* () {
    if ((yield Hc(t)).isSymbolicLink()) {
      try {
        yield Hc(e), yield Cm(e);
      } catch (s) {
        s.code === "EPERM" && (yield Bf(e, "0666"), yield Cm(e));
      }
      const n = yield kQ(t);
      yield DQ(n, e, zr ? "junction" : null);
    } else (!(yield vi(e)) || r) && (yield xQ(t, e));
  });
}
var ym = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
const Ci = process.platform === "win32";
class LQ extends Vg.EventEmitter {
  constructor(e, r, n) {
    if (super(), !e)
      throw new Error("Parameter 'toolPath' cannot be null or empty.");
    this.toolPath = e, this.args = r || [], this.options = n || {};
  }
  _debug(e) {
    this.options.listeners && this.options.listeners.debug && this.options.listeners.debug(e);
  }
  _getCommandString(e, r) {
    const n = this._getSpawnFileName(), s = this._getSpawnArgs(e);
    let i = r ? "" : "[command]";
    if (Ci)
      if (this._isCmdFile()) {
        i += n;
        for (const o of s)
          i += ` ${o}`;
      } else if (e.windowsVerbatimArguments) {
        i += `"${n}"`;
        for (const o of s)
          i += ` ${o}`;
      } else {
        i += this._windowsQuoteCmdArg(n);
        for (const o of s)
          i += ` ${this._windowsQuoteCmdArg(o)}`;
      }
    else {
      i += n;
      for (const o of s)
        i += ` ${o}`;
    }
    return i;
  }
  _processLineBuffer(e, r, n) {
    try {
      let s = r + e.toString(), i = s.indexOf(Zt.EOL);
      for (; i > -1; ) {
        const o = s.substring(0, i);
        n(o), s = s.substring(i + Zt.EOL.length), i = s.indexOf(Zt.EOL);
      }
      return s;
    } catch (s) {
      return this._debug(`error processing line. Failed with error ${s}`), "";
    }
  }
  _getSpawnFileName() {
    return Ci && this._isCmdFile() ? process.env.COMSPEC || "cmd.exe" : this.toolPath;
  }
  _getSpawnArgs(e) {
    if (Ci && this._isCmdFile()) {
      let r = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
      for (const n of this.args)
        r += " ", r += e.windowsVerbatimArguments ? n : this._windowsQuoteCmdArg(n);
      return r += '"', [r];
    }
    return this.args;
  }
  _endsWith(e, r) {
    return e.endsWith(r);
  }
  _isCmdFile() {
    const e = this.toolPath.toUpperCase();
    return this._endsWith(e, ".CMD") || this._endsWith(e, ".BAT");
  }
  _windowsQuoteCmdArg(e) {
    if (!this._isCmdFile())
      return this._uvQuoteCmdArg(e);
    if (!e)
      return '""';
    const r = [
      " ",
      "	",
      "&",
      "(",
      ")",
      "[",
      "]",
      "{",
      "}",
      "^",
      "=",
      ";",
      "!",
      "'",
      "+",
      ",",
      "`",
      "~",
      "|",
      "<",
      ">",
      '"'
    ];
    let n = !1;
    for (const o of e)
      if (r.some((a) => a === o)) {
        n = !0;
        break;
      }
    if (!n)
      return e;
    let s = '"', i = !0;
    for (let o = e.length; o > 0; o--)
      s += e[o - 1], i && e[o - 1] === "\\" ? s += "\\" : e[o - 1] === '"' ? (i = !0, s += '"') : i = !1;
    return s += '"', s.split("").reverse().join("");
  }
  _uvQuoteCmdArg(e) {
    if (!e)
      return '""';
    if (!e.includes(" ") && !e.includes("	") && !e.includes('"'))
      return e;
    if (!e.includes('"') && !e.includes("\\"))
      return `"${e}"`;
    let r = '"', n = !0;
    for (let s = e.length; s > 0; s--)
      r += e[s - 1], n && e[s - 1] === "\\" ? r += "\\" : e[s - 1] === '"' ? (n = !0, r += "\\") : n = !1;
    return r += '"', r.split("").reverse().join("");
  }
  _cloneExecOptions(e) {
    e = e || {};
    const r = {
      cwd: e.cwd || process.cwd(),
      env: e.env || process.env,
      silent: e.silent || !1,
      windowsVerbatimArguments: e.windowsVerbatimArguments || !1,
      failOnStdErr: e.failOnStdErr || !1,
      ignoreReturnCode: e.ignoreReturnCode || !1,
      delay: e.delay || 1e4
    };
    return r.outStream = e.outStream || process.stdout, r.errStream = e.errStream || process.stderr, r;
  }
  _getSpawnOptions(e, r) {
    e = e || {};
    const n = {};
    return n.cwd = e.cwd, n.env = e.env, n.windowsVerbatimArguments = e.windowsVerbatimArguments || this._isCmdFile(), e.windowsVerbatimArguments && (n.argv0 = `"${r}"`), n;
  }
  /**
   * Exec a tool.
   * Output will be streamed to the live console.
   * Returns promise with return code
   *
   * @param     tool     path to tool to exec
   * @param     options  optional exec options.  See ExecOptions
   * @returns   number
   */
  exec() {
    return ym(this, void 0, void 0, function* () {
      return !yf(this.toolPath) && (this.toolPath.includes("/") || Ci && this.toolPath.includes("\\")) && (this.toolPath = De.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath)), this.toolPath = yield br(this.toolPath, !0), new Promise((e, r) => ym(this, void 0, void 0, function* () {
        this._debug(`exec tool: ${this.toolPath}`), this._debug("arguments:");
        for (const c of this.args)
          this._debug(`   ${c}`);
        const n = this._cloneExecOptions(this.options);
        !n.silent && n.outStream && n.outStream.write(this._getCommandString(n) + Zt.EOL);
        const s = new Sl(n, this.toolPath);
        if (s.on("debug", (c) => {
          this._debug(c);
        }), this.options.cwd && !(yield vi(this.options.cwd)))
          return r(new Error(`The cwd: ${this.options.cwd} does not exist!`));
        const i = this._getSpawnFileName(), o = fy.spawn(i, this._getSpawnArgs(n), this._getSpawnOptions(this.options, i));
        let a = "";
        o.stdout && o.stdout.on("data", (c) => {
          this.options.listeners && this.options.listeners.stdout && this.options.listeners.stdout(c), !n.silent && n.outStream && n.outStream.write(c), a = this._processLineBuffer(c, a, (l) => {
            this.options.listeners && this.options.listeners.stdline && this.options.listeners.stdline(l);
          });
        });
        let A = "";
        if (o.stderr && o.stderr.on("data", (c) => {
          s.processStderr = !0, this.options.listeners && this.options.listeners.stderr && this.options.listeners.stderr(c), !n.silent && n.errStream && n.outStream && (n.failOnStdErr ? n.errStream : n.outStream).write(c), A = this._processLineBuffer(c, A, (l) => {
            this.options.listeners && this.options.listeners.errline && this.options.listeners.errline(l);
          });
        }), o.on("error", (c) => {
          s.processError = c.message, s.processExited = !0, s.processClosed = !0, s.CheckComplete();
        }), o.on("exit", (c) => {
          s.processExitCode = c, s.processExited = !0, this._debug(`Exit code ${c} received from tool '${this.toolPath}'`), s.CheckComplete();
        }), o.on("close", (c) => {
          s.processExitCode = c, s.processExited = !0, s.processClosed = !0, this._debug(`STDIO streams have closed for tool '${this.toolPath}'`), s.CheckComplete();
        }), s.on("done", (c, l) => {
          a.length > 0 && this.emit("stdline", a), A.length > 0 && this.emit("errline", A), o.removeAllListeners(), c ? r(c) : e(l);
        }), this.options.input) {
          if (!o.stdin)
            throw new Error("child process missing stdin");
          o.stdin.end(this.options.input);
        }
      }));
    });
  }
}
function UQ(t) {
  const e = [];
  let r = !1, n = !1, s = "";
  function i(o) {
    n && o !== '"' && (s += "\\"), s += o, n = !1;
  }
  for (let o = 0; o < t.length; o++) {
    const a = t.charAt(o);
    if (a === '"') {
      n ? i(a) : r = !r;
      continue;
    }
    if (a === "\\" && n) {
      i(a);
      continue;
    }
    if (a === "\\" && r) {
      n = !0;
      continue;
    }
    if (a === " " && !r) {
      s.length > 0 && (e.push(s), s = "");
      continue;
    }
    i(a);
  }
  return s.length > 0 && e.push(s.trim()), e;
}
class Sl extends Vg.EventEmitter {
  constructor(e, r) {
    if (super(), this.processClosed = !1, this.processError = "", this.processExitCode = 0, this.processExited = !1, this.processStderr = !1, this.delay = 1e4, this.done = !1, this.timeout = null, !r)
      throw new Error("toolPath must not be empty");
    this.options = e, this.toolPath = r, e.delay && (this.delay = e.delay);
  }
  CheckComplete() {
    this.done || (this.processClosed ? this._setResult() : this.processExited && (this.timeout = py(Sl.HandleTimeout, this.delay, this)));
  }
  _debug(e) {
    this.emit("debug", e);
  }
  _setResult() {
    let e;
    this.processExited && (this.processError ? e = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`) : this.processExitCode !== 0 && !this.options.ignoreReturnCode ? e = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`) : this.processStderr && this.options.failOnStdErr && (e = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`))), this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.done = !0, this.emit("done", e, this.processExitCode);
  }
  static HandleTimeout(e) {
    if (!e.done) {
      if (!e.processClosed && e.processExited) {
        const r = `The STDIO streams did not close within ${e.delay / 1e3} seconds of the exit event from process '${e.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        e._debug(r);
      }
      e._setResult();
    }
  }
}
var PQ = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
function Rr(t, e, r) {
  return PQ(this, void 0, void 0, function* () {
    const n = UQ(t);
    if (n.length === 0)
      throw new Error("Parameter 'commandLine' cannot be null or empty.");
    const s = n[0];
    return e = n.slice(1).concat(e || []), new LQ(s, e, r).exec();
  });
}
cl.platform();
cl.arch();
var zc;
(function(t) {
  t[t.Success = 0] = "Success", t[t.Failure = 1] = "Failure";
})(zc || (zc = {}));
function HQ(t, e) {
  const r = $n(e);
  if (process.env[t] = r, process.env.GITHUB_ENV || "")
    return Cl("ENV", tf(t, e));
  jr("set-env", { name: t }, r);
}
function Li(t) {
  jr("add-mask", {}, t);
}
function OQ(t) {
  process.env.GITHUB_PATH || "" ? Cl("PATH", t) : jr("add-path", {}, t), process.env.PATH = `${t}${De.delimiter}${process.env.PATH}`;
}
function Gn(t, e) {
  const r = process.env[`INPUT_${t.replace(/ /g, "_").toUpperCase()}`] || "";
  if (e && e.required && !r)
    throw new Error(`Input required and not supplied: ${t}`);
  return e && e.trimWhitespace === !1 ? r : r.trim();
}
function Qm(t, e) {
  if (process.env.GITHUB_OUTPUT || "")
    return Cl("OUTPUT", tf(t, e));
  process.stdout.write(Zt.EOL), jr("set-output", { name: t }, $n(e));
}
function Nm(t) {
  process.exitCode = zc.Failure, ni(t);
}
function Sn() {
  return process.env.RUNNER_DEBUG === "1";
}
function le(t) {
  jr("debug", {}, t);
}
function ni(t, e = {}) {
  jr("error", jg(e), t instanceof Error ? t.toString() : t);
}
function Hr(t, e = {}) {
  jr("warning", jg(e), t instanceof Error ? t.toString() : t);
}
function xt(t) {
  process.stdout.write(t + Zt.EOL);
}
function RA(t) {
  ef("group", t);
}
function SA() {
  ef("endgroup");
}
var Bi = { exports: {} }, DA, wm;
function ao() {
  if (wm) return DA;
  wm = 1;
  const t = "2.0.0", e = 256, r = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, n = 16, s = e - 6;
  return DA = {
    MAX_LENGTH: e,
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: s,
    MAX_SAFE_INTEGER: r,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: t,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, DA;
}
var kA, bm;
function Ao() {
  return bm || (bm = 1, kA = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
  }), kA;
}
var xm;
function si() {
  return xm || (xm = 1, (function(t, e) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: r,
      MAX_SAFE_BUILD_LENGTH: n,
      MAX_LENGTH: s
    } = ao(), i = Ao();
    e = t.exports = {};
    const o = e.re = [], a = e.safeRe = [], A = e.src = [], c = e.safeSrc = [], l = e.t = {};
    let d = 0;
    const u = "[a-zA-Z0-9-]", m = [
      ["\\s", 1],
      ["\\d", s],
      [u, n]
    ], h = (p) => {
      for (const [y, w] of m)
        p = p.split(`${y}*`).join(`${y}{0,${w}}`).split(`${y}+`).join(`${y}{1,${w}}`);
      return p;
    }, f = (p, y, w) => {
      const R = h(y), D = d++;
      i(p, D, y), l[p] = D, A[D] = y, c[D] = R, o[D] = new RegExp(y, w ? "g" : void 0), a[D] = new RegExp(R, w ? "g" : void 0);
    };
    f("NUMERICIDENTIFIER", "0|[1-9]\\d*"), f("NUMERICIDENTIFIERLOOSE", "\\d+"), f("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${u}*`), f("MAINVERSION", `(${A[l.NUMERICIDENTIFIER]})\\.(${A[l.NUMERICIDENTIFIER]})\\.(${A[l.NUMERICIDENTIFIER]})`), f("MAINVERSIONLOOSE", `(${A[l.NUMERICIDENTIFIERLOOSE]})\\.(${A[l.NUMERICIDENTIFIERLOOSE]})\\.(${A[l.NUMERICIDENTIFIERLOOSE]})`), f("PRERELEASEIDENTIFIER", `(?:${A[l.NONNUMERICIDENTIFIER]}|${A[l.NUMERICIDENTIFIER]})`), f("PRERELEASEIDENTIFIERLOOSE", `(?:${A[l.NONNUMERICIDENTIFIER]}|${A[l.NUMERICIDENTIFIERLOOSE]})`), f("PRERELEASE", `(?:-(${A[l.PRERELEASEIDENTIFIER]}(?:\\.${A[l.PRERELEASEIDENTIFIER]})*))`), f("PRERELEASELOOSE", `(?:-?(${A[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${A[l.PRERELEASEIDENTIFIERLOOSE]})*))`), f("BUILDIDENTIFIER", `${u}+`), f("BUILD", `(?:\\+(${A[l.BUILDIDENTIFIER]}(?:\\.${A[l.BUILDIDENTIFIER]})*))`), f("FULLPLAIN", `v?${A[l.MAINVERSION]}${A[l.PRERELEASE]}?${A[l.BUILD]}?`), f("FULL", `^${A[l.FULLPLAIN]}$`), f("LOOSEPLAIN", `[v=\\s]*${A[l.MAINVERSIONLOOSE]}${A[l.PRERELEASELOOSE]}?${A[l.BUILD]}?`), f("LOOSE", `^${A[l.LOOSEPLAIN]}$`), f("GTLT", "((?:<|>)?=?)"), f("XRANGEIDENTIFIERLOOSE", `${A[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), f("XRANGEIDENTIFIER", `${A[l.NUMERICIDENTIFIER]}|x|X|\\*`), f("XRANGEPLAIN", `[v=\\s]*(${A[l.XRANGEIDENTIFIER]})(?:\\.(${A[l.XRANGEIDENTIFIER]})(?:\\.(${A[l.XRANGEIDENTIFIER]})(?:${A[l.PRERELEASE]})?${A[l.BUILD]}?)?)?`), f("XRANGEPLAINLOOSE", `[v=\\s]*(${A[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${A[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${A[l.XRANGEIDENTIFIERLOOSE]})(?:${A[l.PRERELEASELOOSE]})?${A[l.BUILD]}?)?)?`), f("XRANGE", `^${A[l.GTLT]}\\s*${A[l.XRANGEPLAIN]}$`), f("XRANGELOOSE", `^${A[l.GTLT]}\\s*${A[l.XRANGEPLAINLOOSE]}$`), f("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), f("COERCE", `${A[l.COERCEPLAIN]}(?:$|[^\\d])`), f("COERCEFULL", A[l.COERCEPLAIN] + `(?:${A[l.PRERELEASE]})?(?:${A[l.BUILD]})?(?:$|[^\\d])`), f("COERCERTL", A[l.COERCE], !0), f("COERCERTLFULL", A[l.COERCEFULL], !0), f("LONETILDE", "(?:~>?)"), f("TILDETRIM", `(\\s*)${A[l.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", f("TILDE", `^${A[l.LONETILDE]}${A[l.XRANGEPLAIN]}$`), f("TILDELOOSE", `^${A[l.LONETILDE]}${A[l.XRANGEPLAINLOOSE]}$`), f("LONECARET", "(?:\\^)"), f("CARETTRIM", `(\\s*)${A[l.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", f("CARET", `^${A[l.LONECARET]}${A[l.XRANGEPLAIN]}$`), f("CARETLOOSE", `^${A[l.LONECARET]}${A[l.XRANGEPLAINLOOSE]}$`), f("COMPARATORLOOSE", `^${A[l.GTLT]}\\s*(${A[l.LOOSEPLAIN]})$|^$`), f("COMPARATOR", `^${A[l.GTLT]}\\s*(${A[l.FULLPLAIN]})$|^$`), f("COMPARATORTRIM", `(\\s*)${A[l.GTLT]}\\s*(${A[l.LOOSEPLAIN]}|${A[l.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", f("HYPHENRANGE", `^\\s*(${A[l.XRANGEPLAIN]})\\s+-\\s+(${A[l.XRANGEPLAIN]})\\s*$`), f("HYPHENRANGELOOSE", `^\\s*(${A[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${A[l.XRANGEPLAINLOOSE]})\\s*$`), f("STAR", "(<|>)?=?\\s*\\*"), f("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), f("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(Bi, Bi.exports)), Bi.exports;
}
var MA, Rm;
function Dl() {
  if (Rm) return MA;
  Rm = 1;
  const t = Object.freeze({ loose: !0 }), e = Object.freeze({});
  return MA = (n) => n ? typeof n != "object" ? t : n : e, MA;
}
var TA, Sm;
function wf() {
  if (Sm) return TA;
  Sm = 1;
  const t = /^[0-9]+$/, e = (n, s) => {
    if (typeof n == "number" && typeof s == "number")
      return n === s ? 0 : n < s ? -1 : 1;
    const i = t.test(n), o = t.test(s);
    return i && o && (n = +n, s = +s), n === s ? 0 : i && !o ? -1 : o && !i ? 1 : n < s ? -1 : 1;
  };
  return TA = {
    compareIdentifiers: e,
    rcompareIdentifiers: (n, s) => e(s, n)
  }, TA;
}
var FA, Dm;
function Wt() {
  if (Dm) return FA;
  Dm = 1;
  const t = Ao(), { MAX_LENGTH: e, MAX_SAFE_INTEGER: r } = ao(), { safeRe: n, t: s } = si(), i = Dl(), { compareIdentifiers: o } = wf();
  class a {
    constructor(c, l) {
      if (l = i(l), c instanceof a) {
        if (c.loose === !!l.loose && c.includePrerelease === !!l.includePrerelease)
          return c;
        c = c.version;
      } else if (typeof c != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof c}".`);
      if (c.length > e)
        throw new TypeError(
          `version is longer than ${e} characters`
        );
      t("SemVer", c, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      const d = c.trim().match(l.loose ? n[s.LOOSE] : n[s.FULL]);
      if (!d)
        throw new TypeError(`Invalid Version: ${c}`);
      if (this.raw = c, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > r || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > r || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > r || this.patch < 0)
        throw new TypeError("Invalid patch version");
      d[4] ? this.prerelease = d[4].split(".").map((u) => {
        if (/^[0-9]+$/.test(u)) {
          const m = +u;
          if (m >= 0 && m < r)
            return m;
        }
        return u;
      }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(c) {
      if (t("SemVer.compare", this.version, this.options, c), !(c instanceof a)) {
        if (typeof c == "string" && c === this.version)
          return 0;
        c = new a(c, this.options);
      }
      return c.version === this.version ? 0 : this.compareMain(c) || this.comparePre(c);
    }
    compareMain(c) {
      return c instanceof a || (c = new a(c, this.options)), this.major < c.major ? -1 : this.major > c.major ? 1 : this.minor < c.minor ? -1 : this.minor > c.minor ? 1 : this.patch < c.patch ? -1 : this.patch > c.patch ? 1 : 0;
    }
    comparePre(c) {
      if (c instanceof a || (c = new a(c, this.options)), this.prerelease.length && !c.prerelease.length)
        return -1;
      if (!this.prerelease.length && c.prerelease.length)
        return 1;
      if (!this.prerelease.length && !c.prerelease.length)
        return 0;
      let l = 0;
      do {
        const d = this.prerelease[l], u = c.prerelease[l];
        if (t("prerelease compare", l, d, u), d === void 0 && u === void 0)
          return 0;
        if (u === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === u)
          continue;
        return o(d, u);
      } while (++l);
    }
    compareBuild(c) {
      c instanceof a || (c = new a(c, this.options));
      let l = 0;
      do {
        const d = this.build[l], u = c.build[l];
        if (t("build compare", l, d, u), d === void 0 && u === void 0)
          return 0;
        if (u === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === u)
          continue;
        return o(d, u);
      } while (++l);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(c, l, d) {
      if (c.startsWith("pre")) {
        if (!l && d === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (l) {
          const u = `-${l}`.match(this.options.loose ? n[s.PRERELEASELOOSE] : n[s.PRERELEASE]);
          if (!u || u[1] !== l)
            throw new Error(`invalid identifier: ${l}`);
        }
      }
      switch (c) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l, d);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l, d);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const u = Number(d) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [u];
          else {
            let m = this.prerelease.length;
            for (; --m >= 0; )
              typeof this.prerelease[m] == "number" && (this.prerelease[m]++, m = -2);
            if (m === -1) {
              if (l === this.prerelease.join(".") && d === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(u);
            }
          }
          if (l) {
            let m = [l, u];
            d === !1 && (m = [l]), o(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = m) : this.prerelease = m;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${c}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return FA = a, FA;
}
var vA, km;
function es() {
  if (km) return vA;
  km = 1;
  const t = Wt();
  return vA = (r, n, s = !1) => {
    if (r instanceof t)
      return r;
    try {
      return new t(r, n);
    } catch (i) {
      if (!s)
        return null;
      throw i;
    }
  }, vA;
}
var LA, Mm;
function zQ() {
  if (Mm) return LA;
  Mm = 1;
  const t = es();
  return LA = (r, n) => {
    const s = t(r, n);
    return s ? s.version : null;
  }, LA;
}
var UA, Tm;
function qQ() {
  if (Tm) return UA;
  Tm = 1;
  const t = es();
  return UA = (r, n) => {
    const s = t(r.trim().replace(/^[=v]+/, ""), n);
    return s ? s.version : null;
  }, UA;
}
var PA, Fm;
function GQ() {
  if (Fm) return PA;
  Fm = 1;
  const t = Wt();
  return PA = (r, n, s, i, o) => {
    typeof s == "string" && (o = i, i = s, s = void 0);
    try {
      return new t(
        r instanceof t ? r.version : r,
        s
      ).inc(n, i, o).version;
    } catch {
      return null;
    }
  }, PA;
}
var HA, vm;
function YQ() {
  if (vm) return HA;
  vm = 1;
  const t = es();
  return HA = (r, n) => {
    const s = t(r, null, !0), i = t(n, null, !0), o = s.compare(i);
    if (o === 0)
      return null;
    const a = o > 0, A = a ? s : i, c = a ? i : s, l = !!A.prerelease.length;
    if (!!c.prerelease.length && !l) {
      if (!c.patch && !c.minor)
        return "major";
      if (c.compareMain(A) === 0)
        return c.minor && !c.patch ? "minor" : "patch";
    }
    const u = l ? "pre" : "";
    return s.major !== i.major ? u + "major" : s.minor !== i.minor ? u + "minor" : s.patch !== i.patch ? u + "patch" : "prerelease";
  }, HA;
}
var OA, Lm;
function JQ() {
  if (Lm) return OA;
  Lm = 1;
  const t = Wt();
  return OA = (r, n) => new t(r, n).major, OA;
}
var zA, Um;
function VQ() {
  if (Um) return zA;
  Um = 1;
  const t = Wt();
  return zA = (r, n) => new t(r, n).minor, zA;
}
var qA, Pm;
function _Q() {
  if (Pm) return qA;
  Pm = 1;
  const t = Wt();
  return qA = (r, n) => new t(r, n).patch, qA;
}
var GA, Hm;
function WQ() {
  if (Hm) return GA;
  Hm = 1;
  const t = es();
  return GA = (r, n) => {
    const s = t(r, n);
    return s && s.prerelease.length ? s.prerelease : null;
  }, GA;
}
var YA, Om;
function Br() {
  if (Om) return YA;
  Om = 1;
  const t = Wt();
  return YA = (r, n, s) => new t(r, s).compare(new t(n, s)), YA;
}
var JA, zm;
function $Q() {
  if (zm) return JA;
  zm = 1;
  const t = Br();
  return JA = (r, n, s) => t(n, r, s), JA;
}
var VA, qm;
function XQ() {
  if (qm) return VA;
  qm = 1;
  const t = Br();
  return VA = (r, n) => t(r, n, !0), VA;
}
var _A, Gm;
function kl() {
  if (Gm) return _A;
  Gm = 1;
  const t = Wt();
  return _A = (r, n, s) => {
    const i = new t(r, s), o = new t(n, s);
    return i.compare(o) || i.compareBuild(o);
  }, _A;
}
var WA, Ym;
function ZQ() {
  if (Ym) return WA;
  Ym = 1;
  const t = kl();
  return WA = (r, n) => r.sort((s, i) => t(s, i, n)), WA;
}
var $A, Jm;
function KQ() {
  if (Jm) return $A;
  Jm = 1;
  const t = kl();
  return $A = (r, n) => r.sort((s, i) => t(i, s, n)), $A;
}
var XA, Vm;
function co() {
  if (Vm) return XA;
  Vm = 1;
  const t = Br();
  return XA = (r, n, s) => t(r, n, s) > 0, XA;
}
var ZA, _m;
function Ml() {
  if (_m) return ZA;
  _m = 1;
  const t = Br();
  return ZA = (r, n, s) => t(r, n, s) < 0, ZA;
}
var KA, Wm;
function bf() {
  if (Wm) return KA;
  Wm = 1;
  const t = Br();
  return KA = (r, n, s) => t(r, n, s) === 0, KA;
}
var jA, $m;
function xf() {
  if ($m) return jA;
  $m = 1;
  const t = Br();
  return jA = (r, n, s) => t(r, n, s) !== 0, jA;
}
var ec, Xm;
function Tl() {
  if (Xm) return ec;
  Xm = 1;
  const t = Br();
  return ec = (r, n, s) => t(r, n, s) >= 0, ec;
}
var tc, Zm;
function Fl() {
  if (Zm) return tc;
  Zm = 1;
  const t = Br();
  return tc = (r, n, s) => t(r, n, s) <= 0, tc;
}
var rc, Km;
function Rf() {
  if (Km) return rc;
  Km = 1;
  const t = bf(), e = xf(), r = co(), n = Tl(), s = Ml(), i = Fl();
  return rc = (a, A, c, l) => {
    switch (A) {
      case "===":
        return typeof a == "object" && (a = a.version), typeof c == "object" && (c = c.version), a === c;
      case "!==":
        return typeof a == "object" && (a = a.version), typeof c == "object" && (c = c.version), a !== c;
      case "":
      case "=":
      case "==":
        return t(a, c, l);
      case "!=":
        return e(a, c, l);
      case ">":
        return r(a, c, l);
      case ">=":
        return n(a, c, l);
      case "<":
        return s(a, c, l);
      case "<=":
        return i(a, c, l);
      default:
        throw new TypeError(`Invalid operator: ${A}`);
    }
  }, rc;
}
var nc, jm;
function jQ() {
  if (jm) return nc;
  jm = 1;
  const t = Wt(), e = es(), { safeRe: r, t: n } = si();
  return nc = (i, o) => {
    if (i instanceof t)
      return i;
    if (typeof i == "number" && (i = String(i)), typeof i != "string")
      return null;
    o = o || {};
    let a = null;
    if (!o.rtl)
      a = i.match(o.includePrerelease ? r[n.COERCEFULL] : r[n.COERCE]);
    else {
      const m = o.includePrerelease ? r[n.COERCERTLFULL] : r[n.COERCERTL];
      let h;
      for (; (h = m.exec(i)) && (!a || a.index + a[0].length !== i.length); )
        (!a || h.index + h[0].length !== a.index + a[0].length) && (a = h), m.lastIndex = h.index + h[1].length + h[2].length;
      m.lastIndex = -1;
    }
    if (a === null)
      return null;
    const A = a[2], c = a[3] || "0", l = a[4] || "0", d = o.includePrerelease && a[5] ? `-${a[5]}` : "", u = o.includePrerelease && a[6] ? `+${a[6]}` : "";
    return e(`${A}.${c}.${l}${d}${u}`, o);
  }, nc;
}
var sc, eh;
function eN() {
  if (eh) return sc;
  eh = 1;
  class t {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(r) {
      const n = this.map.get(r);
      if (n !== void 0)
        return this.map.delete(r), this.map.set(r, n), n;
    }
    delete(r) {
      return this.map.delete(r);
    }
    set(r, n) {
      if (!this.delete(r) && n !== void 0) {
        if (this.map.size >= this.max) {
          const i = this.map.keys().next().value;
          this.delete(i);
        }
        this.map.set(r, n);
      }
      return this;
    }
  }
  return sc = t, sc;
}
var ic, th;
function Ir() {
  if (th) return ic;
  th = 1;
  const t = /\s+/g;
  class e {
    constructor(S, M) {
      if (M = s(M), S instanceof e)
        return S.loose === !!M.loose && S.includePrerelease === !!M.includePrerelease ? S : new e(S.raw, M);
      if (S instanceof i)
        return this.raw = S.value, this.set = [[S]], this.formatted = void 0, this;
      if (this.options = M, this.loose = !!M.loose, this.includePrerelease = !!M.includePrerelease, this.raw = S.trim().replace(t, " "), this.set = this.raw.split("||").map((k) => this.parseRange(k.trim())).filter((k) => k.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const k = this.set[0];
        if (this.set = this.set.filter((F) => !f(F[0])), this.set.length === 0)
          this.set = [k];
        else if (this.set.length > 1) {
          for (const F of this.set)
            if (F.length === 1 && p(F[0])) {
              this.set = [F];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let S = 0; S < this.set.length; S++) {
          S > 0 && (this.formatted += "||");
          const M = this.set[S];
          for (let k = 0; k < M.length; k++)
            k > 0 && (this.formatted += " "), this.formatted += M[k].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(S) {
      const k = ((this.options.includePrerelease && m) | (this.options.loose && h)) + ":" + S, F = n.get(k);
      if (F)
        return F;
      const P = this.options.loose, J = P ? A[c.HYPHENRANGELOOSE] : A[c.HYPHENRANGE];
      S = S.replace(J, E(this.options.includePrerelease)), o("hyphen replace", S), S = S.replace(A[c.COMPARATORTRIM], l), o("comparator trim", S), S = S.replace(A[c.TILDETRIM], d), o("tilde trim", S), S = S.replace(A[c.CARETTRIM], u), o("caret trim", S);
      let te = S.split(" ").map((ce) => w(ce, this.options)).join(" ").split(/\s+/).map((ce) => Q(ce, this.options));
      P && (te = te.filter((ce) => (o("loose invalid filter", ce, this.options), !!ce.match(A[c.COMPARATORLOOSE])))), o("range list", te);
      const ee = /* @__PURE__ */ new Map(), de = te.map((ce) => new i(ce, this.options));
      for (const ce of de) {
        if (f(ce))
          return [ce];
        ee.set(ce.value, ce);
      }
      ee.size > 1 && ee.has("") && ee.delete("");
      const ue = [...ee.values()];
      return n.set(k, ue), ue;
    }
    intersects(S, M) {
      if (!(S instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((k) => y(k, M) && S.set.some((F) => y(F, M) && k.every((P) => F.every((J) => P.intersects(J, M)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(S) {
      if (!S)
        return !1;
      if (typeof S == "string")
        try {
          S = new a(S, this.options);
        } catch {
          return !1;
        }
      for (let M = 0; M < this.set.length; M++)
        if (b(this.set[M], S, this.options))
          return !0;
      return !1;
    }
  }
  ic = e;
  const r = eN(), n = new r(), s = Dl(), i = lo(), o = Ao(), a = Wt(), {
    safeRe: A,
    t: c,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: u
  } = si(), { FLAG_INCLUDE_PRERELEASE: m, FLAG_LOOSE: h } = ao(), f = (N) => N.value === "<0.0.0-0", p = (N) => N.value === "", y = (N, S) => {
    let M = !0;
    const k = N.slice();
    let F = k.pop();
    for (; M && k.length; )
      M = k.every((P) => F.intersects(P, S)), F = k.pop();
    return M;
  }, w = (N, S) => (N = N.replace(A[c.BUILD], ""), o("comp", N, S), N = C(N, S), o("caret", N), N = D(N, S), o("tildes", N), N = x(N, S), o("xrange", N), N = B(N, S), o("stars", N), N), R = (N) => !N || N.toLowerCase() === "x" || N === "*", D = (N, S) => N.trim().split(/\s+/).map((M) => L(M, S)).join(" "), L = (N, S) => {
    const M = S.loose ? A[c.TILDELOOSE] : A[c.TILDE];
    return N.replace(M, (k, F, P, J, te) => {
      o("tilde", N, k, F, P, J, te);
      let ee;
      return R(F) ? ee = "" : R(P) ? ee = `>=${F}.0.0 <${+F + 1}.0.0-0` : R(J) ? ee = `>=${F}.${P}.0 <${F}.${+P + 1}.0-0` : te ? (o("replaceTilde pr", te), ee = `>=${F}.${P}.${J}-${te} <${F}.${+P + 1}.0-0`) : ee = `>=${F}.${P}.${J} <${F}.${+P + 1}.0-0`, o("tilde return", ee), ee;
    });
  }, C = (N, S) => N.trim().split(/\s+/).map((M) => I(M, S)).join(" "), I = (N, S) => {
    o("caret", N, S);
    const M = S.loose ? A[c.CARETLOOSE] : A[c.CARET], k = S.includePrerelease ? "-0" : "";
    return N.replace(M, (F, P, J, te, ee) => {
      o("caret", N, F, P, J, te, ee);
      let de;
      return R(P) ? de = "" : R(J) ? de = `>=${P}.0.0${k} <${+P + 1}.0.0-0` : R(te) ? P === "0" ? de = `>=${P}.${J}.0${k} <${P}.${+J + 1}.0-0` : de = `>=${P}.${J}.0${k} <${+P + 1}.0.0-0` : ee ? (o("replaceCaret pr", ee), P === "0" ? J === "0" ? de = `>=${P}.${J}.${te}-${ee} <${P}.${J}.${+te + 1}-0` : de = `>=${P}.${J}.${te}-${ee} <${P}.${+J + 1}.0-0` : de = `>=${P}.${J}.${te}-${ee} <${+P + 1}.0.0-0`) : (o("no pr"), P === "0" ? J === "0" ? de = `>=${P}.${J}.${te}${k} <${P}.${J}.${+te + 1}-0` : de = `>=${P}.${J}.${te}${k} <${P}.${+J + 1}.0-0` : de = `>=${P}.${J}.${te} <${+P + 1}.0.0-0`), o("caret return", de), de;
    });
  }, x = (N, S) => (o("replaceXRanges", N, S), N.split(/\s+/).map((M) => g(M, S)).join(" ")), g = (N, S) => {
    N = N.trim();
    const M = S.loose ? A[c.XRANGELOOSE] : A[c.XRANGE];
    return N.replace(M, (k, F, P, J, te, ee) => {
      o("xRange", N, k, F, P, J, te, ee);
      const de = R(P), ue = de || R(J), ce = ue || R(te), fe = ce;
      return F === "=" && fe && (F = ""), ee = S.includePrerelease ? "-0" : "", de ? F === ">" || F === "<" ? k = "<0.0.0-0" : k = "*" : F && fe ? (ue && (J = 0), te = 0, F === ">" ? (F = ">=", ue ? (P = +P + 1, J = 0, te = 0) : (J = +J + 1, te = 0)) : F === "<=" && (F = "<", ue ? P = +P + 1 : J = +J + 1), F === "<" && (ee = "-0"), k = `${F + P}.${J}.${te}${ee}`) : ue ? k = `>=${P}.0.0${ee} <${+P + 1}.0.0-0` : ce && (k = `>=${P}.${J}.0${ee} <${P}.${+J + 1}.0-0`), o("xRange return", k), k;
    });
  }, B = (N, S) => (o("replaceStars", N, S), N.trim().replace(A[c.STAR], "")), Q = (N, S) => (o("replaceGTE0", N, S), N.trim().replace(A[S.includePrerelease ? c.GTE0PRE : c.GTE0], "")), E = (N) => (S, M, k, F, P, J, te, ee, de, ue, ce, fe) => (R(k) ? M = "" : R(F) ? M = `>=${k}.0.0${N ? "-0" : ""}` : R(P) ? M = `>=${k}.${F}.0${N ? "-0" : ""}` : J ? M = `>=${M}` : M = `>=${M}${N ? "-0" : ""}`, R(de) ? ee = "" : R(ue) ? ee = `<${+de + 1}.0.0-0` : R(ce) ? ee = `<${de}.${+ue + 1}.0-0` : fe ? ee = `<=${de}.${ue}.${ce}-${fe}` : N ? ee = `<${de}.${ue}.${+ce + 1}-0` : ee = `<=${ee}`, `${M} ${ee}`.trim()), b = (N, S, M) => {
    for (let k = 0; k < N.length; k++)
      if (!N[k].test(S))
        return !1;
    if (S.prerelease.length && !M.includePrerelease) {
      for (let k = 0; k < N.length; k++)
        if (o(N[k].semver), N[k].semver !== i.ANY && N[k].semver.prerelease.length > 0) {
          const F = N[k].semver;
          if (F.major === S.major && F.minor === S.minor && F.patch === S.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return ic;
}
var oc, rh;
function lo() {
  if (rh) return oc;
  rh = 1;
  const t = /* @__PURE__ */ Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return t;
    }
    constructor(l, d) {
      if (d = r(d), l instanceof e) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), o("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[s.COMPARATORLOOSE] : n[s.COMPARATOR], u = l.match(d);
      if (!u)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = u[1] !== void 0 ? u[1] : "", this.operator === "=" && (this.operator = ""), u[2] ? this.semver = new a(u[2], this.options.loose) : this.semver = t;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (o("Comparator.test", l, this.options.loose), this.semver === t || l === t)
        return !0;
      if (typeof l == "string")
        try {
          l = new a(l, this.options);
        } catch {
          return !1;
        }
      return i(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new A(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new A(this.value, d).test(l.semver) : (d = r(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || i(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || i(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  oc = e;
  const r = Dl(), { safeRe: n, t: s } = si(), i = Rf(), o = Ao(), a = Wt(), A = Ir();
  return oc;
}
var ac, nh;
function uo() {
  if (nh) return ac;
  nh = 1;
  const t = Ir();
  return ac = (r, n, s) => {
    try {
      n = new t(n, s);
    } catch {
      return !1;
    }
    return n.test(r);
  }, ac;
}
var Ac, sh;
function tN() {
  if (sh) return Ac;
  sh = 1;
  const t = Ir();
  return Ac = (r, n) => new t(r, n).set.map((s) => s.map((i) => i.value).join(" ").trim().split(" ")), Ac;
}
var cc, ih;
function rN() {
  if (ih) return cc;
  ih = 1;
  const t = Wt(), e = Ir();
  return cc = (n, s, i) => {
    let o = null, a = null, A = null;
    try {
      A = new e(s, i);
    } catch {
      return null;
    }
    return n.forEach((c) => {
      A.test(c) && (!o || a.compare(c) === -1) && (o = c, a = new t(o, i));
    }), o;
  }, cc;
}
var lc, oh;
function nN() {
  if (oh) return lc;
  oh = 1;
  const t = Wt(), e = Ir();
  return lc = (n, s, i) => {
    let o = null, a = null, A = null;
    try {
      A = new e(s, i);
    } catch {
      return null;
    }
    return n.forEach((c) => {
      A.test(c) && (!o || a.compare(c) === 1) && (o = c, a = new t(o, i));
    }), o;
  }, lc;
}
var dc, ah;
function sN() {
  if (ah) return dc;
  ah = 1;
  const t = Wt(), e = Ir(), r = co();
  return dc = (s, i) => {
    s = new e(s, i);
    let o = new t("0.0.0");
    if (s.test(o) || (o = new t("0.0.0-0"), s.test(o)))
      return o;
    o = null;
    for (let a = 0; a < s.set.length; ++a) {
      const A = s.set[a];
      let c = null;
      A.forEach((l) => {
        const d = new t(l.semver.version);
        switch (l.operator) {
          case ">":
            d.prerelease.length === 0 ? d.patch++ : d.prerelease.push(0), d.raw = d.format();
          /* fallthrough */
          case "":
          case ">=":
            (!c || r(d, c)) && (c = d);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${l.operator}`);
        }
      }), c && (!o || r(o, c)) && (o = c);
    }
    return o && s.test(o) ? o : null;
  }, dc;
}
var uc, Ah;
function iN() {
  if (Ah) return uc;
  Ah = 1;
  const t = Ir();
  return uc = (r, n) => {
    try {
      return new t(r, n).range || "*";
    } catch {
      return null;
    }
  }, uc;
}
var mc, ch;
function vl() {
  if (ch) return mc;
  ch = 1;
  const t = Wt(), e = lo(), { ANY: r } = e, n = Ir(), s = uo(), i = co(), o = Ml(), a = Fl(), A = Tl();
  return mc = (l, d, u, m) => {
    l = new t(l, m), d = new n(d, m);
    let h, f, p, y, w;
    switch (u) {
      case ">":
        h = i, f = a, p = o, y = ">", w = ">=";
        break;
      case "<":
        h = o, f = A, p = i, y = "<", w = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (s(l, d, m))
      return !1;
    for (let R = 0; R < d.set.length; ++R) {
      const D = d.set[R];
      let L = null, C = null;
      if (D.forEach((I) => {
        I.semver === r && (I = new e(">=0.0.0")), L = L || I, C = C || I, h(I.semver, L.semver, m) ? L = I : p(I.semver, C.semver, m) && (C = I);
      }), L.operator === y || L.operator === w || (!C.operator || C.operator === y) && f(l, C.semver))
        return !1;
      if (C.operator === w && p(l, C.semver))
        return !1;
    }
    return !0;
  }, mc;
}
var hc, lh;
function oN() {
  if (lh) return hc;
  lh = 1;
  const t = vl();
  return hc = (r, n, s) => t(r, n, ">", s), hc;
}
var gc, dh;
function aN() {
  if (dh) return gc;
  dh = 1;
  const t = vl();
  return gc = (r, n, s) => t(r, n, "<", s), gc;
}
var fc, uh;
function AN() {
  if (uh) return fc;
  uh = 1;
  const t = Ir();
  return fc = (r, n, s) => (r = new t(r, s), n = new t(n, s), r.intersects(n, s)), fc;
}
var pc, mh;
function cN() {
  if (mh) return pc;
  mh = 1;
  const t = uo(), e = Br();
  return pc = (r, n, s) => {
    const i = [];
    let o = null, a = null;
    const A = r.sort((u, m) => e(u, m, s));
    for (const u of A)
      t(u, n, s) ? (a = u, o || (o = u)) : (a && i.push([o, a]), a = null, o = null);
    o && i.push([o, null]);
    const c = [];
    for (const [u, m] of i)
      u === m ? c.push(u) : !m && u === A[0] ? c.push("*") : m ? u === A[0] ? c.push(`<=${m}`) : c.push(`${u} - ${m}`) : c.push(`>=${u}`);
    const l = c.join(" || "), d = typeof n.raw == "string" ? n.raw : String(n);
    return l.length < d.length ? l : n;
  }, pc;
}
var Ec, hh;
function lN() {
  if (hh) return Ec;
  hh = 1;
  const t = Ir(), e = lo(), { ANY: r } = e, n = uo(), s = Br(), i = (d, u, m = {}) => {
    if (d === u)
      return !0;
    d = new t(d, m), u = new t(u, m);
    let h = !1;
    e: for (const f of d.set) {
      for (const p of u.set) {
        const y = A(f, p, m);
        if (h = h || y !== null, y)
          continue e;
      }
      if (h)
        return !1;
    }
    return !0;
  }, o = [new e(">=0.0.0-0")], a = [new e(">=0.0.0")], A = (d, u, m) => {
    if (d === u)
      return !0;
    if (d.length === 1 && d[0].semver === r) {
      if (u.length === 1 && u[0].semver === r)
        return !0;
      m.includePrerelease ? d = o : d = a;
    }
    if (u.length === 1 && u[0].semver === r) {
      if (m.includePrerelease)
        return !0;
      u = a;
    }
    const h = /* @__PURE__ */ new Set();
    let f, p;
    for (const x of d)
      x.operator === ">" || x.operator === ">=" ? f = c(f, x, m) : x.operator === "<" || x.operator === "<=" ? p = l(p, x, m) : h.add(x.semver);
    if (h.size > 1)
      return null;
    let y;
    if (f && p) {
      if (y = s(f.semver, p.semver, m), y > 0)
        return null;
      if (y === 0 && (f.operator !== ">=" || p.operator !== "<="))
        return null;
    }
    for (const x of h) {
      if (f && !n(x, String(f), m) || p && !n(x, String(p), m))
        return null;
      for (const g of u)
        if (!n(x, String(g), m))
          return !1;
      return !0;
    }
    let w, R, D, L, C = p && !m.includePrerelease && p.semver.prerelease.length ? p.semver : !1, I = f && !m.includePrerelease && f.semver.prerelease.length ? f.semver : !1;
    C && C.prerelease.length === 1 && p.operator === "<" && C.prerelease[0] === 0 && (C = !1);
    for (const x of u) {
      if (L = L || x.operator === ">" || x.operator === ">=", D = D || x.operator === "<" || x.operator === "<=", f) {
        if (I && x.semver.prerelease && x.semver.prerelease.length && x.semver.major === I.major && x.semver.minor === I.minor && x.semver.patch === I.patch && (I = !1), x.operator === ">" || x.operator === ">=") {
          if (w = c(f, x, m), w === x && w !== f)
            return !1;
        } else if (f.operator === ">=" && !n(f.semver, String(x), m))
          return !1;
      }
      if (p) {
        if (C && x.semver.prerelease && x.semver.prerelease.length && x.semver.major === C.major && x.semver.minor === C.minor && x.semver.patch === C.patch && (C = !1), x.operator === "<" || x.operator === "<=") {
          if (R = l(p, x, m), R === x && R !== p)
            return !1;
        } else if (p.operator === "<=" && !n(p.semver, String(x), m))
          return !1;
      }
      if (!x.operator && (p || f) && y !== 0)
        return !1;
    }
    return !(f && D && !p && y !== 0 || p && L && !f && y !== 0 || I || C);
  }, c = (d, u, m) => {
    if (!d)
      return u;
    const h = s(d.semver, u.semver, m);
    return h > 0 ? d : h < 0 || u.operator === ">" && d.operator === ">=" ? u : d;
  }, l = (d, u, m) => {
    if (!d)
      return u;
    const h = s(d.semver, u.semver, m);
    return h < 0 ? d : h > 0 || u.operator === "<" && d.operator === "<=" ? u : d;
  };
  return Ec = i, Ec;
}
var Cc, gh;
function dN() {
  if (gh) return Cc;
  gh = 1;
  const t = si(), e = ao(), r = Wt(), n = wf(), s = es(), i = zQ(), o = qQ(), a = GQ(), A = YQ(), c = JQ(), l = VQ(), d = _Q(), u = WQ(), m = Br(), h = $Q(), f = XQ(), p = kl(), y = ZQ(), w = KQ(), R = co(), D = Ml(), L = bf(), C = xf(), I = Tl(), x = Fl(), g = Rf(), B = jQ(), Q = lo(), E = Ir(), b = uo(), N = tN(), S = rN(), M = nN(), k = sN(), F = iN(), P = vl(), J = oN(), te = aN(), ee = AN(), de = cN(), ue = lN();
  return Cc = {
    parse: s,
    valid: i,
    clean: o,
    inc: a,
    diff: A,
    major: c,
    minor: l,
    patch: d,
    prerelease: u,
    compare: m,
    rcompare: h,
    compareLoose: f,
    compareBuild: p,
    sort: y,
    rsort: w,
    gt: R,
    lt: D,
    eq: L,
    neq: C,
    gte: I,
    lte: x,
    cmp: g,
    coerce: B,
    Comparator: Q,
    Range: E,
    satisfies: b,
    toComparators: N,
    maxSatisfying: S,
    minSatisfying: M,
    minVersion: k,
    validRange: F,
    outside: P,
    gtr: J,
    ltr: te,
    intersects: ee,
    simplifyRange: de,
    subset: ue,
    SemVer: r,
    re: t.re,
    src: t.src,
    tokens: t.t,
    SEMVER_SPEC_VERSION: e.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: e.RELEASE_TYPES,
    compareIdentifiers: n.compareIdentifiers,
    rcompareIdentifiers: n.rcompareIdentifiers
  }, Cc;
}
var Sr = dN(), fh = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
class uN {
  constructor(e, r, n) {
    if (e < 1)
      throw new Error("max attempts should be greater than or equal to 1");
    if (this.maxAttempts = e, this.minSeconds = Math.floor(r), this.maxSeconds = Math.floor(n), this.minSeconds > this.maxSeconds)
      throw new Error("min seconds should be less than or equal to max seconds");
  }
  execute(e, r) {
    return fh(this, void 0, void 0, function* () {
      let n = 1;
      for (; n < this.maxAttempts; ) {
        try {
          return yield e();
        } catch (i) {
          if (r && !r(i))
            throw i;
          xt(i.message);
        }
        const s = this.getSleepAmount();
        xt(`Waiting ${s} seconds before trying again`), yield this.sleep(s), n++;
      }
      return yield e();
    });
  }
  getSleepAmount() {
    return Math.floor(Math.random() * (this.maxSeconds - this.minSeconds + 1)) + this.minSeconds;
  }
  sleep(e) {
    return fh(this, void 0, void 0, function* () {
      return new Promise((r) => setTimeout(r, e * 1e3));
    });
  }
}
var Er = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
class Sf extends Error {
  constructor(e) {
    super(`Unexpected HTTP response: ${e}`), this.httpStatusCode = e, Object.setPrototypeOf(this, new.target.prototype);
  }
}
const Ll = process.platform === "win32";
process.platform;
const mN = "actions/tool-cache";
function hN(t, e, r, n) {
  return Er(this, void 0, void 0, function* () {
    e = e || De.join(kf(), Js.randomUUID()), yield jn(De.dirname(e)), le(`Downloading ${t}`), le(`Destination ${e}`);
    const s = 3, i = qc("TEST_DOWNLOAD_TOOL_RETRY_MIN_SECONDS", 10), o = qc("TEST_DOWNLOAD_TOOL_RETRY_MAX_SECONDS", 20);
    return yield new uN(s, i, o).execute(() => Er(this, void 0, void 0, function* () {
      return yield gN(t, e || "", r, n);
    }), (A) => !(A instanceof Sf && A.httpStatusCode && A.httpStatusCode < 500 && A.httpStatusCode !== 408 && A.httpStatusCode !== 429));
  });
}
function gN(t, e, r, n) {
  return Er(this, void 0, void 0, function* () {
    if (tt.existsSync(e))
      throw new Error(`Destination file path ${e} already exists`);
    const i = yield new Kn(mN, [], {
      allowRetries: !1
    }).get(t, n);
    if (i.message.statusCode !== 200) {
      const l = new Sf(i.message.statusCode);
      throw le(`Failed to download from "${t}". Code(${i.message.statusCode}) Message(${i.message.statusMessage})`), l;
    }
    const o = hl.promisify(Zg.pipeline), A = qc("TEST_DOWNLOAD_TOOL_RESPONSE_MESSAGE_FACTORY", () => i.message)();
    let c = !1;
    try {
      return yield o(A, tt.createWriteStream(e)), le("download complete"), c = !0, e;
    } finally {
      if (!c) {
        le("download failed");
        try {
          yield Oc(e);
        } catch (l) {
          le(`Failed to delete '${e}'. ${l.message}`);
        }
      }
    }
  });
}
function fN(t, e, r) {
  return Er(this, void 0, void 0, function* () {
    Ps(Ll, "extract7z() not supported on current OS"), Ps(t, 'parameter "file" is required'), e = yield Ul(e);
    const n = process.cwd();
    process.chdir(e);
    {
      const s = De.join(ty, "..", "scripts", "Invoke-7zdec.ps1").replace(/'/g, "''").replace(/"|\n|\r/g, ""), i = t.replace(/'/g, "''").replace(/"|\n|\r/g, ""), o = e.replace(/'/g, "''").replace(/"|\n|\r/g, ""), A = [
        "-NoLogo",
        "-Sta",
        "-NoProfile",
        "-NonInteractive",
        "-ExecutionPolicy",
        "Unrestricted",
        "-Command",
        `& '${s}' -Source '${i}' -Target '${o}'`
      ], c = {
        silent: !0
      };
      try {
        const l = yield br("powershell", !0);
        yield Rr(`"${l}"`, A, c);
      } finally {
        process.chdir(n);
      }
    }
    return e;
  });
}
function pN(t, e) {
  return Er(this, arguments, void 0, function* (r, n, s = "xz") {
    if (!r)
      throw new Error("parameter 'file' is required");
    n = yield Ul(n), le("Checking tar --version");
    let i = "";
    yield Rr("tar --version", [], {
      ignoreReturnCode: !0,
      silent: !0,
      listeners: {
        stdout: (l) => i += l.toString(),
        stderr: (l) => i += l.toString()
      }
    }), le(i.trim());
    const o = i.toUpperCase().includes("GNU TAR");
    let a;
    s instanceof Array ? a = s : a = [s], Sn() && !s.includes("v") && a.push("-v");
    let A = n, c = r;
    return Ll && o && (a.push("--force-local"), A = n.replace(/\\/g, "/"), c = r.replace(/\\/g, "/")), o && (a.push("--warning=no-unknown-keyword"), a.push("--overwrite")), a.push("-C", A, "-f", c), yield Rr("tar", a), n;
  });
}
function EN(t, e) {
  return Er(this, void 0, void 0, function* () {
    if (!t)
      throw new Error("parameter 'file' is required");
    return e = yield Ul(e), Ll ? yield CN(t, e) : yield BN(t, e), e;
  });
}
function CN(t, e) {
  return Er(this, void 0, void 0, function* () {
    const r = t.replace(/'/g, "''").replace(/"|\n|\r/g, ""), n = e.replace(/'/g, "''").replace(/"|\n|\r/g, ""), s = yield br("pwsh", !1);
    if (s) {
      const o = [
        "-NoLogo",
        "-NoProfile",
        "-NonInteractive",
        "-ExecutionPolicy",
        "Unrestricted",
        "-Command",
        [
          "$ErrorActionPreference = 'Stop' ;",
          "try { Add-Type -AssemblyName System.IO.Compression.ZipFile } catch { } ;",
          `try { [System.IO.Compression.ZipFile]::ExtractToDirectory('${r}', '${n}', $true) }`,
          `catch { if (($_.Exception.GetType().FullName -eq 'System.Management.Automation.MethodException') -or ($_.Exception.GetType().FullName -eq 'System.Management.Automation.RuntimeException') ){ Expand-Archive -LiteralPath '${r}' -DestinationPath '${n}' -Force } else { throw $_ } } ;`
        ].join(" ")
      ];
      le(`Using pwsh at path: ${s}`), yield Rr(`"${s}"`, o);
    } else {
      const o = [
        "-NoLogo",
        "-Sta",
        "-NoProfile",
        "-NonInteractive",
        "-ExecutionPolicy",
        "Unrestricted",
        "-Command",
        [
          "$ErrorActionPreference = 'Stop' ;",
          "try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ;",
          `if ((Get-Command -Name Expand-Archive -Module Microsoft.PowerShell.Archive -ErrorAction Ignore)) { Expand-Archive -LiteralPath '${r}' -DestinationPath '${n}' -Force }`,
          `else {[System.IO.Compression.ZipFile]::ExtractToDirectory('${r}', '${n}', $true) }`
        ].join(" ")
      ], a = yield br("powershell", !0);
      le(`Using powershell at path: ${a}`), yield Rr(`"${a}"`, o);
    }
  });
}
function BN(t, e) {
  return Er(this, void 0, void 0, function* () {
    const r = yield br("unzip", !0), n = [t];
    Sn() || n.unshift("-q"), n.unshift("-o"), yield Rr(`"${r}"`, n, { cwd: e });
  });
}
function IN(t, e, r, n) {
  return Er(this, void 0, void 0, function* () {
    if (r = Sr.clean(r) || r, n = n || Zt.arch(), le(`Caching tool ${e} ${r} ${n}`), le(`source dir: ${t}`), !tt.statSync(t).isDirectory())
      throw new Error("sourceDir is not a directory");
    const s = yield QN(e, r, n);
    for (const i of tt.readdirSync(t)) {
      const o = De.join(t, i);
      yield TQ(o, s, { recursive: !0 });
    }
    return NN(e, r, n), s;
  });
}
function ph(t, e, r) {
  if (!e)
    throw new Error("versionSpec parameter is required");
  if (r = r || Zt.arch(), !Df(e)) {
    const s = yN(t, r);
    e = wN(s, e);
  }
  let n = "";
  if (e) {
    e = Sr.clean(e) || "";
    const s = De.join(mo(), t, e, r);
    le(`checking cache: ${s}`), tt.existsSync(s) && tt.existsSync(`${s}.complete`) ? (le(`Found tool in cache ${t} ${e} ${r}`), n = s) : le("not found");
  }
  return n;
}
function yN(t, e) {
  const r = [];
  e = e || Zt.arch();
  const n = De.join(mo(), t);
  if (tt.existsSync(n)) {
    const s = tt.readdirSync(n);
    for (const i of s)
      if (Df(i)) {
        const o = De.join(n, i, e || "");
        tt.existsSync(o) && tt.existsSync(`${o}.complete`) && r.push(i);
      }
  }
  return r;
}
function Ul(t) {
  return Er(this, void 0, void 0, function* () {
    return t || (t = De.join(kf(), Js.randomUUID())), yield jn(t), t;
  });
}
function QN(t, e, r) {
  return Er(this, void 0, void 0, function* () {
    const n = De.join(mo(), t, Sr.clean(e) || e, r || "");
    le(`destination ${n}`);
    const s = `${n}.complete`;
    return yield Oc(n), yield Oc(s), yield jn(n), n;
  });
}
function NN(t, e, r) {
  const s = `${De.join(mo(), t, Sr.clean(e) || e, r || "")}.complete`;
  tt.writeFileSync(s, ""), le("finished caching tool");
}
function Df(t) {
  const e = Sr.clean(t) || "";
  le(`isExplicit: ${e}`);
  const r = Sr.valid(e) != null;
  return le(`explicit? ${r}`), r;
}
function wN(t, e) {
  let r = "";
  le(`evaluating ${t.length} versions`), t = t.sort((n, s) => Sr.gt(n, s) ? 1 : -1);
  for (let n = t.length - 1; n >= 0; n--) {
    const s = t[n];
    if (Sr.satisfies(s, e)) {
      r = s;
      break;
    }
  }
  return le(r ? `matched: ${r}` : "match not found"), r;
}
function mo() {
  const t = process.env.RUNNER_TOOL_CACHE || "";
  return Ps(t, "Expected RUNNER_TOOL_CACHE to be defined"), t;
}
function kf() {
  const t = process.env.RUNNER_TEMP || "";
  return Ps(t, "Expected RUNNER_TEMP to be defined"), t;
}
function qc(t, e) {
  const r = global[t];
  return r !== void 0 ? r : e;
}
function Eh(t) {
  const e = {
    followSymbolicLinks: !0,
    implicitDescendants: !0,
    matchDirectories: !0,
    omitBrokenSymbolicLinks: !0,
    excludeHiddenFiles: !1
  };
  return t && (typeof t.followSymbolicLinks == "boolean" && (e.followSymbolicLinks = t.followSymbolicLinks, le(`followSymbolicLinks '${e.followSymbolicLinks}'`)), typeof t.implicitDescendants == "boolean" && (e.implicitDescendants = t.implicitDescendants, le(`implicitDescendants '${e.implicitDescendants}'`)), typeof t.matchDirectories == "boolean" && (e.matchDirectories = t.matchDirectories, le(`matchDirectories '${e.matchDirectories}'`)), typeof t.omitBrokenSymbolicLinks == "boolean" && (e.omitBrokenSymbolicLinks = t.omitBrokenSymbolicLinks, le(`omitBrokenSymbolicLinks '${e.omitBrokenSymbolicLinks}'`)), typeof t.excludeHiddenFiles == "boolean" && (e.excludeHiddenFiles = t.excludeHiddenFiles, le(`excludeHiddenFiles '${e.excludeHiddenFiles}'`))), e;
}
const Zr = process.platform === "win32";
function Yn(t) {
  if (t = In(t), Zr && /^\\\\[^\\]+(\\[^\\]+)?$/.test(t))
    return t;
  let e = De.dirname(t);
  return Zr && /^\\\\[^\\]+\\[^\\]+\\$/.test(e) && (e = In(e)), e;
}
function Bc(t, e) {
  if (yt(t, "ensureAbsoluteRoot parameter 'root' must not be empty"), yt(e, "ensureAbsoluteRoot parameter 'itemPath' must not be empty"), Ui(e))
    return e;
  if (Zr) {
    if (e.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
      let r = process.cwd();
      return yt(r.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${r}'`), e[0].toUpperCase() === r[0].toUpperCase() ? e.length === 2 ? `${e[0]}:\\${r.substr(3)}` : (r.endsWith("\\") || (r += "\\"), `${e[0]}:\\${r.substr(3)}${e.substr(2)}`) : `${e[0]}:\\${e.substr(2)}`;
    } else if (Pr(e).match(/^\\$|^\\[^\\]/)) {
      const r = process.cwd();
      return yt(r.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${r}'`), `${r[0]}:\\${e.substr(1)}`;
    }
  }
  return yt(Ui(t), "ensureAbsoluteRoot parameter 'root' must have an absolute root"), t.endsWith("/") || Zr && t.endsWith("\\") || (t += De.sep), t + e;
}
function Ui(t) {
  return yt(t, "hasAbsoluteRoot parameter 'itemPath' must not be empty"), t = Pr(t), Zr ? t.startsWith("\\\\") || /^[A-Z]:\\/i.test(t) : t.startsWith("/");
}
function Gc(t) {
  return yt(t, "isRooted parameter 'itemPath' must not be empty"), t = Pr(t), Zr ? t.startsWith("\\") || /^[A-Z]:/i.test(t) : t.startsWith("/");
}
function Pr(t) {
  return t = t || "", Zr ? (t = t.replace(/\//g, "\\"), (/^\\\\+[^\\]/.test(t) ? "\\" : "") + t.replace(/\\\\+/g, "\\")) : t.replace(/\/\/+/g, "/");
}
function In(t) {
  return t ? (t = Pr(t), !t.endsWith(De.sep) || t === De.sep || Zr && /^[A-Z]:\\$/i.test(t) ? t : t.substr(0, t.length - 1)) : "";
}
var Wr;
(function(t) {
  t[t.None = 0] = "None", t[t.Directory = 1] = "Directory", t[t.File = 2] = "File", t[t.All = 3] = "All";
})(Wr || (Wr = {}));
const Ch = process.platform === "win32";
function Bh(t) {
  t = t.filter((n) => !n.negate);
  const e = {};
  for (const n of t) {
    const s = Ch ? n.searchPath.toUpperCase() : n.searchPath;
    e[s] = "candidate";
  }
  const r = [];
  for (const n of t) {
    const s = Ch ? n.searchPath.toUpperCase() : n.searchPath;
    if (e[s] === "included")
      continue;
    let i = !1, o = s, a = Yn(o);
    for (; a !== o; ) {
      if (e[a]) {
        i = !0;
        break;
      }
      o = a, a = Yn(o);
    }
    i || (r.push(n.searchPath), e[s] = "included");
  }
  return r;
}
function bN(t, e) {
  let r = Wr.None;
  for (const n of t)
    n.negate ? r &= ~n.match(e) : r |= n.match(e);
  return r;
}
function xN(t, e) {
  return t.some((r) => !r.negate && r.partialMatch(e));
}
var Ic, Ih;
function RN() {
  if (Ih) return Ic;
  Ih = 1, Ic = function(e, r) {
    for (var n = [], s = 0; s < e.length; s++) {
      var i = r(e[s], s);
      t(i) ? n.push.apply(n, i) : n.push(i);
    }
    return n;
  };
  var t = Array.isArray || function(e) {
    return Object.prototype.toString.call(e) === "[object Array]";
  };
  return Ic;
}
var yc, yh;
function SN() {
  if (yh) return yc;
  yh = 1, yc = t;
  function t(n, s, i) {
    n instanceof RegExp && (n = e(n, i)), s instanceof RegExp && (s = e(s, i));
    var o = r(n, s, i);
    return o && {
      start: o[0],
      end: o[1],
      pre: i.slice(0, o[0]),
      body: i.slice(o[0] + n.length, o[1]),
      post: i.slice(o[1] + s.length)
    };
  }
  function e(n, s) {
    var i = s.match(n);
    return i ? i[0] : null;
  }
  t.range = r;
  function r(n, s, i) {
    var o, a, A, c, l, d = i.indexOf(n), u = i.indexOf(s, d + 1), m = d;
    if (d >= 0 && u > 0) {
      if (n === s)
        return [d, u];
      for (o = [], A = i.length; m >= 0 && !l; )
        m == d ? (o.push(m), d = i.indexOf(n, m + 1)) : o.length == 1 ? l = [o.pop(), u] : (a = o.pop(), a < A && (A = a, c = u), u = i.indexOf(s, m + 1)), m = d < u && d >= 0 ? d : u;
      o.length && (l = [A, c]);
    }
    return l;
  }
  return yc;
}
var Qc, Qh;
function DN() {
  if (Qh) return Qc;
  Qh = 1;
  var t = RN(), e = SN();
  Qc = d;
  var r = "\0SLASH" + Math.random() + "\0", n = "\0OPEN" + Math.random() + "\0", s = "\0CLOSE" + Math.random() + "\0", i = "\0COMMA" + Math.random() + "\0", o = "\0PERIOD" + Math.random() + "\0";
  function a(y) {
    return parseInt(y, 10) == y ? parseInt(y, 10) : y.charCodeAt(0);
  }
  function A(y) {
    return y.split("\\\\").join(r).split("\\{").join(n).split("\\}").join(s).split("\\,").join(i).split("\\.").join(o);
  }
  function c(y) {
    return y.split(r).join("\\").split(n).join("{").split(s).join("}").split(i).join(",").split(o).join(".");
  }
  function l(y) {
    if (!y)
      return [""];
    var w = [], R = e("{", "}", y);
    if (!R)
      return y.split(",");
    var D = R.pre, L = R.body, C = R.post, I = D.split(",");
    I[I.length - 1] += "{" + L + "}";
    var x = l(C);
    return C.length && (I[I.length - 1] += x.shift(), I.push.apply(I, x)), w.push.apply(w, I), w;
  }
  function d(y) {
    return y ? (y.substr(0, 2) === "{}" && (y = "\\{\\}" + y.substr(2)), p(A(y), !0).map(c)) : [];
  }
  function u(y) {
    return "{" + y + "}";
  }
  function m(y) {
    return /^-?0\d/.test(y);
  }
  function h(y, w) {
    return y <= w;
  }
  function f(y, w) {
    return y >= w;
  }
  function p(y, w) {
    var R = [], D = e("{", "}", y);
    if (!D || /\$$/.test(D.pre)) return [y];
    var L = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(D.body), C = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(D.body), I = L || C, x = D.body.indexOf(",") >= 0;
    if (!I && !x)
      return D.post.match(/,(?!,).*\}/) ? (y = D.pre + "{" + D.body + s + D.post, p(y)) : [y];
    var g;
    if (I)
      g = D.body.split(/\.\./);
    else if (g = l(D.body), g.length === 1 && (g = p(g[0], !1).map(u), g.length === 1)) {
      var Q = D.post.length ? p(D.post, !1) : [""];
      return Q.map(function(Z) {
        return D.pre + g[0] + Z;
      });
    }
    var B = D.pre, Q = D.post.length ? p(D.post, !1) : [""], E;
    if (I) {
      var b = a(g[0]), N = a(g[1]), S = Math.max(g[0].length, g[1].length), M = g.length == 3 ? Math.abs(a(g[2])) : 1, k = h, F = N < b;
      F && (M *= -1, k = f);
      var P = g.some(m);
      E = [];
      for (var J = b; k(J, N); J += M) {
        var te;
        if (C)
          te = String.fromCharCode(J), te === "\\" && (te = "");
        else if (te = String(J), P) {
          var ee = S - te.length;
          if (ee > 0) {
            var de = new Array(ee + 1).join("0");
            J < 0 ? te = "-" + de + te.slice(1) : te = de + te;
          }
        }
        E.push(te);
      }
    } else
      E = t(g, function(Ce) {
        return p(Ce, !1);
      });
    for (var ue = 0; ue < E.length; ue++)
      for (var ce = 0; ce < Q.length; ce++) {
        var fe = B + E[ue] + Q[ce];
        (!w || I || fe) && R.push(fe);
      }
    return R;
  }
  return Qc;
}
var Nc, Nh;
function kN() {
  if (Nh) return Nc;
  Nh = 1, Nc = m, m.Minimatch = h;
  var t = (function() {
    try {
      return Wn("path");
    } catch {
    }
  })() || {
    sep: "/"
  };
  m.sep = t.sep;
  var e = m.GLOBSTAR = h.GLOBSTAR = {}, r = DN(), n = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, s = "[^/]", i = s + "*?", o = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", a = "(?:(?!(?:\\/|^)\\.).)*?", A = c("().*{}+?[]^$\\!");
  function c(g) {
    return g.split("").reduce(function(B, Q) {
      return B[Q] = !0, B;
    }, {});
  }
  var l = /\/+/;
  m.filter = d;
  function d(g, B) {
    return B = B || {}, function(Q, E, b) {
      return m(Q, g, B);
    };
  }
  function u(g, B) {
    B = B || {};
    var Q = {};
    return Object.keys(g).forEach(function(E) {
      Q[E] = g[E];
    }), Object.keys(B).forEach(function(E) {
      Q[E] = B[E];
    }), Q;
  }
  m.defaults = function(g) {
    if (!g || typeof g != "object" || !Object.keys(g).length)
      return m;
    var B = m, Q = function(b, N, S) {
      return B(b, N, u(g, S));
    };
    return Q.Minimatch = function(b, N) {
      return new B.Minimatch(b, u(g, N));
    }, Q.Minimatch.defaults = function(b) {
      return B.defaults(u(g, b)).Minimatch;
    }, Q.filter = function(b, N) {
      return B.filter(b, u(g, N));
    }, Q.defaults = function(b) {
      return B.defaults(u(g, b));
    }, Q.makeRe = function(b, N) {
      return B.makeRe(b, u(g, N));
    }, Q.braceExpand = function(b, N) {
      return B.braceExpand(b, u(g, N));
    }, Q.match = function(E, b, N) {
      return B.match(E, b, u(g, N));
    }, Q;
  }, h.defaults = function(g) {
    return m.defaults(g).Minimatch;
  };
  function m(g, B, Q) {
    return R(B), Q || (Q = {}), !Q.nocomment && B.charAt(0) === "#" ? !1 : new h(B, Q).match(g);
  }
  function h(g, B) {
    if (!(this instanceof h))
      return new h(g, B);
    R(g), B || (B = {}), g = g.trim(), !B.allowWindowsEscape && t.sep !== "/" && (g = g.split(t.sep).join("/")), this.options = B, this.maxGlobstarRecursion = B.maxGlobstarRecursion !== void 0 ? B.maxGlobstarRecursion : 200, this.set = [], this.pattern = g, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!B.partial, this.make();
  }
  h.prototype.debug = function() {
  }, h.prototype.make = f;
  function f() {
    var g = this.pattern, B = this.options;
    if (!B.nocomment && g.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!g) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    var Q = this.globSet = this.braceExpand();
    B.debug && (this.debug = function() {
      console.error.apply(console, arguments);
    }), this.debug(this.pattern, Q), Q = this.globParts = Q.map(function(E) {
      return E.split(l);
    }), this.debug(this.pattern, Q), Q = Q.map(function(E, b, N) {
      return E.map(this.parse, this);
    }, this), this.debug(this.pattern, Q), Q = Q.filter(function(E) {
      return E.indexOf(!1) === -1;
    }), this.debug(this.pattern, Q), this.set = Q;
  }
  h.prototype.parseNegate = p;
  function p() {
    var g = this.pattern, B = !1, Q = this.options, E = 0;
    if (!Q.nonegate) {
      for (var b = 0, N = g.length; b < N && g.charAt(b) === "!"; b++)
        B = !B, E++;
      E && (this.pattern = g.substr(E)), this.negate = B;
    }
  }
  m.braceExpand = function(g, B) {
    return y(g, B);
  }, h.prototype.braceExpand = y;
  function y(g, B) {
    return B || (this instanceof h ? B = this.options : B = {}), g = typeof g > "u" ? this.pattern : g, R(g), B.nobrace || !/\{(?:(?!\{).)*\}/.test(g) ? [g] : r(g);
  }
  var w = 1024 * 64, R = function(g) {
    if (typeof g != "string")
      throw new TypeError("invalid pattern");
    if (g.length > w)
      throw new TypeError("pattern is too long");
  };
  h.prototype.parse = L;
  var D = {};
  function L(g, B) {
    R(g);
    var Q = this.options;
    if (g === "**")
      if (Q.noglobstar)
        g = "*";
      else
        return e;
    if (g === "") return "";
    var E = "", b = !!Q.nocase, N = !1, S = [], M = [], k, F = !1, P = -1, J = -1, te = g.charAt(0) === "." ? "" : Q.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", ee = this;
    function de() {
      if (k) {
        switch (k) {
          case "*":
            E += i, b = !0;
            break;
          case "?":
            E += s, b = !0;
            break;
          default:
            E += "\\" + k;
            break;
        }
        ee.debug("clearStateChar %j %j", k, E), k = !1;
      }
    }
    for (var ue = 0, ce = g.length, fe; ue < ce && (fe = g.charAt(ue)); ue++) {
      if (this.debug("%s	%s %s %j", g, ue, E, fe), N && A[fe]) {
        E += "\\" + fe, N = !1;
        continue;
      }
      switch (fe) {
        /* istanbul ignore next */
        case "/":
          return !1;
        case "\\":
          de(), N = !0;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", g, ue, E, fe), F) {
            this.debug("  in class"), fe === "!" && ue === J + 1 && (fe = "^"), E += fe;
            continue;
          }
          if (fe === "*" && k === "*") continue;
          ee.debug("call clearStateChar %j", k), de(), k = fe, Q.noext && de();
          continue;
        case "(":
          if (F) {
            E += "(";
            continue;
          }
          if (!k) {
            E += "\\(";
            continue;
          }
          S.push({
            type: k,
            start: ue - 1,
            reStart: E.length,
            open: n[k].open,
            close: n[k].close
          }), E += k === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", k, E), k = !1;
          continue;
        case ")":
          if (F || !S.length) {
            E += "\\)";
            continue;
          }
          de(), b = !0;
          var Ce = S.pop();
          E += Ce.close, Ce.type === "!" && M.push(Ce), Ce.reEnd = E.length;
          continue;
        case "|":
          if (F || !S.length || N) {
            E += "\\|", N = !1;
            continue;
          }
          de(), E += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          if (de(), F) {
            E += "\\" + fe;
            continue;
          }
          F = !0, J = ue, P = E.length, E += fe;
          continue;
        case "]":
          if (ue === J + 1 || !F) {
            E += "\\" + fe, N = !1;
            continue;
          }
          var Z = g.substring(J + 1, ue);
          try {
            RegExp("[" + Z + "]");
          } catch {
            var _ = this.parse(Z, D);
            E = E.substr(0, P) + "\\[" + _[0] + "\\]", b = b || _[1], F = !1;
            continue;
          }
          b = !0, F = !1, E += fe;
          continue;
        default:
          de(), N ? N = !1 : A[fe] && !(fe === "^" && F) && (E += "\\"), E += fe;
      }
    }
    for (F && (Z = g.substr(J + 1), _ = this.parse(Z, D), E = E.substr(0, P) + "\\[" + _[0], b = b || _[1]), Ce = S.pop(); Ce; Ce = S.pop()) {
      var ne = E.slice(Ce.reStart + Ce.open.length);
      this.debug("setting tail", E, Ce), ne = ne.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(ut, At, rt) {
        return rt || (rt = "\\"), At + At + rt + "|";
      }), this.debug(`tail=%j
   %s`, ne, ne, Ce, E);
      var H = Ce.type === "*" ? i : Ce.type === "?" ? s : "\\" + Ce.type;
      b = !0, E = E.slice(0, Ce.reStart) + H + "\\(" + ne;
    }
    de(), N && (E += "\\\\");
    var W = !1;
    switch (E.charAt(0)) {
      case "[":
      case ".":
      case "(":
        W = !0;
    }
    for (var z = M.length - 1; z > -1; z--) {
      var $ = M[z], Ae = E.slice(0, $.reStart), pe = E.slice($.reStart, $.reEnd - 8), me = E.slice($.reEnd - 8, $.reEnd), xe = E.slice($.reEnd);
      me += xe;
      var _e = Ae.split("(").length - 1, ke = xe;
      for (ue = 0; ue < _e; ue++)
        ke = ke.replace(/\)[+*?]?/, "");
      xe = ke;
      var We = "";
      xe === "" && B !== D && (We = "$");
      var ve = Ae + pe + xe + We + me;
      E = ve;
    }
    if (E !== "" && b && (E = "(?=.)" + E), W && (E = te + E), B === D)
      return [E, b];
    if (!b)
      return I(g);
    var He = Q.nocase ? "i" : "";
    try {
      var Re = new RegExp("^" + E + "$", He);
    } catch {
      return new RegExp("$.");
    }
    return Re._glob = g, Re._src = E, Re;
  }
  m.makeRe = function(g, B) {
    return new h(g, B || {}).makeRe();
  }, h.prototype.makeRe = C;
  function C() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    var g = this.set;
    if (!g.length)
      return this.regexp = !1, this.regexp;
    var B = this.options, Q = B.noglobstar ? i : B.dot ? o : a, E = B.nocase ? "i" : "", b = g.map(function(N) {
      return N.map(function(S) {
        return S === e ? Q : typeof S == "string" ? x(S) : S._src;
      }).join("\\/");
    }).join("|");
    b = "^(?:" + b + ")$", this.negate && (b = "^(?!" + b + ").*$");
    try {
      this.regexp = new RegExp(b, E);
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  m.match = function(g, B, Q) {
    Q = Q || {};
    var E = new h(B, Q);
    return g = g.filter(function(b) {
      return E.match(b);
    }), E.options.nonull && !g.length && g.push(B), g;
  }, h.prototype.match = function(B, Q) {
    if (typeof Q > "u" && (Q = this.partial), this.debug("match", B, this.pattern), this.comment) return !1;
    if (this.empty) return B === "";
    if (B === "/" && Q) return !0;
    var E = this.options;
    t.sep !== "/" && (B = B.split(t.sep).join("/")), B = B.split(l), this.debug(this.pattern, "split", B);
    var b = this.set;
    this.debug(this.pattern, "set", b);
    var N, S;
    for (S = B.length - 1; S >= 0 && (N = B[S], !N); S--)
      ;
    for (S = 0; S < b.length; S++) {
      var M = b[S], k = B;
      E.matchBase && M.length === 1 && (k = [N]);
      var F = this.matchOne(k, M, Q);
      if (F)
        return E.flipNegate ? !0 : !this.negate;
    }
    return E.flipNegate ? !1 : this.negate;
  }, h.prototype.matchOne = function(g, B, Q) {
    return B.indexOf(e) !== -1 ? this._matchGlobstar(g, B, Q, 0, 0) : this._matchOne(g, B, Q, 0, 0);
  }, h.prototype._matchGlobstar = function(g, B, Q, E, b) {
    var N, S = -1;
    for (N = b; N < B.length; N++)
      if (B[N] === e) {
        S = N;
        break;
      }
    var M = -1;
    for (N = B.length - 1; N >= 0; N--)
      if (B[N] === e) {
        M = N;
        break;
      }
    var k = B.slice(b, S), F = B.slice(S + 1, M), P = B.slice(M + 1);
    if (k.length) {
      var J = g.slice(E, E + k.length);
      if (!this._matchOne(J, k, Q, 0, 0))
        return !1;
      E += k.length;
    }
    var te = 0;
    if (P.length) {
      if (P.length + E > g.length) return !1;
      var ee = g.length - P.length;
      if (this._matchOne(g, P, Q, ee, 0))
        te = P.length;
      else {
        if (g[g.length - 1] !== "" || E + P.length === g.length || (ee--, !this._matchOne(g, P, Q, ee, 0)))
          return !1;
        te = P.length + 1;
      }
    }
    if (!F.length) {
      var de = !!te;
      for (N = E; N < g.length - te; N++) {
        var ue = String(g[N]);
        if (de = !0, ue === "." || ue === ".." || !this.options.dot && ue.charAt(0) === ".")
          return !1;
      }
      return de;
    }
    for (var ce = [[[], 0]], fe = ce[0], Ce = 0, Z = [0], _ = 0; _ < F.length; _++) {
      var ne = F[_];
      ne === e ? (Z.push(Ce), fe = [[], 0], ce.push(fe)) : (fe[0].push(ne), Ce++);
    }
    for (var H = ce.length - 1, W = g.length - te, z = 0; z < ce.length; z++)
      ce[z][1] = W - (Z[H--] + ce[z][0].length);
    return !!this._matchGlobStarBodySections(
      g,
      ce,
      E,
      0,
      Q,
      0,
      !!te
    );
  }, h.prototype._matchGlobStarBodySections = function(g, B, Q, E, b, N, S) {
    var M = B[E];
    if (!M) {
      for (var k = Q; k < g.length; k++) {
        S = !0;
        var F = g[k];
        if (F === "." || F === ".." || !this.options.dot && F.charAt(0) === ".")
          return !1;
      }
      return S;
    }
    for (var P = M[0], J = M[1]; Q <= J; ) {
      var te = this._matchOne(
        g.slice(0, Q + P.length),
        P,
        b,
        Q,
        0
      );
      if (te && N < this.maxGlobstarRecursion) {
        var ee = this._matchGlobStarBodySections(
          g,
          B,
          Q + P.length,
          E + 1,
          b,
          N + 1,
          S
        );
        if (ee !== !1)
          return ee;
      }
      var F = g[Q];
      if (F === "." || F === ".." || !this.options.dot && F.charAt(0) === ".")
        return !1;
      Q++;
    }
    return null;
  }, h.prototype._matchOne = function(g, B, Q, E, b) {
    var N, S, M, k;
    for (N = E, S = b, M = g.length, k = B.length; N < M && S < k; N++, S++) {
      this.debug("matchOne loop");
      var F = B[S], P = g[N];
      if (this.debug(B, F, P), F === !1 || F === e) return !1;
      var J;
      if (typeof F == "string" ? (J = P === F, this.debug("string match", F, P, J)) : (J = P.match(F), this.debug("pattern match", F, P, J)), !J) return !1;
    }
    if (N === M && S === k)
      return !0;
    if (N === M)
      return Q;
    if (S === k)
      return N === M - 1 && g[N] === "";
    throw new Error("wtf?");
  };
  function I(g) {
    return g.replace(/\\(.)/g, "$1");
  }
  function x(g) {
    return g.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return Nc;
}
var MN = kN();
const TN = /* @__PURE__ */ xy(MN), FN = process.platform === "win32";
class Ii {
  /**
   * Constructs a Path
   * @param itemPath Path or array of segments
   */
  constructor(e) {
    if (this.segments = [], typeof e == "string")
      if (yt(e, "Parameter 'itemPath' must not be empty"), e = In(e), !Gc(e))
        this.segments = e.split(De.sep);
      else {
        let r = e, n = Yn(r);
        for (; n !== r; ) {
          const s = De.basename(r);
          this.segments.unshift(s), r = n, n = Yn(r);
        }
        this.segments.unshift(r);
      }
    else {
      yt(e.length > 0, "Parameter 'itemPath' must not be an empty array");
      for (let r = 0; r < e.length; r++) {
        let n = e[r];
        yt(n, "Parameter 'itemPath' must not contain any empty segments"), n = Pr(e[r]), r === 0 && Gc(n) ? (n = In(n), yt(n === Yn(n), "Parameter 'itemPath' root segment contains information for multiple segments"), this.segments.push(n)) : (yt(!n.includes(De.sep), "Parameter 'itemPath' contains unexpected path separators"), this.segments.push(n));
      }
    }
  }
  /**
   * Converts the path to it's string representation
   */
  toString() {
    let e = this.segments[0], r = e.endsWith(De.sep) || FN && /^[A-Z]:$/i.test(e);
    for (let n = 1; n < this.segments.length; n++)
      r ? r = !1 : e += De.sep, e += this.segments[n];
    return e;
  }
}
const { Minimatch: vN } = TN, vr = process.platform === "win32";
class rr {
  constructor(e, r = !1, n, s) {
    this.negate = !1;
    let i;
    if (typeof e == "string")
      i = e.trim();
    else {
      n = n || [], yt(n.length, "Parameter 'segments' must not empty");
      const c = rr.getLiteral(n[0]);
      yt(c && Ui(c), "Parameter 'segments' first element must be a root path"), i = new Ii(n).toString().trim(), e && (i = `!${i}`);
    }
    for (; i.startsWith("!"); )
      this.negate = !this.negate, i = i.substr(1).trim();
    i = rr.fixupPattern(i, s), this.segments = new Ii(i).segments, this.trailingSeparator = Pr(i).endsWith(De.sep), i = In(i);
    let o = !1;
    const a = this.segments.map((c) => rr.getLiteral(c)).filter((c) => !o && !(o = c === ""));
    this.searchPath = new Ii(a).toString(), this.rootRegExp = new RegExp(rr.regExpEscape(a[0]), vr ? "i" : ""), this.isImplicitPattern = r;
    const A = {
      dot: !0,
      nobrace: !0,
      nocase: vr,
      nocomment: !0,
      noext: !0,
      nonegate: !0
    };
    i = vr ? i.replace(/\\/g, "/") : i, this.minimatch = new vN(i, A);
  }
  /**
   * Matches the pattern against the specified path
   */
  match(e) {
    return this.segments[this.segments.length - 1] === "**" ? (e = Pr(e), !e.endsWith(De.sep) && this.isImplicitPattern === !1 && (e = `${e}${De.sep}`)) : e = In(e), this.minimatch.match(e) ? this.trailingSeparator ? Wr.Directory : Wr.All : Wr.None;
  }
  /**
   * Indicates whether the pattern may match descendants of the specified path
   */
  partialMatch(e) {
    return e = In(e), Yn(e) === e ? this.rootRegExp.test(e) : this.minimatch.matchOne(e.split(vr ? /\\+/ : /\/+/), this.minimatch.set[0], !0);
  }
  /**
   * Escapes glob patterns within a path
   */
  static globEscape(e) {
    return (vr ? e : e.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
  }
  /**
   * Normalizes slashes and ensures absolute root
   */
  static fixupPattern(e, r) {
    yt(e, "pattern cannot be empty");
    const n = new Ii(e).segments.map((s) => rr.getLiteral(s));
    if (yt(n.every((s, i) => (s !== "." || i === 0) && s !== ".."), `Invalid pattern '${e}'. Relative pathing '.' and '..' is not allowed.`), yt(!Gc(e) || n[0], `Invalid pattern '${e}'. Root segment must not contain globs.`), e = Pr(e), e === "." || e.startsWith(`.${De.sep}`))
      e = rr.globEscape(process.cwd()) + e.substr(1);
    else if (e === "~" || e.startsWith(`~${De.sep}`))
      r = r || Zt.homedir(), yt(r, "Unable to determine HOME directory"), yt(Ui(r), `Expected HOME directory to be a rooted path. Actual '${r}'`), e = rr.globEscape(r) + e.substr(1);
    else if (vr && (e.match(/^[A-Z]:$/i) || e.match(/^[A-Z]:[^\\]/i))) {
      let s = Bc("C:\\dummy-root", e.substr(0, 2));
      e.length > 2 && !s.endsWith("\\") && (s += "\\"), e = rr.globEscape(s) + e.substr(2);
    } else if (vr && (e === "\\" || e.match(/^\\[^\\]/))) {
      let s = Bc("C:\\dummy-root", "\\");
      s.endsWith("\\") || (s += "\\"), e = rr.globEscape(s) + e.substr(1);
    } else
      e = Bc(rr.globEscape(process.cwd()), e);
    return Pr(e);
  }
  /**
   * Attempts to unescape a pattern segment to create a literal path segment.
   * Otherwise returns empty string.
   */
  static getLiteral(e) {
    let r = "";
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s === "\\" && !vr && n + 1 < e.length) {
        r += e[++n];
        continue;
      } else {
        if (s === "*" || s === "?")
          return "";
        if (s === "[" && n + 1 < e.length) {
          let i = "", o = -1;
          for (let a = n + 1; a < e.length; a++) {
            const A = e[a];
            if (A === "\\" && !vr && a + 1 < e.length) {
              i += e[++a];
              continue;
            } else if (A === "]") {
              o = a;
              break;
            } else
              i += A;
          }
          if (o >= 0) {
            if (i.length > 1)
              return "";
            if (i) {
              r += i, n = o;
              continue;
            }
          }
        }
      }
      r += s;
    }
    return r;
  }
  /**
   * Escapes regexp special characters
   * https://javascript.info/regexp-escaping
   */
  static regExpEscape(e) {
    return e.replace(/[[\\^$.|?*+()]/g, "\\$&");
  }
}
class wh {
  constructor(e, r) {
    this.path = e, this.level = r;
  }
}
var wc = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
}, LN = function(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof __values == "function" ? __values(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(i) {
    r[i] = t[i] && function(o) {
      return new Promise(function(a, A) {
        o = t[i](o), s(a, A, o.done, o.value);
      });
    };
  }
  function s(i, o, a, A) {
    Promise.resolve(A).then(function(c) {
      i({ value: c, done: a });
    }, o);
  }
}, _r = function(t) {
  return this instanceof _r ? (this.v = t, this) : new _r(t);
}, UN = function(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), s, i = [];
  return s = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", o), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(m) {
    return function(h) {
      return Promise.resolve(h).then(m, d);
    };
  }
  function a(m, h) {
    n[m] && (s[m] = function(f) {
      return new Promise(function(p, y) {
        i.push([m, f, p, y]) > 1 || A(m, f);
      });
    }, h && (s[m] = h(s[m])));
  }
  function A(m, h) {
    try {
      c(n[m](h));
    } catch (f) {
      u(i[0][3], f);
    }
  }
  function c(m) {
    m.value instanceof _r ? Promise.resolve(m.value.v).then(l, d) : u(i[0][2], m);
  }
  function l(m) {
    A("next", m);
  }
  function d(m) {
    A("throw", m);
  }
  function u(m, h) {
    m(h), i.shift(), i.length && A(i[0][0], i[0][1]);
  }
};
const PN = process.platform === "win32";
class Pi {
  constructor(e) {
    this.patterns = [], this.searchPaths = [], this.options = Eh(e);
  }
  getSearchPaths() {
    return this.searchPaths.slice();
  }
  glob() {
    return wc(this, void 0, void 0, function* () {
      var e, r, n, s;
      const i = [];
      try {
        for (var o = !0, a = LN(this.globGenerator()), A; A = yield a.next(), e = A.done, !e; o = !0) {
          s = A.value, o = !1;
          const c = s;
          i.push(c);
        }
      } catch (c) {
        r = { error: c };
      } finally {
        try {
          !o && !e && (n = a.return) && (yield n.call(a));
        } finally {
          if (r) throw r.error;
        }
      }
      return i;
    });
  }
  globGenerator() {
    return UN(this, arguments, function* () {
      const r = Eh(this.options), n = [];
      for (const o of this.patterns)
        n.push(o), r.implicitDescendants && (o.trailingSeparator || o.segments[o.segments.length - 1] !== "**") && n.push(new rr(o.negate, !0, o.segments.concat("**")));
      const s = [];
      for (const o of Bh(n)) {
        le(`Search path '${o}'`);
        try {
          yield _r(tt.promises.lstat(o));
        } catch (a) {
          if (a.code === "ENOENT")
            continue;
          throw a;
        }
        s.unshift(new wh(o, 1));
      }
      const i = [];
      for (; s.length; ) {
        const o = s.pop(), a = bN(n, o.path), A = !!a || xN(n, o.path);
        if (!a && !A)
          continue;
        const c = yield _r(
          Pi.stat(o, r, i)
          // Broken symlink, or symlink cycle detected, or no longer exists
        );
        if (c && !(r.excludeHiddenFiles && De.basename(o.path).match(/^\./)))
          if (c.isDirectory()) {
            if (a & Wr.Directory && r.matchDirectories)
              yield yield _r(o.path);
            else if (!A)
              continue;
            const l = o.level + 1, d = (yield _r(tt.promises.readdir(o.path))).map((u) => new wh(De.join(o.path, u), l));
            s.push(...d.reverse());
          } else a & Wr.File && (yield yield _r(o.path));
      }
    });
  }
  /**
   * Constructs a DefaultGlobber
   */
  static create(e, r) {
    return wc(this, void 0, void 0, function* () {
      const n = new Pi(r);
      PN && (e = e.replace(/\r\n/g, `
`), e = e.replace(/\r/g, `
`));
      const s = e.split(`
`).map((i) => i.trim());
      for (const i of s)
        !i || i.startsWith("#") || n.patterns.push(new rr(i));
      return n.searchPaths.push(...Bh(n.patterns)), n;
    });
  }
  static stat(e, r, n) {
    return wc(this, void 0, void 0, function* () {
      let s;
      if (r.followSymbolicLinks)
        try {
          s = yield tt.promises.stat(e.path);
        } catch (i) {
          if (i.code === "ENOENT") {
            if (r.omitBrokenSymbolicLinks) {
              le(`Broken symlink '${e.path}'`);
              return;
            }
            throw new Error(`No information found for the path '${e.path}'. This may indicate a broken symbolic link.`);
          }
          throw i;
        }
      else
        s = yield tt.promises.lstat(e.path);
      if (s.isDirectory() && r.followSymbolicLinks) {
        const i = yield tt.promises.realpath(e.path);
        for (; n.length >= e.level; )
          n.pop();
        if (n.some((o) => o === i)) {
          le(`Symlink cycle detected for path '${e.path}' and realpath '${i}'`);
          return;
        }
        n.push(i);
      }
      return s;
    });
  }
}
var HN = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
function ON(t, e) {
  return HN(this, void 0, void 0, function* () {
    return yield Pi.create(t, e);
  });
}
var Hi;
(function(t) {
  t.Gzip = "cache.tgz", t.Zstd = "cache.tzst";
})(Hi || (Hi = {}));
var ir;
(function(t) {
  t.Gzip = "gzip", t.ZstdWithoutLong = "zstd-without-long", t.Zstd = "zstd";
})(ir || (ir = {}));
var cr;
(function(t) {
  t.GNU = "gnu", t.BSD = "bsd";
})(cr || (cr = {}));
const Pl = 2, Hl = 5e3, bh = 5e3, xh = `${process.env.PROGRAMFILES}\\Git\\usr\\bin\\tar.exe`, zN = `${process.env.SYSTEMDRIVE}\\Windows\\System32\\tar.exe`, Oi = "cache.tar", Mf = "manifest.txt";
var ts = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
}, qN = function(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof __values == "function" ? __values(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(i) {
    r[i] = t[i] && function(o) {
      return new Promise(function(a, A) {
        o = t[i](o), s(a, A, o.done, o.value);
      });
    };
  }
  function s(i, o, a, A) {
    Promise.resolve(A).then(function(c) {
      i({ value: c, done: a });
    }, o);
  }
};
const GN = "1.0";
function ho() {
  return ts(this, void 0, void 0, function* () {
    const t = process.platform === "win32";
    let e = process.env.RUNNER_TEMP || "";
    if (!e) {
      let n;
      t ? n = process.env.USERPROFILE || "C:\\" : process.platform === "darwin" ? n = "/Users" : n = "/home", e = De.join(n, "actions", "temp");
    }
    const r = De.join(e, Js.randomUUID());
    return yield jn(r), r;
  });
}
function Dn(t) {
  return tt.statSync(t).size;
}
function Tf(t) {
  return ts(this, void 0, void 0, function* () {
    var e, r, n, s, i;
    const o = [], a = (i = process.env.GITHUB_WORKSPACE) !== null && i !== void 0 ? i : process.cwd(), A = yield ON(t.join(`
`), {
      implicitDescendants: !1
    });
    try {
      for (var c = !0, l = qN(A.globGenerator()), d; d = yield l.next(), e = d.done, !e; c = !0) {
        s = d.value, c = !1;
        const u = s, m = De.relative(a, u).replace(new RegExp(`\\${De.sep}`, "g"), "/");
        le(`Matched: ${m}`), m === "" ? o.push(".") : o.push(`${m}`);
      }
    } catch (u) {
      r = { error: u };
    } finally {
      try {
        !c && !e && (n = l.return) && (yield n.call(l));
      } finally {
        if (r) throw r.error;
      }
    }
    return o;
  });
}
function go(t) {
  return ts(this, void 0, void 0, function* () {
    return hl.promisify(tt.unlink)(t);
  });
}
function Ff(t) {
  return ts(this, arguments, void 0, function* (e, r = []) {
    let n = "";
    r.push("--version"), le(`Checking ${e} ${r.join(" ")}`);
    try {
      yield Rr(`${e}`, r, {
        ignoreReturnCode: !0,
        silent: !0,
        listeners: {
          stdout: (s) => n += s.toString(),
          stderr: (s) => n += s.toString()
        }
      });
    } catch (s) {
      le(s.message);
    }
    return n = n.trim(), le(n), n;
  });
}
function fo() {
  return ts(this, void 0, void 0, function* () {
    const t = yield Ff("zstd", ["--quiet"]), e = Sr.clean(t);
    return le(`zstd version: ${e}`), t === "" ? ir.Gzip : ir.ZstdWithoutLong;
  });
}
function rs(t) {
  return t === ir.Gzip ? Hi.Gzip : Hi.Zstd;
}
function YN() {
  return ts(this, void 0, void 0, function* () {
    return tt.existsSync(xh) ? xh : (yield Ff("tar")).toLowerCase().includes("gnu tar") ? br("tar") : "";
  });
}
function Rh(t, e) {
  if (e === void 0)
    throw Error(`Expected ${t} but value was undefiend`);
  return e;
}
function po(t, e, r = !1) {
  const n = t.slice();
  return e && n.push(e), process.platform === "win32" && !r && n.push("windows-only"), n.push(GN), Js.createHash("sha256").update(n.join("|")).digest("hex");
}
function JN() {
  const t = process.env.ACTIONS_RUNTIME_TOKEN;
  if (!t)
    throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
  return t;
}
let zi = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function VN(t, ...e) {
  ki.stderr.write(`${_t.format(t, ...e)}${Iy}`);
}
const Sh = typeof process < "u" && process.env && process.env.DEBUG || void 0;
let vf, Yc = [], Jc = [];
const qi = [];
Sh && Ol(Sh);
const qn = Object.assign((t) => Lf(t), {
  enable: Ol,
  enabled: zl,
  disable: _N,
  log: VN
});
function Ol(t) {
  vf = t, Yc = [], Jc = [];
  const e = t.split(",").map((r) => r.trim());
  for (const r of e)
    r.startsWith("-") ? Jc.push(r.substring(1)) : Yc.push(r);
  for (const r of qi)
    r.enabled = zl(r.namespace);
}
function zl(t) {
  if (t.endsWith("*"))
    return !0;
  for (const e of Jc)
    if (Dh(t, e))
      return !1;
  for (const e of Yc)
    if (Dh(t, e))
      return !0;
  return !1;
}
function Dh(t, e) {
  if (e.indexOf("*") === -1)
    return t === e;
  let r = e;
  if (e.indexOf("**") !== -1) {
    const u = [];
    let m = "";
    for (const h of e)
      h === "*" && m === "*" || (m = h, u.push(h));
    r = u.join("");
  }
  let n = 0, s = 0;
  const i = r.length, o = t.length;
  let a = -1, A = -1;
  for (; n < o && s < i; )
    if (r[s] === "*") {
      if (a = s, s++, s === i)
        return !0;
      for (; t[n] !== r[s]; )
        if (n++, n === o)
          return !1;
      A = n, n++, s++;
      continue;
    } else if (r[s] === t[n])
      s++, n++;
    else if (a >= 0) {
      if (s = a + 1, n = A + 1, n === o)
        return !1;
      for (; t[n] !== r[s]; )
        if (n++, n === o)
          return !1;
      A = n, n++, s++;
      continue;
    } else
      return !1;
  const c = n === t.length, l = s === r.length, d = s === r.length - 1 && r[s] === "*";
  return c && (l || d);
}
function _N() {
  const t = vf || "";
  return Ol(""), t;
}
function Lf(t) {
  const e = Object.assign(r, {
    enabled: zl(t),
    destroy: WN,
    log: qn.log,
    namespace: t,
    extend: $N
  });
  function r(...n) {
    e.enabled && (n.length > 0 && (n[0] = `${t} ${n[0]}`), e.log(...n));
  }
  return qi.push(e), e;
}
function WN() {
  const t = qi.indexOf(this);
  return t >= 0 ? (qi.splice(t, 1), !0) : !1;
}
function $N(t) {
  const e = Lf(`${this.namespace}:${t}`);
  return e.log = this.log, e;
}
const Vc = ["verbose", "info", "warning", "error"], kh = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function Mh(t, e) {
  e.log = (...r) => {
    t.log(...r);
  };
}
function Th(t) {
  return Vc.includes(t);
}
function Uf(t) {
  const e = /* @__PURE__ */ new Set(), r = typeof process < "u" && process.env && process.env[t.logLevelEnvVarName] || void 0;
  let n;
  const s = qn(t.namespace);
  s.log = (...l) => {
    qn.log(...l);
  };
  function i(l) {
    if (l && !Th(l))
      throw new Error(`Unknown log level '${l}'. Acceptable values: ${Vc.join(",")}`);
    n = l;
    const d = [];
    for (const u of e)
      o(u) && d.push(u.namespace);
    qn.enable(d.join(","));
  }
  r && (Th(r) ? i(r) : console.error(`${t.logLevelEnvVarName} set to unknown log level '${r}'; logging is not enabled. Acceptable values: ${Vc.join(", ")}.`));
  function o(l) {
    return !!(n && kh[l.level] <= kh[n]);
  }
  function a(l, d) {
    const u = Object.assign(l.extend(d), {
      level: d
    });
    if (Mh(l, u), o(u)) {
      const m = qn.disable();
      qn.enable(m + "," + u.namespace);
    }
    return e.add(u), u;
  }
  function A() {
    return n;
  }
  function c(l) {
    const d = s.extend(l);
    return Mh(s, d), {
      error: a(d, "error"),
      warning: a(d, "warning"),
      info: a(d, "info"),
      verbose: a(d, "verbose")
    };
  }
  return {
    setLogLevel: i,
    getLogLevel: A,
    createClientLogger: c,
    logger: s
  };
}
const XN = Uf({
  logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
  namespace: "typeSpecRuntime"
});
function Pf(t) {
  return XN.createClientLogger(t);
}
function yi(t) {
  return t.toLowerCase();
}
function* ZN(t) {
  for (const e of t.values())
    yield [e.name, e.value];
}
class KN {
  _headersMap;
  constructor(e) {
    if (this._headersMap = /* @__PURE__ */ new Map(), e)
      for (const r of Object.keys(e))
        this.set(r, e[r]);
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param name - The name of the header to set. This value is case-insensitive.
   * @param value - The value of the header to set.
   */
  set(e, r) {
    this._headersMap.set(yi(e), { name: e, value: String(r).trim() });
  }
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param name - The name of the header. This value is case-insensitive.
   */
  get(e) {
    return this._headersMap.get(yi(e))?.value;
  }
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   * @param name - The name of the header to set. This value is case-insensitive.
   */
  has(e) {
    return this._headersMap.has(yi(e));
  }
  /**
   * Remove the header with the provided headerName.
   * @param name - The name of the header to remove.
   */
  delete(e) {
    this._headersMap.delete(yi(e));
  }
  /**
   * Get the JSON object representation of this HTTP header collection.
   */
  toJSON(e = {}) {
    const r = {};
    if (e.preserveCase)
      for (const n of this._headersMap.values())
        r[n.name] = n.value;
    else
      for (const [n, s] of this._headersMap)
        r[n] = s.value;
    return r;
  }
  /**
   * Get the string representation of this HTTP header collection.
   */
  toString() {
    return JSON.stringify(this.toJSON({ preserveCase: !0 }));
  }
  /**
   * Iterate over tuples of header [name, value] pairs.
   */
  [Symbol.iterator]() {
    return ZN(this._headersMap);
  }
}
function Os(t) {
  return new KN(t);
}
function ql() {
  return crypto.randomUUID();
}
class jN {
  url;
  method;
  headers;
  timeout;
  withCredentials;
  body;
  multipartBody;
  formData;
  streamResponseStatusCodes;
  enableBrowserStreams;
  proxySettings;
  disableKeepAlive;
  abortSignal;
  requestId;
  allowInsecureConnection;
  onUploadProgress;
  onDownloadProgress;
  requestOverrides;
  authSchemes;
  constructor(e) {
    this.url = e.url, this.body = e.body, this.headers = e.headers ?? Os(), this.method = e.method ?? "GET", this.timeout = e.timeout ?? 0, this.multipartBody = e.multipartBody, this.formData = e.formData, this.disableKeepAlive = e.disableKeepAlive ?? !1, this.proxySettings = e.proxySettings, this.streamResponseStatusCodes = e.streamResponseStatusCodes, this.withCredentials = e.withCredentials ?? !1, this.abortSignal = e.abortSignal, this.onUploadProgress = e.onUploadProgress, this.onDownloadProgress = e.onDownloadProgress, this.requestId = e.requestId || ql(), this.allowInsecureConnection = e.allowInsecureConnection ?? !1, this.enableBrowserStreams = e.enableBrowserStreams ?? !1, this.requestOverrides = e.requestOverrides, this.authSchemes = e.authSchemes;
  }
}
function ew(t) {
  return new jN(t);
}
const Fh = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
class Gi {
  _policies = [];
  _orderedPolicies;
  constructor(e) {
    this._policies = e?.slice(0) ?? [], this._orderedPolicies = void 0;
  }
  addPolicy(e, r = {}) {
    if (r.phase && r.afterPhase)
      throw new Error("Policies inside a phase cannot specify afterPhase.");
    if (r.phase && !Fh.has(r.phase))
      throw new Error(`Invalid phase name: ${r.phase}`);
    if (r.afterPhase && !Fh.has(r.afterPhase))
      throw new Error(`Invalid afterPhase name: ${r.afterPhase}`);
    this._policies.push({
      policy: e,
      options: r
    }), this._orderedPolicies = void 0;
  }
  removePolicy(e) {
    const r = [];
    return this._policies = this._policies.filter((n) => e.name && n.policy.name === e.name || e.phase && n.options.phase === e.phase ? (r.push(n.policy), !1) : !0), this._orderedPolicies = void 0, r;
  }
  sendRequest(e, r) {
    return this.getOrderedPolicies().reduceRight((i, o) => (a) => o.sendRequest(a, i), (i) => e.sendRequest(i))(r);
  }
  getOrderedPolicies() {
    return this._orderedPolicies || (this._orderedPolicies = this.orderPolicies()), this._orderedPolicies;
  }
  clone() {
    return new Gi(this._policies);
  }
  static create() {
    return new Gi();
  }
  orderPolicies() {
    const e = [], r = /* @__PURE__ */ new Map();
    function n(h) {
      return {
        name: h,
        policies: /* @__PURE__ */ new Set(),
        hasRun: !1,
        hasAfterPolicies: !1
      };
    }
    const s = n("Serialize"), i = n("None"), o = n("Deserialize"), a = n("Retry"), A = n("Sign"), c = [s, i, o, a, A];
    function l(h) {
      return h === "Retry" ? a : h === "Serialize" ? s : h === "Deserialize" ? o : h === "Sign" ? A : i;
    }
    for (const h of this._policies) {
      const f = h.policy, p = h.options, y = f.name;
      if (r.has(y))
        throw new Error("Duplicate policy names not allowed in pipeline");
      const w = {
        policy: f,
        dependsOn: /* @__PURE__ */ new Set(),
        dependants: /* @__PURE__ */ new Set()
      };
      p.afterPhase && (w.afterPhase = l(p.afterPhase), w.afterPhase.hasAfterPolicies = !0), r.set(y, w), l(p.phase).policies.add(w);
    }
    for (const h of this._policies) {
      const { policy: f, options: p } = h, y = f.name, w = r.get(y);
      if (!w)
        throw new Error(`Missing node for policy ${y}`);
      if (p.afterPolicies)
        for (const R of p.afterPolicies) {
          const D = r.get(R);
          D && (w.dependsOn.add(D), D.dependants.add(w));
        }
      if (p.beforePolicies)
        for (const R of p.beforePolicies) {
          const D = r.get(R);
          D && (D.dependsOn.add(w), w.dependants.add(D));
        }
    }
    function d(h) {
      h.hasRun = !0;
      for (const f of h.policies)
        if (!(f.afterPhase && (!f.afterPhase.hasRun || f.afterPhase.policies.size)) && f.dependsOn.size === 0) {
          e.push(f.policy);
          for (const p of f.dependants)
            p.dependsOn.delete(f);
          r.delete(f.policy.name), h.policies.delete(f);
        }
    }
    function u() {
      for (const h of c) {
        if (d(h), h.policies.size > 0 && h !== i) {
          i.hasRun || d(i);
          return;
        }
        h.hasAfterPolicies && d(i);
      }
    }
    let m = 0;
    for (; r.size > 0; ) {
      m++;
      const h = e.length;
      if (u(), e.length <= h && m > 1)
        throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
    }
    return e;
  }
}
function tw() {
  return Gi.create();
}
function Hf(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && !(t instanceof RegExp) && !(t instanceof Date);
}
function Gl(t) {
  if (Hf(t)) {
    const e = typeof t.name == "string", r = typeof t.message == "string";
    return e && r;
  }
  return !1;
}
const rw = ay.custom, bc = "REDACTED", nw = [
  "x-ms-client-request-id",
  "x-ms-return-client-request-id",
  "x-ms-useragent",
  "x-ms-correlation-request-id",
  "x-ms-request-id",
  "client-request-id",
  "ms-cv",
  "return-client-request-id",
  "traceparent",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Origin",
  "Accept",
  "Accept-Encoding",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "Last-Modified",
  "Pragma",
  "Request-Id",
  "Retry-After",
  "Server",
  "Transfer-Encoding",
  "User-Agent",
  "WWW-Authenticate"
], sw = ["api-version"];
class Eo {
  allowedHeaderNames;
  allowedQueryParameters;
  constructor({ additionalAllowedHeaderNames: e = [], additionalAllowedQueryParameters: r = [] } = {}) {
    e = nw.concat(e), r = sw.concat(r), this.allowedHeaderNames = new Set(e.map((n) => n.toLowerCase())), this.allowedQueryParameters = new Set(r.map((n) => n.toLowerCase()));
  }
  /**
   * Sanitizes an object for logging.
   * @param obj - The object to sanitize
   * @returns - The sanitized object as a string
   */
  sanitize(e) {
    const r = /* @__PURE__ */ new Set();
    return JSON.stringify(e, (n, s) => {
      if (s instanceof Error)
        return {
          ...s,
          name: s.name,
          message: s.message
        };
      if (n === "headers")
        return this.sanitizeHeaders(s);
      if (n === "url")
        return this.sanitizeUrl(s);
      if (n === "query")
        return this.sanitizeQuery(s);
      if (n === "body")
        return;
      if (n === "response")
        return;
      if (n === "operationSpec")
        return;
      if (Array.isArray(s) || Hf(s)) {
        if (r.has(s))
          return "[Circular]";
        r.add(s);
      }
      return s;
    }, 2);
  }
  /**
   * Sanitizes a URL for logging.
   * @param value - The URL to sanitize
   * @returns - The sanitized URL as a string
   */
  sanitizeUrl(e) {
    if (typeof e != "string" || e === null || e === "")
      return e;
    const r = new URL(e);
    if (!r.search)
      return e;
    for (const [n] of r.searchParams)
      this.allowedQueryParameters.has(n.toLowerCase()) || r.searchParams.set(n, bc);
    return r.toString();
  }
  sanitizeHeaders(e) {
    const r = {};
    for (const n of Object.keys(e))
      this.allowedHeaderNames.has(n.toLowerCase()) ? r[n] = e[n] : r[n] = bc;
    return r;
  }
  sanitizeQuery(e) {
    if (typeof e != "object" || e === null)
      return e;
    const r = {};
    for (const n of Object.keys(e))
      this.allowedQueryParameters.has(n.toLowerCase()) ? r[n] = e[n] : r[n] = bc;
    return r;
  }
}
const iw = new Eo();
let yn = class Of extends Error {
  /**
   * Something went wrong when making the request.
   * This means the actual request failed for some reason,
   * such as a DNS issue or the connection being lost.
   */
  static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
  /**
   * This means that parsing the response from the server failed.
   * It may have been malformed.
   */
  static PARSE_ERROR = "PARSE_ERROR";
  /**
   * The code of the error itself (use statics on RestError if possible.)
   */
  code;
  /**
   * The HTTP status code of the request (if applicable.)
   */
  statusCode;
  /**
   * The request that was made.
   * This property is non-enumerable.
   */
  request;
  /**
   * The response received (if any.)
   * This property is non-enumerable.
   */
  response;
  /**
   * Bonus property set by the throw site.
   */
  details;
  constructor(e, r = {}) {
    super(e), this.name = "RestError", this.code = r.code, this.statusCode = r.statusCode, Object.defineProperty(this, "request", { value: r.request, enumerable: !1 }), Object.defineProperty(this, "response", { value: r.response, enumerable: !1 });
    const n = this.request?.agent ? {
      maxFreeSockets: this.request.agent.maxFreeSockets,
      maxSockets: this.request.agent.maxSockets
    } : void 0;
    Object.defineProperty(this, rw, {
      value: () => `RestError: ${this.message} 
 ${iw.sanitize({
        ...this,
        request: { ...this.request, agent: n },
        response: this.response
      })}`,
      enumerable: !1
    }), Object.setPrototypeOf(this, Of.prototype);
  }
};
function ow(t) {
  return t instanceof yn ? !0 : Gl(t) && t.name === "RestError";
}
function gn(t, e) {
  return Buffer.from(t, e);
}
const Vr = Pf("ts-http-runtime"), aw = {};
function ks(t) {
  return t && typeof t.pipe == "function";
}
function vh(t) {
  return t.readable === !1 ? Promise.resolve() : new Promise((e) => {
    const r = () => {
      e(), t.removeListener("close", r), t.removeListener("end", r), t.removeListener("error", r);
    };
    t.on("close", r), t.on("end", r), t.on("error", r);
  });
}
function zf(t) {
  return t && typeof t.byteLength == "number";
}
class Lh extends oy {
  loadedBytes = 0;
  progressCallback;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  _transform(e, r, n) {
    this.push(e), this.loadedBytes += e.length;
    try {
      this.progressCallback({ loadedBytes: this.loadedBytes }), n();
    } catch (s) {
      n(s);
    }
  }
  constructor(e) {
    super(), this.progressCallback = e;
  }
}
class Aw {
  cachedHttpAgent;
  cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
  /**
   * Makes a request over an underlying transport layer and returns the response.
   * @param request - The request to be made.
   */
  async sendRequest(e) {
    const r = new AbortController();
    let n;
    if (e.abortSignal) {
      if (e.abortSignal.aborted)
        throw new zi("The operation was aborted. Request has already been canceled.");
      n = (c) => {
        c.type === "abort" && r.abort();
      }, e.abortSignal.addEventListener("abort", n);
    }
    let s;
    e.timeout > 0 && (s = setTimeout(() => {
      const c = new Eo();
      Vr.info(`request to '${c.sanitizeUrl(e.url)}' timed out. canceling...`), r.abort();
    }, e.timeout));
    const i = e.headers.get("Accept-Encoding"), o = i?.includes("gzip") || i?.includes("deflate");
    let a = typeof e.body == "function" ? e.body() : e.body;
    if (a && !e.headers.has("Content-Length")) {
      const c = uw(a);
      c !== null && e.headers.set("Content-Length", c);
    }
    let A;
    try {
      if (a && e.onUploadProgress) {
        const h = e.onUploadProgress, f = new Lh(h);
        f.on("error", (p) => {
          Vr.error("Error in upload progress", p);
        }), ks(a) ? a.pipe(f) : f.end(a), a = f;
      }
      const c = await this.makeRequest(e, r, a);
      s !== void 0 && clearTimeout(s);
      const l = cw(c), u = {
        status: c.statusCode ?? 0,
        headers: l,
        request: e
      };
      if (e.method === "HEAD")
        return c.resume(), u;
      A = o ? lw(c, l) : c;
      const m = e.onDownloadProgress;
      if (m) {
        const h = new Lh(m);
        h.on("error", (f) => {
          Vr.error("Error in download progress", f);
        }), A.pipe(h), A = h;
      }
      return /* Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code */ e.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || e.streamResponseStatusCodes?.has(u.status) ? u.readableStreamBody = A : u.bodyAsText = await dw(A), u;
    } finally {
      if (e.abortSignal && n) {
        let c = Promise.resolve();
        ks(a) && (c = vh(a));
        let l = Promise.resolve();
        ks(A) && (l = vh(A)), Promise.all([c, l]).then(() => {
          n && e.abortSignal?.removeEventListener("abort", n);
        }).catch((d) => {
          Vr.warning("Error when cleaning up abortListener on httpRequest", d);
        });
      }
    }
  }
  makeRequest(e, r, n) {
    const s = new URL(e.url), i = s.protocol !== "https:";
    if (i && !e.allowInsecureConnection)
      throw new Error(`Cannot connect to ${e.url} while allowInsecureConnection is false.`);
    const a = {
      agent: e.agent ?? this.getOrCreateAgent(e, i),
      hostname: s.hostname,
      path: `${s.pathname}${s.search}`,
      port: s.port,
      method: e.method,
      headers: e.headers.toJSON({ preserveCase: !0 }),
      ...e.requestOverrides
    };
    return new Promise((A, c) => {
      const l = i ? Bn.request(a, A) : Go.request(a, A);
      l.once("error", (d) => {
        c(new yn(d.message, { code: d.code ?? yn.REQUEST_SEND_ERROR, request: e }));
      }), r.signal.addEventListener("abort", () => {
        const d = new zi("The operation was aborted. Rejecting from abort signal callback while making request.");
        l.destroy(d), c(d);
      }), n && ks(n) ? n.pipe(l) : n ? typeof n == "string" || Buffer.isBuffer(n) ? l.end(n) : zf(n) ? l.end(ArrayBuffer.isView(n) ? Buffer.from(n.buffer) : Buffer.from(n)) : (Vr.error("Unrecognized body type", n), c(new yn("Unrecognized body type"))) : l.end();
    });
  }
  getOrCreateAgent(e, r) {
    const n = e.disableKeepAlive;
    if (r)
      return n ? Bn.globalAgent : (this.cachedHttpAgent || (this.cachedHttpAgent = new Bn.Agent({ keepAlive: !0 })), this.cachedHttpAgent);
    {
      if (n && !e.tlsSettings)
        return Go.globalAgent;
      const s = e.tlsSettings ?? aw;
      let i = this.cachedHttpsAgents.get(s);
      return i && i.options.keepAlive === !n || (Vr.info("No cached TLS Agent exist, creating a new Agent"), i = new Go.Agent({
        // keepAlive is true if disableKeepAlive is false.
        keepAlive: !n,
        // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.
        ...s
      }), this.cachedHttpsAgents.set(s, i)), i;
    }
  }
}
function cw(t) {
  const e = Os();
  for (const r of Object.keys(t.headers)) {
    const n = t.headers[r];
    Array.isArray(n) ? n.length > 0 && e.set(r, n[0]) : n && e.set(r, n);
  }
  return e;
}
function lw(t, e) {
  const r = e.get("Content-Encoding");
  if (r === "gzip") {
    const n = Hs.createGunzip();
    return t.pipe(n), n;
  } else if (r === "deflate") {
    const n = Hs.createInflate();
    return t.pipe(n), n;
  }
  return t;
}
function dw(t) {
  return new Promise((e, r) => {
    const n = [];
    t.on("data", (s) => {
      Buffer.isBuffer(s) ? n.push(s) : n.push(Buffer.from(s));
    }), t.on("end", () => {
      e(Buffer.concat(n).toString("utf8"));
    }), t.on("error", (s) => {
      s && s?.name === "AbortError" ? r(s) : r(new yn(`Error reading response as text: ${s.message}`, {
        code: yn.PARSE_ERROR
      }));
    });
  });
}
function uw(t) {
  return t ? Buffer.isBuffer(t) ? t.length : ks(t) ? null : zf(t) ? t.byteLength : typeof t == "string" ? Buffer.from(t).length : null : 0;
}
function mw() {
  return new Aw();
}
function hw() {
  return mw();
}
const gw = "logPolicy";
function fw(t = {}) {
  const e = t.logger ?? Vr.info, r = new Eo({
    additionalAllowedHeaderNames: t.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: t.additionalAllowedQueryParameters
  });
  return {
    name: gw,
    async sendRequest(n, s) {
      if (!e.enabled)
        return s(n);
      e(`Request: ${r.sanitize(n)}`);
      const i = await s(n);
      return e(`Response status code: ${i.status}`), e(`Headers: ${r.sanitize(i.headers)}`), i;
    }
  };
}
const qf = "redirectPolicy", Uh = ["GET", "HEAD"];
function pw(t = {}) {
  const { maxRetries: e = 20 } = t;
  return {
    name: qf,
    async sendRequest(r, n) {
      const s = await n(r);
      return Gf(n, s, e);
    }
  };
}
async function Gf(t, e, r, n = 0) {
  const { request: s, status: i, headers: o } = e, a = o.get("location");
  if (a && (i === 300 || i === 301 && Uh.includes(s.method) || i === 302 && Uh.includes(s.method) || i === 303 && s.method === "POST" || i === 307) && n < r) {
    const A = new URL(a, s.url);
    s.url = A.toString(), i === 303 && (s.method = "GET", s.headers.delete("Content-Length"), delete s.body), s.headers.delete("Authorization");
    const c = await t(s);
    return Gf(t, c, r, n + 1);
  }
  return e;
}
const _c = 3, Yf = "decompressResponsePolicy";
function Ew() {
  return {
    name: Yf,
    async sendRequest(t, e) {
      return t.method !== "HEAD" && t.headers.set("Accept-Encoding", "gzip,deflate"), e(t);
    }
  };
}
function Cw(t, e) {
  return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t;
}
function Bw(t, e) {
  const r = e.retryDelayInMs * Math.pow(2, t), n = Math.min(e.maxRetryDelayInMs, r);
  return { retryAfterInMs: n / 2 + Cw(0, n / 2) };
}
const Iw = "The operation was aborted.";
function yw(t, e, r) {
  return new Promise((n, s) => {
    let i, o;
    const a = () => s(new zi(r?.abortErrorMsg ? r?.abortErrorMsg : Iw)), A = () => {
      r?.abortSignal && o && r.abortSignal.removeEventListener("abort", o);
    };
    if (o = () => (i && clearTimeout(i), A(), a()), r?.abortSignal && r.abortSignal.aborted)
      return a();
    i = setTimeout(() => {
      A(), n(e);
    }, t), r?.abortSignal && r.abortSignal.addEventListener("abort", o);
  });
}
function Qw(t, e) {
  const r = t.headers.get(e);
  if (!r)
    return;
  const n = Number(r);
  if (!Number.isNaN(n))
    return n;
}
const Wc = "Retry-After", Nw = ["retry-after-ms", "x-ms-retry-after-ms", Wc];
function Jf(t) {
  if (t && [429, 503].includes(t.status))
    try {
      for (const s of Nw) {
        const i = Qw(t, s);
        if (i === 0 || i)
          return i * (s === Wc ? 1e3 : 1);
      }
      const e = t.headers.get(Wc);
      if (!e)
        return;
      const n = Date.parse(e) - Date.now();
      return Number.isFinite(n) ? Math.max(0, n) : void 0;
    } catch {
      return;
    }
}
function ww(t) {
  return Number.isFinite(Jf(t));
}
function bw() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response: t }) {
      const e = Jf(t);
      return Number.isFinite(e) ? {
        retryAfterInMs: e
      } : { skipStrategy: !0 };
    }
  };
}
const xw = 1e3, Rw = 1e3 * 64;
function Sw(t = {}) {
  const e = t.retryDelayInMs ?? xw, r = t.maxRetryDelayInMs ?? Rw;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount: n, response: s, responseError: i }) {
      const o = kw(i), a = o && t.ignoreSystemErrors, A = Dw(s), c = A && t.ignoreHttpStatusCodes;
      return s && (ww(s) || !A) || c || a ? { skipStrategy: !0 } : i && !o && !A ? { errorToThrow: i } : Bw(n, {
        retryDelayInMs: e,
        maxRetryDelayInMs: r
      });
    }
  };
}
function Dw(t) {
  return !!(t && t.status !== void 0 && (t.status >= 500 || t.status === 408) && t.status !== 501 && t.status !== 505);
}
function kw(t) {
  return t ? t.code === "ETIMEDOUT" || t.code === "ESOCKETTIMEDOUT" || t.code === "ECONNREFUSED" || t.code === "ECONNRESET" || t.code === "ENOENT" || t.code === "ENOTFOUND" : !1;
}
const Mw = Pf("ts-http-runtime retryPolicy"), Tw = "retryPolicy";
function Fw(t, e = { maxRetries: _c }) {
  const r = e.logger || Mw;
  return {
    name: Tw,
    async sendRequest(n, s) {
      let i, o, a = -1;
      e: for (; ; ) {
        a += 1, i = void 0, o = void 0;
        try {
          r.info(`Retry ${a}: Attempting to send request`, n.requestId), i = await s(n), r.info(`Retry ${a}: Received a response from request`, n.requestId);
        } catch (A) {
          if (r.error(`Retry ${a}: Received an error from request`, n.requestId), o = A, !A || o.name !== "RestError")
            throw A;
          i = o.response;
        }
        if (n.abortSignal?.aborted)
          throw r.error(`Retry ${a}: Request aborted.`), new zi();
        if (a >= (e.maxRetries ?? _c)) {
          if (r.info(`Retry ${a}: Maximum retries reached. Returning the last received response, or throwing the last received error.`), o)
            throw o;
          if (i)
            return i;
          throw new Error("Maximum retries reached with no response or error to throw");
        }
        r.info(`Retry ${a}: Processing ${t.length} retry strategies.`);
        t: for (const A of t) {
          const c = A.logger || r;
          c.info(`Retry ${a}: Processing retry strategy ${A.name}.`);
          const l = A.retry({
            retryCount: a,
            response: i,
            responseError: o
          });
          if (l.skipStrategy) {
            c.info(`Retry ${a}: Skipped.`);
            continue t;
          }
          const { errorToThrow: d, retryAfterInMs: u, redirectTo: m } = l;
          if (d)
            throw c.error(`Retry ${a}: Retry strategy ${A.name} throws error:`, d), d;
          if (u || u === 0) {
            c.info(`Retry ${a}: Retry strategy ${A.name} retries after ${u}`), await yw(u, void 0, { abortSignal: n.abortSignal });
            continue e;
          }
          if (m) {
            c.info(`Retry ${a}: Retry strategy ${A.name} redirects to ${m}`), n.url = m;
            continue e;
          }
        }
        if (o)
          throw r.info("None of the retry strategies could work with the received error. Throwing it."), o;
        if (i)
          return r.info("None of the retry strategies could work with the received response. Returning it."), i;
      }
    }
  };
}
const vw = "defaultRetryPolicy";
function Lw(t = {}) {
  return {
    name: vw,
    sendRequest: Fw([bw(), Sw(t)], {
      maxRetries: t.maxRetries ?? _c
    }).sendRequest
  };
}
typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u";
typeof Bun < "u" && typeof Bun.version < "u";
const Vf = typeof globalThis.process < "u" && !!globalThis.process.version && !!globalThis.process.versions?.node, Uw = "formDataPolicy";
function Pw(t) {
  const e = {};
  for (const [r, n] of t.entries())
    e[r] ??= [], e[r].push(n);
  return e;
}
function Hw() {
  return {
    name: Uw,
    async sendRequest(t, e) {
      if (Vf && typeof FormData < "u" && t.body instanceof FormData && (t.formData = Pw(t.body), t.body = void 0), t.formData) {
        const r = t.headers.get("Content-Type");
        r && r.indexOf("application/x-www-form-urlencoded") !== -1 ? t.body = Ow(t.formData) : await zw(t.formData, t), t.formData = void 0;
      }
      return e(t);
    }
  };
}
function Ow(t) {
  const e = new URLSearchParams();
  for (const [r, n] of Object.entries(t))
    if (Array.isArray(n))
      for (const s of n)
        e.append(r, s.toString());
    else
      e.append(r, n.toString());
  return e.toString();
}
async function zw(t, e) {
  const r = e.headers.get("Content-Type");
  if (r && !r.startsWith("multipart/form-data"))
    return;
  e.headers.set("Content-Type", r ?? "multipart/form-data");
  const n = [];
  for (const [s, i] of Object.entries(t))
    for (const o of Array.isArray(i) ? i : [i])
      if (typeof o == "string")
        n.push({
          headers: Os({
            "Content-Disposition": `form-data; name="${s}"`
          }),
          body: gn(o, "utf-8")
        });
      else {
        if (o == null || typeof o != "object")
          throw new Error(`Unexpected value for key ${s}: ${o}. Value should be serialized to string first.`);
        {
          const a = o.name || "blob", A = Os();
          A.set("Content-Disposition", `form-data; name="${s}"; filename="${a}"`), A.set("Content-Type", o.type || "application/octet-stream"), n.push({
            headers: A,
            body: o
          });
        }
      }
  e.multipartBody = { parts: n };
}
var er = {}, Qi = { exports: {} }, xc, Ph;
function qw() {
  if (Ph) return xc;
  Ph = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, s = n * 7, i = n * 365.25;
  xc = function(l, d) {
    d = d || {};
    var u = typeof l;
    if (u === "string" && l.length > 0)
      return o(l);
    if (u === "number" && isFinite(l))
      return d.long ? A(l) : a(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function o(l) {
    if (l = String(l), !(l.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (d) {
        var u = parseFloat(d[1]), m = (d[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "weeks":
          case "week":
          case "w":
            return u * s;
          case "days":
          case "day":
          case "d":
            return u * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function a(l) {
    var d = Math.abs(l);
    return d >= n ? Math.round(l / n) + "d" : d >= r ? Math.round(l / r) + "h" : d >= e ? Math.round(l / e) + "m" : d >= t ? Math.round(l / t) + "s" : l + "ms";
  }
  function A(l) {
    var d = Math.abs(l);
    return d >= n ? c(l, d, n, "day") : d >= r ? c(l, d, r, "hour") : d >= e ? c(l, d, e, "minute") : d >= t ? c(l, d, t, "second") : l + " ms";
  }
  function c(l, d, u, m) {
    var h = d >= u * 1.5;
    return Math.round(l / u) + " " + m + (h ? "s" : "");
  }
  return xc;
}
var Rc, Hh;
function Gw() {
  if (Hh) return Rc;
  Hh = 1;
  function t(e) {
    n.debug = n, n.default = n, n.coerce = c, n.disable = a, n.enable = i, n.enabled = A, n.humanize = qw(), n.destroy = l, Object.keys(e).forEach((d) => {
      n[d] = e[d];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(d) {
      let u = 0;
      for (let m = 0; m < d.length; m++)
        u = (u << 5) - u + d.charCodeAt(m), u |= 0;
      return n.colors[Math.abs(u) % n.colors.length];
    }
    n.selectColor = r;
    function n(d) {
      let u, m = null, h, f;
      function p(...y) {
        if (!p.enabled)
          return;
        const w = p, R = Number(/* @__PURE__ */ new Date()), D = R - (u || R);
        w.diff = D, w.prev = u, w.curr = R, u = R, y[0] = n.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
        let L = 0;
        y[0] = y[0].replace(/%([a-zA-Z%])/g, (I, x) => {
          if (I === "%%")
            return "%";
          L++;
          const g = n.formatters[x];
          if (typeof g == "function") {
            const B = y[L];
            I = g.call(w, B), y.splice(L, 1), L--;
          }
          return I;
        }), n.formatArgs.call(w, y), (w.log || n.log).apply(w, y);
      }
      return p.namespace = d, p.useColors = n.useColors(), p.color = n.selectColor(d), p.extend = s, p.destroy = n.destroy, Object.defineProperty(p, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => m !== null ? m : (h !== n.namespaces && (h = n.namespaces, f = n.enabled(d)), f),
        set: (y) => {
          m = y;
        }
      }), typeof n.init == "function" && n.init(p), p;
    }
    function s(d, u) {
      const m = n(this.namespace + (typeof u > "u" ? ":" : u) + d);
      return m.log = this.log, m;
    }
    function i(d) {
      n.save(d), n.namespaces = d, n.names = [], n.skips = [];
      const u = (typeof d == "string" ? d : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const m of u)
        m[0] === "-" ? n.skips.push(m.slice(1)) : n.names.push(m);
    }
    function o(d, u) {
      let m = 0, h = 0, f = -1, p = 0;
      for (; m < d.length; )
        if (h < u.length && (u[h] === d[m] || u[h] === "*"))
          u[h] === "*" ? (f = h, p = m, h++) : (m++, h++);
        else if (f !== -1)
          h = f + 1, p++, m = p;
        else
          return !1;
      for (; h < u.length && u[h] === "*"; )
        h++;
      return h === u.length;
    }
    function a() {
      const d = [
        ...n.names,
        ...n.skips.map((u) => "-" + u)
      ].join(",");
      return n.enable(""), d;
    }
    function A(d) {
      for (const u of n.skips)
        if (o(d, u))
          return !1;
      for (const u of n.names)
        if (o(d, u))
          return !0;
      return !1;
    }
    function c(d) {
      return d instanceof Error ? d.stack || d.message : d;
    }
    function l() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n.enable(n.load()), n;
  }
  return Rc = t, Rc;
}
var Oh;
function Yl() {
  return Oh || (Oh = 1, (function(t, e) {
    e.formatArgs = n, e.save = s, e.load = i, e.useColors = r, e.storage = o(), e.destroy = /* @__PURE__ */ (() => {
      let A = !1;
      return () => {
        A || (A = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let A;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (A = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(A[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(A) {
      if (A[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + A[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
        return;
      const c = "color: " + this.color;
      A.splice(1, 0, c, "color: inherit");
      let l = 0, d = 0;
      A[0].replace(/%[a-zA-Z%]/g, (u) => {
        u !== "%%" && (l++, u === "%c" && (d = l));
      }), A.splice(d, 0, c);
    }
    e.log = console.debug || console.log || (() => {
    });
    function s(A) {
      try {
        A ? e.storage.setItem("debug", A) : e.storage.removeItem("debug");
      } catch {
      }
    }
    function i() {
      let A;
      try {
        A = e.storage.getItem("debug") || e.storage.getItem("DEBUG");
      } catch {
      }
      return !A && typeof process < "u" && "env" in process && (A = process.env.DEBUG), A;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    t.exports = Gw()(e);
    const { formatters: a } = t.exports;
    a.j = function(A) {
      try {
        return JSON.stringify(A);
      } catch (c) {
        return "[UnexpectedJSONParseError]: " + c.message;
      }
    };
  })(Qi, Qi.exports)), Qi.exports;
}
var gr = {}, Gt = {}, zh;
function Yw() {
  if (zh) return Gt;
  zh = 1;
  var t = Gt && Gt.__createBinding || (Object.create ? (function(A, c, l, d) {
    d === void 0 && (d = l);
    var u = Object.getOwnPropertyDescriptor(c, l);
    (!u || ("get" in u ? !c.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return c[l];
    } }), Object.defineProperty(A, d, u);
  }) : (function(A, c, l, d) {
    d === void 0 && (d = l), A[d] = c[l];
  })), e = Gt && Gt.__setModuleDefault || (Object.create ? (function(A, c) {
    Object.defineProperty(A, "default", { enumerable: !0, value: c });
  }) : function(A, c) {
    A.default = c;
  }), r = Gt && Gt.__importStar || function(A) {
    if (A && A.__esModule) return A;
    var c = {};
    if (A != null) for (var l in A) l !== "default" && Object.prototype.hasOwnProperty.call(A, l) && t(c, A, l);
    return e(c, A), c;
  };
  Object.defineProperty(Gt, "__esModule", { value: !0 }), Gt.req = Gt.json = Gt.toBuffer = void 0;
  const n = r(ll), s = r(dl);
  async function i(A) {
    let c = 0;
    const l = [];
    for await (const d of A)
      c += d.length, l.push(d);
    return Buffer.concat(l, c);
  }
  Gt.toBuffer = i;
  async function o(A) {
    const l = (await i(A)).toString("utf8");
    try {
      return JSON.parse(l);
    } catch (d) {
      const u = d;
      throw u.message += ` (input: ${l})`, u;
    }
  }
  Gt.json = o;
  function a(A, c = {}) {
    const d = ((typeof A == "string" ? A : A.href).startsWith("https:") ? s : n).request(A, c), u = new Promise((m, h) => {
      d.once("response", m).once("error", h).end();
    });
    return d.then = u.then.bind(u), d;
  }
  return Gt.req = a, Gt;
}
var qh;
function _f() {
  return qh || (qh = 1, (function(t) {
    var e = gr && gr.__createBinding || (Object.create ? (function(l, d, u, m) {
      m === void 0 && (m = u);
      var h = Object.getOwnPropertyDescriptor(d, u);
      (!h || ("get" in h ? !d.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
        return d[u];
      } }), Object.defineProperty(l, m, h);
    }) : (function(l, d, u, m) {
      m === void 0 && (m = u), l[m] = d[u];
    })), r = gr && gr.__setModuleDefault || (Object.create ? (function(l, d) {
      Object.defineProperty(l, "default", { enumerable: !0, value: d });
    }) : function(l, d) {
      l.default = d;
    }), n = gr && gr.__importStar || function(l) {
      if (l && l.__esModule) return l;
      var d = {};
      if (l != null) for (var u in l) u !== "default" && Object.prototype.hasOwnProperty.call(l, u) && e(d, l, u);
      return r(d, l), d;
    }, s = gr && gr.__exportStar || function(l, d) {
      for (var u in l) u !== "default" && !Object.prototype.hasOwnProperty.call(d, u) && e(d, l, u);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Agent = void 0;
    const i = n(ul), o = n(ll), a = dl;
    s(Yw(), t);
    const A = /* @__PURE__ */ Symbol("AgentBaseInternalState");
    class c extends o.Agent {
      constructor(d) {
        super(d), this[A] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(d) {
        if (d) {
          if (typeof d.secureEndpoint == "boolean")
            return d.secureEndpoint;
          if (typeof d.protocol == "string")
            return d.protocol === "https:";
        }
        const { stack: u } = new Error();
        return typeof u != "string" ? !1 : u.split(`
`).some((m) => m.indexOf("(https.js:") !== -1 || m.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(d) {
        if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
          return null;
        this.sockets[d] || (this.sockets[d] = []);
        const u = new i.Socket({ writable: !1 });
        return this.sockets[d].push(u), this.totalSocketCount++, u;
      }
      decrementSockets(d, u) {
        if (!this.sockets[d] || u === null)
          return;
        const m = this.sockets[d], h = m.indexOf(u);
        h !== -1 && (m.splice(h, 1), this.totalSocketCount--, m.length === 0 && delete this.sockets[d]);
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(d) {
        return this.isSecureEndpoint(d) ? a.Agent.prototype.getName.call(this, d) : super.getName(d);
      }
      createSocket(d, u, m) {
        const h = {
          ...u,
          secureEndpoint: this.isSecureEndpoint(u)
        }, f = this.getName(h), p = this.incrementSockets(f);
        Promise.resolve().then(() => this.connect(d, h)).then((y) => {
          if (this.decrementSockets(f, p), y instanceof o.Agent)
            try {
              return y.addRequest(d, h);
            } catch (w) {
              return m(w);
            }
          this[A].currentSocket = y, super.createSocket(d, u, m);
        }, (y) => {
          this.decrementSockets(f, p), m(y);
        });
      }
      createConnection() {
        const d = this[A].currentSocket;
        if (this[A].currentSocket = void 0, !d)
          throw new Error("No socket was returned in the `connect()` function");
        return d;
      }
      get defaultPort() {
        return this[A].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(d) {
        this[A] && (this[A].defaultPort = d);
      }
      get protocol() {
        return this[A].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(d) {
        this[A] && (this[A].protocol = d);
      }
    }
    t.Agent = c;
  })(gr)), gr;
}
var un = {}, Gh;
function Jw() {
  if (Gh) return un;
  Gh = 1;
  var t = un && un.__importDefault || function(s) {
    return s && s.__esModule ? s : { default: s };
  };
  Object.defineProperty(un, "__esModule", { value: !0 }), un.parseProxyResponse = void 0;
  const r = (0, t(Yl()).default)("https-proxy-agent:parse-proxy-response");
  function n(s) {
    return new Promise((i, o) => {
      let a = 0;
      const A = [];
      function c() {
        const h = s.read();
        h ? m(h) : s.once("readable", c);
      }
      function l() {
        s.removeListener("end", d), s.removeListener("error", u), s.removeListener("readable", c);
      }
      function d() {
        l(), r("onend"), o(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function u(h) {
        l(), r("onerror %o", h), o(h);
      }
      function m(h) {
        A.push(h), a += h.length;
        const f = Buffer.concat(A, a), p = f.indexOf(`\r
\r
`);
        if (p === -1) {
          r("have not received end of HTTP headers yet..."), c();
          return;
        }
        const y = f.slice(0, p).toString("ascii").split(`\r
`), w = y.shift();
        if (!w)
          return s.destroy(), o(new Error("No header received from proxy CONNECT response"));
        const R = w.split(" "), D = +R[1], L = R.slice(2).join(" "), C = {};
        for (const I of y) {
          if (!I)
            continue;
          const x = I.indexOf(":");
          if (x === -1)
            return s.destroy(), o(new Error(`Invalid header from proxy CONNECT response: "${I}"`));
          const g = I.slice(0, x).toLowerCase(), B = I.slice(x + 1).trimStart(), Q = C[g];
          typeof Q == "string" ? C[g] = [Q, B] : Array.isArray(Q) ? Q.push(B) : C[g] = B;
        }
        r("got proxy server response: %o %o", w, C), l(), i({
          connect: {
            statusCode: D,
            statusText: L,
            headers: C
          },
          buffered: f
        });
      }
      s.on("error", u), s.on("end", d), c();
    });
  }
  return un.parseProxyResponse = n, un;
}
var Yh;
function Vw() {
  if (Yh) return er;
  Yh = 1;
  var t = er && er.__createBinding || (Object.create ? (function(p, y, w, R) {
    R === void 0 && (R = w);
    var D = Object.getOwnPropertyDescriptor(y, w);
    (!D || ("get" in D ? !y.__esModule : D.writable || D.configurable)) && (D = { enumerable: !0, get: function() {
      return y[w];
    } }), Object.defineProperty(p, R, D);
  }) : (function(p, y, w, R) {
    R === void 0 && (R = w), p[R] = y[w];
  })), e = er && er.__setModuleDefault || (Object.create ? (function(p, y) {
    Object.defineProperty(p, "default", { enumerable: !0, value: y });
  }) : function(p, y) {
    p.default = y;
  }), r = er && er.__importStar || function(p) {
    if (p && p.__esModule) return p;
    var y = {};
    if (p != null) for (var w in p) w !== "default" && Object.prototype.hasOwnProperty.call(p, w) && t(y, p, w);
    return e(y, p), y;
  }, n = er && er.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(er, "__esModule", { value: !0 }), er.HttpsProxyAgent = void 0;
  const s = r(ul), i = r(ml), o = n(yt), a = n(Yl()), A = _f(), c = Kg, l = Jw(), d = (0, a.default)("https-proxy-agent"), u = (p) => p.servername === void 0 && p.host && !s.isIP(p.host) ? {
    ...p,
    servername: p.host
  } : p;
  class m extends A.Agent {
    constructor(y, w) {
      super(w), this.options = { path: void 0 }, this.proxy = typeof y == "string" ? new c.URL(y) : y, this.proxyHeaders = w?.headers ?? {}, d("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const R = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), D = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        // Attempt to negotiate http/1.1 for proxy servers that support http/2
        ALPNProtocols: ["http/1.1"],
        ...w ? f(w, "headers") : null,
        host: R,
        port: D
      };
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */
    async connect(y, w) {
      const { proxy: R } = this;
      if (!w.host)
        throw new TypeError('No "host" provided');
      let D;
      R.protocol === "https:" ? (d("Creating `tls.Socket`: %o", this.connectOpts), D = i.connect(u(this.connectOpts))) : (d("Creating `net.Socket`: %o", this.connectOpts), D = s.connect(this.connectOpts));
      const L = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, C = s.isIPv6(w.host) ? `[${w.host}]` : w.host;
      let I = `CONNECT ${C}:${w.port} HTTP/1.1\r
`;
      if (R.username || R.password) {
        const E = `${decodeURIComponent(R.username)}:${decodeURIComponent(R.password)}`;
        L["Proxy-Authorization"] = `Basic ${Buffer.from(E).toString("base64")}`;
      }
      L.Host = `${C}:${w.port}`, L["Proxy-Connection"] || (L["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (const E of Object.keys(L))
        I += `${E}: ${L[E]}\r
`;
      const x = (0, l.parseProxyResponse)(D);
      D.write(`${I}\r
`);
      const { connect: g, buffered: B } = await x;
      if (y.emit("proxyConnect", g), this.emit("proxyConnect", g, y), g.statusCode === 200)
        return y.once("socket", h), w.secureEndpoint ? (d("Upgrading socket connection to TLS"), i.connect({
          ...f(u(w), "host", "path", "port"),
          socket: D
        })) : D;
      D.destroy();
      const Q = new s.Socket({ writable: !1 });
      return Q.readable = !0, y.once("socket", (E) => {
        d("Replaying proxy buffer for failed request"), (0, o.default)(E.listenerCount("data") > 0), E.push(B), E.push(null);
      }), Q;
    }
  }
  m.protocols = ["http", "https"], er.HttpsProxyAgent = m;
  function h(p) {
    p.resume();
  }
  function f(p, ...y) {
    const w = {};
    let R;
    for (R in p)
      y.includes(R) || (w[R] = p[R]);
    return w;
  }
  return er;
}
var _w = Vw(), tr = {}, Jh;
function Ww() {
  if (Jh) return tr;
  Jh = 1;
  var t = tr && tr.__createBinding || (Object.create ? (function(m, h, f, p) {
    p === void 0 && (p = f);
    var y = Object.getOwnPropertyDescriptor(h, f);
    (!y || ("get" in y ? !h.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return h[f];
    } }), Object.defineProperty(m, p, y);
  }) : (function(m, h, f, p) {
    p === void 0 && (p = f), m[p] = h[f];
  })), e = tr && tr.__setModuleDefault || (Object.create ? (function(m, h) {
    Object.defineProperty(m, "default", { enumerable: !0, value: h });
  }) : function(m, h) {
    m.default = h;
  }), r = tr && tr.__importStar || function(m) {
    if (m && m.__esModule) return m;
    var h = {};
    if (m != null) for (var f in m) f !== "default" && Object.prototype.hasOwnProperty.call(m, f) && t(h, m, f);
    return e(h, m), h;
  }, n = tr && tr.__importDefault || function(m) {
    return m && m.__esModule ? m : { default: m };
  };
  Object.defineProperty(tr, "__esModule", { value: !0 }), tr.HttpProxyAgent = void 0;
  const s = r(ul), i = r(ml), o = n(Yl()), a = _g, A = _f(), c = Kg, l = (0, o.default)("http-proxy-agent");
  class d extends A.Agent {
    constructor(h, f) {
      super(f), this.proxy = typeof h == "string" ? new c.URL(h) : h, this.proxyHeaders = f?.headers ?? {}, l("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const p = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), y = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...f ? u(f, "headers") : null,
        host: p,
        port: y
      };
    }
    addRequest(h, f) {
      h._header = null, this.setRequestProps(h, f), super.addRequest(h, f);
    }
    setRequestProps(h, f) {
      const { proxy: p } = this, y = f.secureEndpoint ? "https:" : "http:", w = h.getHeader("host") || "localhost", R = `${y}//${w}`, D = new c.URL(h.path, R);
      f.port !== 80 && (D.port = String(f.port)), h.path = String(D);
      const L = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (p.username || p.password) {
        const C = `${decodeURIComponent(p.username)}:${decodeURIComponent(p.password)}`;
        L["Proxy-Authorization"] = `Basic ${Buffer.from(C).toString("base64")}`;
      }
      L["Proxy-Connection"] || (L["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (const C of Object.keys(L)) {
        const I = L[C];
        I && h.setHeader(C, I);
      }
    }
    async connect(h, f) {
      h._header = null, h.path.includes("://") || this.setRequestProps(h, f);
      let p, y;
      l("Regenerating stored HTTP header string for request"), h._implicitHeader(), h.outputData && h.outputData.length > 0 && (l("Patching connection write() output buffer with updated header"), p = h.outputData[0].data, y = p.indexOf(`\r
\r
`) + 4, h.outputData[0].data = h._header + p.substring(y), l("Output buffer: %o", h.outputData[0].data));
      let w;
      return this.proxy.protocol === "https:" ? (l("Creating `tls.Socket`: %o", this.connectOpts), w = i.connect(this.connectOpts)) : (l("Creating `net.Socket`: %o", this.connectOpts), w = s.connect(this.connectOpts)), await (0, a.once)(w, "connect"), w;
    }
  }
  d.protocols = ["http", "https"], tr.HttpProxyAgent = d;
  function u(m, ...h) {
    const f = {};
    let p;
    for (p in m)
      h.includes(p) || (f[p] = m[p]);
    return f;
  }
  return tr;
}
var $w = Ww();
const Xw = "HTTPS_PROXY", Zw = "HTTP_PROXY", Kw = "ALL_PROXY", jw = "NO_PROXY", e0 = "proxyPolicy", Vh = [];
let Wf = !1;
const t0 = /* @__PURE__ */ new Map();
function Mi(t) {
  if (process.env[t])
    return process.env[t];
  if (process.env[t.toLowerCase()])
    return process.env[t.toLowerCase()];
}
function $f() {
  if (!process)
    return;
  const t = Mi(Xw), e = Mi(Kw), r = Mi(Zw);
  return t || e || r;
}
function r0(t, e, r) {
  if (e.length === 0)
    return !1;
  const n = new URL(t).hostname;
  if (r?.has(n))
    return r.get(n);
  let s = !1;
  for (const i of e)
    i[0] === "." ? (n.endsWith(i) || n.length === i.length - 1 && n === i.slice(1)) && (s = !0) : n === i && (s = !0);
  return r?.set(n, s), s;
}
function n0() {
  const t = Mi(jw);
  return Wf = !0, t ? t.split(",").map((e) => e.trim()).filter((e) => e.length) : [];
}
function s0(t) {
  if (!t && (t = $f(), !t))
    return;
  const e = new URL(t);
  return {
    host: (e.protocol ? e.protocol + "//" : "") + e.hostname,
    port: Number.parseInt(e.port || "80"),
    username: e.username,
    password: e.password
  };
}
function i0() {
  const t = $f();
  return t ? new URL(t) : void 0;
}
function _h(t) {
  let e;
  try {
    e = new URL(t.host);
  } catch {
    throw new Error(`Expecting a valid host string in proxy settings, but found "${t.host}".`);
  }
  return e.port = String(t.port), t.username && (e.username = t.username), t.password && (e.password = t.password), e;
}
function Wh(t, e, r) {
  if (t.agent)
    return;
  const s = new URL(t.url).protocol !== "https:";
  t.tlsSettings && Vr.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
  const i = t.headers.toJSON();
  s ? (e.httpProxyAgent || (e.httpProxyAgent = new $w.HttpProxyAgent(r, { headers: i })), t.agent = e.httpProxyAgent) : (e.httpsProxyAgent || (e.httpsProxyAgent = new _w.HttpsProxyAgent(r, { headers: i })), t.agent = e.httpsProxyAgent);
}
function o0(t, e) {
  Wf || Vh.push(...n0());
  const r = t ? _h(t) : i0(), n = {};
  return {
    name: e0,
    async sendRequest(s, i) {
      return !s.proxySettings && r && !r0(s.url, Vh, t0) ? Wh(s, n, r) : s.proxySettings && Wh(s, n, _h(s.proxySettings)), i(s);
    }
  };
}
const a0 = "agentPolicy";
function A0(t) {
  return {
    name: a0,
    sendRequest: async (e, r) => (e.agent || (e.agent = t), r(e))
  };
}
const c0 = "tlsPolicy";
function l0(t) {
  return {
    name: c0,
    sendRequest: async (e, r) => (e.tlsSettings || (e.tlsSettings = t), r(e))
  };
}
function Xf(t) {
  return typeof t.stream == "function";
}
async function* $h() {
  const t = this.getReader();
  try {
    for (; ; ) {
      const { done: e, value: r } = await t.read();
      if (e)
        return;
      yield r;
    }
  } finally {
    t.releaseLock();
  }
}
function d0(t) {
  t[Symbol.asyncIterator] || (t[Symbol.asyncIterator] = $h.bind(t)), t.values || (t.values = $h.bind(t));
}
function Xh(t) {
  return t instanceof ReadableStream ? (d0(t), fl.fromWeb(t)) : t;
}
function u0(t) {
  return t instanceof Uint8Array ? fl.from(Buffer.from(t)) : Xf(t) ? Xh(t.stream()) : Xh(t);
}
async function m0(t) {
  return function() {
    const e = t.map((r) => typeof r == "function" ? r() : r).map(u0);
    return fl.from((async function* () {
      for (const r of e)
        for await (const n of r)
          yield n;
    })());
  };
}
function h0() {
  return `----AzSDKFormBoundary${ql()}`;
}
function g0(t) {
  let e = "";
  for (const [r, n] of t)
    e += `${r}: ${n}\r
`;
  return e;
}
function f0(t) {
  return t instanceof Uint8Array ? t.byteLength : Xf(t) ? t.size === -1 ? void 0 : t.size : void 0;
}
function p0(t) {
  let e = 0;
  for (const r of t) {
    const n = f0(r);
    if (n === void 0)
      return;
    e += n;
  }
  return e;
}
async function E0(t, e, r) {
  const n = [
    gn(`--${r}`, "utf-8"),
    ...e.flatMap((i) => [
      gn(`\r
`, "utf-8"),
      gn(g0(i.headers), "utf-8"),
      gn(`\r
`, "utf-8"),
      i.body,
      gn(`\r
--${r}`, "utf-8")
    ]),
    gn(`--\r
\r
`, "utf-8")
  ], s = p0(n);
  s && t.headers.set("Content-Length", s), t.body = await m0(n);
}
const Zf = "multipartPolicy", C0 = 70, B0 = new Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?");
function I0(t) {
  if (t.length > C0)
    throw new Error(`Multipart boundary "${t}" exceeds maximum length of 70 characters`);
  if (Array.from(t).some((e) => !B0.has(e)))
    throw new Error(`Multipart boundary "${t}" contains invalid characters`);
}
function y0() {
  return {
    name: Zf,
    async sendRequest(t, e) {
      if (!t.multipartBody)
        return e(t);
      if (t.body)
        throw new Error("multipartBody and regular body cannot be set at the same time");
      let r = t.multipartBody.boundary;
      const n = t.headers.get("Content-Type") ?? "multipart/mixed", s = n.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!s)
        throw new Error(`Got multipart request body, but content-type header was not multipart: ${n}`);
      const [, i, o] = s;
      if (o && r && o !== r)
        throw new Error(`Multipart boundary was specified as ${o} in the header, but got ${r} in the request body`);
      return r ??= o, r ? I0(r) : r = h0(), t.headers.set("Content-Type", `${i}; boundary=${r}`), await E0(t, t.multipartBody.parts, r), t.multipartBody = void 0, e(t);
    }
  };
}
function Q0() {
  return tw();
}
const N0 = Uf({
  logLevelEnvVarName: "AZURE_LOG_LEVEL",
  namespace: "azure"
});
function Co(t) {
  return N0.createClientLogger(t);
}
const ns = Co("core-rest-pipeline");
function w0(t = {}) {
  return fw({
    logger: ns.info,
    ...t
  });
}
const b0 = qf;
function x0(t = {}) {
  return pw(t);
}
function R0() {
  return "User-Agent";
}
async function S0(t) {
  if (ki && ki.versions) {
    const e = `${qo.type()} ${qo.release()}; ${qo.arch()}`, r = ki.versions;
    r.bun ? t.set("Bun", `${r.bun} (${e})`) : r.deno ? t.set("Deno", `${r.deno} (${e})`) : r.node && t.set("Node", `${r.node} (${e})`);
  }
}
const Kf = "1.22.2";
function D0(t) {
  const e = [];
  for (const [r, n] of t) {
    const s = n ? `${r}/${n}` : r;
    e.push(s);
  }
  return e.join(" ");
}
function k0() {
  return R0();
}
async function jf(t) {
  const e = /* @__PURE__ */ new Map();
  e.set("core-rest-pipeline", Kf), await S0(e);
  const r = D0(e);
  return t ? `${t} ${r}` : r;
}
const Zh = k0(), M0 = "userAgentPolicy";
function T0(t = {}) {
  const e = jf(t.userAgentPrefix);
  return {
    name: M0,
    async sendRequest(r, n) {
      return r.headers.has(Zh) || r.headers.set(Zh, await e), n(r);
    }
  };
}
class ii extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
}
function F0(t, e) {
  const { cleanupBeforeAbort: r, abortSignal: n, abortErrorMsg: s } = e ?? {};
  return new Promise((i, o) => {
    function a() {
      o(new ii(s ?? "The operation was aborted."));
    }
    function A() {
      n?.removeEventListener("abort", c);
    }
    function c() {
      r?.(), A(), a();
    }
    if (n?.aborted)
      return a();
    try {
      t((l) => {
        A(), i(l);
      }, (l) => {
        A(), o(l);
      });
    } catch (l) {
      o(l);
    }
    n?.addEventListener("abort", c);
  });
}
const v0 = "The delay was aborted.";
function ep(t, e) {
  let r;
  const { abortSignal: n, abortErrorMsg: s } = {};
  return F0((i) => {
    r = setTimeout(i, t);
  }, {
    cleanupBeforeAbort: () => clearTimeout(r),
    abortSignal: n,
    abortErrorMsg: s ?? v0
  });
}
function oi(t) {
  if (Gl(t))
    return t.message;
  {
    let e;
    try {
      typeof t == "object" && t ? e = JSON.stringify(t) : e = String(t);
    } catch {
      e = "[unable to stringify input]";
    }
    return `Unknown error ${e}`;
  }
}
function L0(t) {
  return Gl(t);
}
function $c() {
  return ql();
}
const Rt = Vf, tp = /* @__PURE__ */ Symbol("rawContent");
function rp(t) {
  return typeof t[tp] == "function";
}
function U0(t) {
  return rp(t) ? t[tp]() : t;
}
const np = Zf;
function P0() {
  const t = y0();
  return {
    name: np,
    sendRequest: async (e, r) => {
      if (e.multipartBody)
        for (const n of e.multipartBody.parts)
          rp(n.body) && (n.body = U0(n.body));
      return t.sendRequest(e, r);
    }
  };
}
const H0 = Yf;
function O0() {
  return Ew();
}
function z0(t = {}) {
  return Lw(t);
}
function q0() {
  return Hw();
}
function Bo(t) {
  return s0(t);
}
function G0(t, e) {
  return o0(t);
}
const Y0 = "setClientRequestIdPolicy";
function J0(t = "x-ms-client-request-id") {
  return {
    name: Y0,
    async sendRequest(e, r) {
      return e.headers.has(t) || e.headers.set(t, e.requestId), r(e);
    }
  };
}
function V0(t) {
  return A0(t);
}
function _0(t) {
  return l0(t);
}
const Ms = {
  span: /* @__PURE__ */ Symbol.for("@azure/core-tracing span"),
  namespace: /* @__PURE__ */ Symbol.for("@azure/core-tracing namespace")
};
function W0(t = {}) {
  let e = new Ts(t.parentContext);
  return t.span && (e = e.setValue(Ms.span, t.span)), t.namespace && (e = e.setValue(Ms.namespace, t.namespace)), e;
}
class Ts {
  _contextMap;
  constructor(e) {
    this._contextMap = e instanceof Ts ? new Map(e._contextMap) : /* @__PURE__ */ new Map();
  }
  setValue(e, r) {
    const n = new Ts(this);
    return n._contextMap.set(e, r), n;
  }
  getValue(e) {
    return this._contextMap.get(e);
  }
  deleteValue(e) {
    const r = new Ts(this);
    return r._contextMap.delete(e), r;
  }
}
var bs = {}, Kh;
function $0() {
  return Kh || (Kh = 1, Object.defineProperty(bs, "__esModule", { value: !0 }), bs.state = void 0, bs.state = {
    instrumenterImplementation: void 0
  }), bs;
}
var X0 = $0();
const Sc = X0.state;
function Z0() {
  return {
    end: () => {
    },
    isRecording: () => !1,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    },
    addEvent: () => {
    }
  };
}
function K0() {
  return {
    createRequestHeaders: () => ({}),
    parseTraceparentHeader: () => {
    },
    startSpan: (t, e) => ({
      span: Z0(),
      tracingContext: W0({ parentContext: e.tracingContext })
    }),
    withContext(t, e, ...r) {
      return e(...r);
    }
  };
}
function Ni() {
  return Sc.instrumenterImplementation || (Sc.instrumenterImplementation = K0()), Sc.instrumenterImplementation;
}
function sp(t) {
  const { namespace: e, packageName: r, packageVersion: n } = t;
  function s(c, l, d) {
    const u = Ni().startSpan(c, {
      ...d,
      packageName: r,
      packageVersion: n,
      tracingContext: l?.tracingOptions?.tracingContext
    });
    let m = u.tracingContext;
    const h = u.span;
    m.getValue(Ms.namespace) || (m = m.setValue(Ms.namespace, e)), h.setAttribute("az.namespace", m.getValue(Ms.namespace));
    const f = Object.assign({}, l, {
      tracingOptions: { ...l?.tracingOptions, tracingContext: m }
    });
    return {
      span: h,
      updatedOptions: f
    };
  }
  async function i(c, l, d, u) {
    const { span: m, updatedOptions: h } = s(c, l, u);
    try {
      const f = await o(h.tracingOptions.tracingContext, () => Promise.resolve(d(h, m)));
      return m.setStatus({ status: "success" }), f;
    } catch (f) {
      throw m.setStatus({ status: "error", error: f }), f;
    } finally {
      m.end();
    }
  }
  function o(c, l, ...d) {
    return Ni().withContext(c, l, ...d);
  }
  function a(c) {
    return Ni().parseTraceparentHeader(c);
  }
  function A(c) {
    return Ni().createRequestHeaders(c);
  }
  return {
    startSpan: s,
    withSpan: i,
    withContext: o,
    parseTraceparentHeader: a,
    createRequestHeaders: A
  };
}
const zs = yn;
function Jl(t) {
  return ow(t);
}
const j0 = "tracingPolicy";
function eb(t = {}) {
  const e = jf(t.userAgentPrefix), r = new Eo({
    additionalAllowedQueryParameters: t.additionalAllowedQueryParameters
  }), n = tb();
  return {
    name: j0,
    async sendRequest(s, i) {
      if (!n)
        return i(s);
      const o = await e, a = {
        "http.url": r.sanitizeUrl(s.url),
        "http.method": s.method,
        "http.user_agent": o,
        requestId: s.requestId
      };
      o && (a["http.user_agent"] = o);
      const { span: A, tracingContext: c } = rb(n, s, a) ?? {};
      if (!A || !c)
        return i(s);
      try {
        const l = await n.withContext(c, i, s);
        return sb(A, l), l;
      } catch (l) {
        throw nb(A, l), l;
      }
    }
  };
}
function tb() {
  try {
    return sp({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: Kf
    });
  } catch (t) {
    ns.warning(`Error when creating the TracingClient: ${oi(t)}`);
    return;
  }
}
function rb(t, e, r) {
  try {
    const { span: n, updatedOptions: s } = t.startSpan(`HTTP ${e.method}`, { tracingOptions: e.tracingOptions }, {
      spanKind: "client",
      spanAttributes: r
    });
    if (!n.isRecording()) {
      n.end();
      return;
    }
    const i = t.createRequestHeaders(s.tracingOptions.tracingContext);
    for (const [o, a] of Object.entries(i))
      e.headers.set(o, a);
    return { span: n, tracingContext: s.tracingOptions.tracingContext };
  } catch (n) {
    ns.warning(`Skipping creating a tracing span due to an error: ${oi(n)}`);
    return;
  }
}
function nb(t, e) {
  try {
    t.setStatus({
      status: "error",
      error: L0(e) ? e : void 0
    }), Jl(e) && e.statusCode && t.setAttribute("http.status_code", e.statusCode), t.end();
  } catch (r) {
    ns.warning(`Skipping tracing span processing due to an error: ${oi(r)}`);
  }
}
function sb(t, e) {
  try {
    t.setAttribute("http.status_code", e.status);
    const r = e.headers.get("x-ms-request-id");
    r && t.setAttribute("serviceRequestId", r), e.status >= 400 && t.setStatus({
      status: "error"
    }), t.end();
  } catch (r) {
    ns.warning(`Skipping tracing span processing due to an error: ${oi(r)}`);
  }
}
function ip(t) {
  if (t instanceof AbortSignal)
    return { abortSignal: t };
  if (t.aborted)
    return { abortSignal: AbortSignal.abort(t.reason) };
  const e = new AbortController();
  let r = !0;
  function n() {
    r && (t.removeEventListener("abort", s), r = !1);
  }
  function s() {
    e.abort(t.reason), n();
  }
  return t.addEventListener("abort", s), { abortSignal: e.signal, cleanup: n };
}
const ib = "wrapAbortSignalLikePolicy";
function ob() {
  return {
    name: ib,
    sendRequest: async (t, e) => {
      if (!t.abortSignal)
        return e(t);
      const { abortSignal: r, cleanup: n } = ip(t.abortSignal);
      t.abortSignal = r;
      try {
        return await e(t);
      } finally {
        n?.();
      }
    }
  };
}
function ab(t) {
  const e = Q0();
  return Rt && (t.agent && e.addPolicy(V0(t.agent)), t.tlsOptions && e.addPolicy(_0(t.tlsOptions)), e.addPolicy(G0(t.proxyOptions)), e.addPolicy(O0())), e.addPolicy(ob()), e.addPolicy(q0(), { beforePolicies: [np] }), e.addPolicy(T0(t.userAgentOptions)), e.addPolicy(J0(t.telemetryOptions?.clientRequestIdHeaderName)), e.addPolicy(P0(), { afterPhase: "Deserialize" }), e.addPolicy(z0(t.retryOptions), { phase: "Retry" }), e.addPolicy(eb({ ...t.userAgentOptions, ...t.loggingOptions }), {
    afterPhase: "Retry"
  }), Rt && e.addPolicy(x0(t.redirectOptions), { afterPhase: "Retry" }), e.addPolicy(w0(t.loggingOptions), { afterPhase: "Sign" }), e;
}
function op() {
  const t = hw();
  return {
    async sendRequest(e) {
      const { abortSignal: r, cleanup: n } = e.abortSignal ? ip(e.abortSignal) : {};
      try {
        return e.abortSignal = r, await t.sendRequest(e);
      } finally {
        n?.();
      }
    }
  };
}
function ap(t) {
  return Os(t);
}
function Ap(t) {
  return ew(t);
}
const Ab = {
  forcedRefreshWindowInMs: 1e3,
  // Force waiting for a refresh 1s before the token expires
  retryIntervalInMs: 3e3,
  // Allow refresh attempts every 3s
  refreshWindowInMs: 1e3 * 60 * 2
  // Start refreshing 2m before expiry
};
async function cb(t, e, r) {
  async function n() {
    if (Date.now() < r)
      try {
        return await t();
      } catch {
        return null;
      }
    else {
      const i = await t();
      if (i === null)
        throw new Error("Failed to refresh access token.");
      return i;
    }
  }
  let s = await n();
  for (; s === null; )
    await ep(e), s = await n();
  return s;
}
function lb(t, e) {
  let r = null, n = null, s;
  const i = {
    ...Ab,
    ...e
  }, o = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return r !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      return o.isRefreshing ? !1 : n?.refreshAfterTimestamp && n.refreshAfterTimestamp < Date.now() ? !0 : (n?.expiresOnTimestamp ?? 0) - i.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return n === null || n.expiresOnTimestamp - i.forcedRefreshWindowInMs < Date.now();
    }
  };
  function a(A, c) {
    return o.isRefreshing || (r = cb(
      () => t.getToken(A, c),
      i.retryIntervalInMs,
      // If we don't have a token, then we should timeout immediately
      n?.expiresOnTimestamp ?? Date.now()
    ).then((d) => (r = null, n = d, s = c.tenantId, n)).catch((d) => {
      throw r = null, n = null, s = void 0, d;
    })), r;
  }
  return async (A, c) => {
    const l = !!c.claims, d = s !== c.tenantId;
    return l && (n = null), d || l || o.mustRefresh ? a(A, c) : (o.shouldRefresh && a(A, c), n);
  };
}
const db = "bearerTokenAuthenticationPolicy";
async function wi(t, e) {
  try {
    return [await e(t), void 0];
  } catch (r) {
    if (Jl(r) && r.response)
      return [r.response, r];
    throw r;
  }
}
async function ub(t) {
  const { scopes: e, getAccessToken: r, request: n } = t, s = {
    abortSignal: n.abortSignal,
    tracingOptions: n.tracingOptions,
    enableCae: !0
  }, i = await r(e, s);
  i && t.request.headers.set("Authorization", `Bearer ${i.token}`);
}
function jh(t) {
  return t.status === 401 && t.headers.has("WWW-Authenticate");
}
async function eg(t, e) {
  const { scopes: r } = t, n = await t.getAccessToken(r, {
    enableCae: !0,
    claims: e
  });
  return n ? (t.request.headers.set("Authorization", `${n.tokenType ?? "Bearer"} ${n.token}`), !0) : !1;
}
function cp(t) {
  const { credential: e, scopes: r, challengeCallbacks: n } = t, s = t.logger || ns, i = {
    authorizeRequest: n?.authorizeRequest?.bind(n) ?? ub,
    authorizeRequestOnChallenge: n?.authorizeRequestOnChallenge?.bind(n)
  }, o = e ? lb(
    e
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: db,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(a, A) {
      if (!a.url.toLowerCase().startsWith("https://"))
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      await i.authorizeRequest({
        scopes: Array.isArray(r) ? r : [r],
        request: a,
        getAccessToken: o,
        logger: s
      });
      let c, l, d;
      if ([c, l] = await wi(a, A), jh(c)) {
        let u = tg(c.headers.get("WWW-Authenticate"));
        if (u) {
          let m;
          try {
            m = atob(u);
          } catch {
            return s.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${u}`), c;
          }
          d = await eg({
            scopes: Array.isArray(r) ? r : [r],
            response: c,
            request: a,
            getAccessToken: o,
            logger: s
          }, m), d && ([c, l] = await wi(a, A));
        } else if (i.authorizeRequestOnChallenge && (d = await i.authorizeRequestOnChallenge({
          scopes: Array.isArray(r) ? r : [r],
          request: a,
          response: c,
          getAccessToken: o,
          logger: s
        }), d && ([c, l] = await wi(a, A)), jh(c) && (u = tg(c.headers.get("WWW-Authenticate")), u))) {
          let m;
          try {
            m = atob(u);
          } catch {
            return s.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${u}`), c;
          }
          d = await eg({
            scopes: Array.isArray(r) ? r : [r],
            response: c,
            request: a,
            getAccessToken: o,
            logger: s
          }, m), d && ([c, l] = await wi(a, A));
        }
      }
      if (l)
        throw l;
      return c;
    }
  };
}
function mb(t) {
  const e = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g, r = /(\w+)="([^"]*)"/g, n = [];
  let s;
  for (; (s = e.exec(t)) !== null; ) {
    const i = s[1], o = s[2], a = {};
    let A;
    for (; (A = r.exec(o)) !== null; )
      a[A[1]] = A[2];
    n.push({ scheme: i, params: a });
  }
  return n;
}
function tg(t) {
  return t ? mb(t).find((r) => r.scheme === "Bearer" && r.params.claims && r.params.error === "insufficient_claims")?.params.claims : void 0;
}
function kn(t) {
  const e = t;
  return e && typeof e.getToken == "function" && (e.signRequest === void 0 || e.getToken.length > 0);
}
const lp = "DisableKeepAlivePolicy";
function hb() {
  return {
    name: lp,
    async sendRequest(t, e) {
      return t.disableKeepAlive = !0, e(t);
    }
  };
}
function gb(t) {
  return t.getOrderedPolicies().some((e) => e.name === lp);
}
function dp(t) {
  return (t instanceof Buffer ? t : Buffer.from(t.buffer)).toString("base64");
}
function up(t) {
  return Buffer.from(t, "base64");
}
const Lt = "$", qs = "_";
function fb(t, e) {
  return e !== "Composite" && e !== "Dictionary" && (typeof t == "string" || typeof t == "number" || typeof t == "boolean" || e?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || t === void 0 || t === null);
}
const pb = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Eb(t) {
  return pb.test(t);
}
const Cb = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
function Bb(t) {
  return Cb.test(t);
}
function Ib(t) {
  const e = {
    ...t.headers,
    ...t.body
  };
  return t.hasNullableType && Object.getOwnPropertyNames(e).length === 0 ? t.shouldWrapBody ? { body: null } : null : t.shouldWrapBody ? {
    ...t.headers,
    body: t.body
  } : e;
}
function rg(t, e) {
  const r = t.parsedHeaders;
  if (t.request.method === "HEAD")
    return {
      ...r,
      body: t.parsedBody
    };
  const n = e && e.bodyMapper, s = !!n?.nullable, i = n?.type.name;
  if (i === "Stream")
    return {
      ...r,
      blobBody: t.blobBody,
      readableStreamBody: t.readableStreamBody
    };
  const o = i === "Composite" && n.type.modelProperties || {}, a = Object.keys(o).some((A) => o[A].serializedName === "");
  if (i === "Sequence" || a) {
    const A = t.parsedBody ?? [];
    for (const c of Object.keys(o))
      o[c].serializedName && (A[c] = t.parsedBody?.[c]);
    if (r)
      for (const c of Object.keys(r))
        A[c] = r[c];
    return s && !t.parsedBody && !r && Object.getOwnPropertyNames(o).length === 0 ? null : A;
  }
  return Ib({
    body: t.parsedBody,
    headers: r,
    hasNullableType: s,
    shouldWrapBody: fb(t.parsedBody, i)
  });
}
class yb {
  modelMappers;
  isXML;
  constructor(e = {}, r = !1) {
    this.modelMappers = e, this.isXML = r;
  }
  /**
   * @deprecated Removing the constraints validation on client side.
   */
  validateConstraints(e, r, n) {
    const s = (i, o) => {
      throw new Error(`"${n}" with value "${r}" should satisfy the constraint "${i}": ${o}.`);
    };
    if (e.constraints && r !== void 0 && r !== null) {
      const { ExclusiveMaximum: i, ExclusiveMinimum: o, InclusiveMaximum: a, InclusiveMinimum: A, MaxItems: c, MaxLength: l, MinItems: d, MinLength: u, MultipleOf: m, Pattern: h, UniqueItems: f } = e.constraints;
      if (i !== void 0 && r >= i && s("ExclusiveMaximum", i), o !== void 0 && r <= o && s("ExclusiveMinimum", o), a !== void 0 && r > a && s("InclusiveMaximum", a), A !== void 0 && r < A && s("InclusiveMinimum", A), c !== void 0 && r.length > c && s("MaxItems", c), l !== void 0 && r.length > l && s("MaxLength", l), d !== void 0 && r.length < d && s("MinItems", d), u !== void 0 && r.length < u && s("MinLength", u), m !== void 0 && r % m !== 0 && s("MultipleOf", m), h) {
        const p = typeof h == "string" ? new RegExp(h) : h;
        (typeof r != "string" || r.match(p) === null) && s("Pattern", h);
      }
      f && r.some((p, y, w) => w.indexOf(p) !== y) && s("UniqueItems", f);
    }
  }
  /**
   * Serialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param object - A valid Javascript object to be serialized
   *
   * @param objectName - Name of the serialized object
   *
   * @param options - additional options to serialization
   *
   * @returns A valid serialized Javascript object
   */
  serialize(e, r, n, s = { xml: {} }) {
    const i = {
      xml: {
        rootName: s.xml.rootName ?? "",
        includeRoot: s.xml.includeRoot ?? !1,
        xmlCharKey: s.xml.xmlCharKey ?? qs
      }
    };
    let o = {};
    const a = e.type.name;
    n || (n = e.serializedName), a.match(/^Sequence$/i) !== null && (o = []), e.isConstant && (r = e.defaultValue);
    const { required: A, nullable: c } = e;
    if (A && c && r === void 0)
      throw new Error(`${n} cannot be undefined.`);
    if (A && !c && r == null)
      throw new Error(`${n} cannot be null or undefined.`);
    if (!A && c === !1 && r === null)
      throw new Error(`${n} cannot be null.`);
    return r == null || a.match(/^any$/i) !== null ? o = r : a.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null ? o = Rb(a, n, r) : a.match(/^Enum$/i) !== null ? o = Sb(n, e.type.allowedValues, r) : a.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null ? o = Mb(a, r, n) : a.match(/^ByteArray$/i) !== null ? o = Db(n, r) : a.match(/^Base64Url$/i) !== null ? o = kb(n, r) : a.match(/^Sequence$/i) !== null ? o = Tb(this, e, r, n, !!this.isXML, i) : a.match(/^Dictionary$/i) !== null ? o = Fb(this, e, r, n, !!this.isXML, i) : a.match(/^Composite$/i) !== null && (o = Lb(this, e, r, n, !!this.isXML, i)), o;
  }
  /**
   * Deserialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param responseBody - A valid Javascript entity to be deserialized
   *
   * @param objectName - Name of the deserialized object
   *
   * @param options - Controls behavior of XML parser and builder.
   *
   * @returns A valid deserialized Javascript object
   */
  deserialize(e, r, n, s = { xml: {} }) {
    const i = {
      xml: {
        rootName: s.xml.rootName ?? "",
        includeRoot: s.xml.includeRoot ?? !1,
        xmlCharKey: s.xml.xmlCharKey ?? qs
      },
      ignoreUnknownProperties: s.ignoreUnknownProperties ?? !1
    };
    if (r == null)
      return this.isXML && e.type.name === "Sequence" && !e.xmlIsWrapped && (r = []), e.defaultValue !== void 0 && (r = e.defaultValue), r;
    let o;
    const a = e.type.name;
    if (n || (n = e.serializedName), a.match(/^Composite$/i) !== null)
      o = Pb(this, e, r, n, i);
    else {
      if (this.isXML) {
        const A = i.xml.xmlCharKey;
        r[Lt] !== void 0 && r[A] !== void 0 && (r = r[A]);
      }
      a.match(/^Number$/i) !== null ? (o = parseFloat(r), isNaN(o) && (o = r)) : a.match(/^Boolean$/i) !== null ? r === "true" ? o = !0 : r === "false" ? o = !1 : o = r : a.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null ? o = r : a.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null ? o = new Date(r) : a.match(/^UnixTime$/i) !== null ? o = xb(r) : a.match(/^ByteArray$/i) !== null ? o = up(r) : a.match(/^Base64Url$/i) !== null ? o = wb(r) : a.match(/^Sequence$/i) !== null ? o = Ob(this, e, r, n, i) : a.match(/^Dictionary$/i) !== null && (o = Hb(this, e, r, n, i));
    }
    return e.isConstant && (o = e.defaultValue), o;
  }
}
function ss(t = {}, e = !1) {
  return new yb(t, e);
}
function Qb(t, e) {
  let r = t.length;
  for (; r - 1 >= 0 && t[r - 1] === e; )
    --r;
  return t.substr(0, r);
}
function Nb(t) {
  if (!t)
    return;
  if (!(t instanceof Uint8Array))
    throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
  const e = dp(t);
  return Qb(e, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function wb(t) {
  if (t) {
    if (t && typeof t.valueOf() != "string")
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    return t = t.replace(/-/g, "+").replace(/_/g, "/"), up(t);
  }
}
function Xc(t) {
  const e = [];
  let r = "";
  if (t) {
    const n = t.split(".");
    for (const s of n)
      s.charAt(s.length - 1) === "\\" ? r += s.substr(0, s.length - 1) + "." : (r += s, e.push(r), r = "");
  }
  return e;
}
function bb(t) {
  if (t)
    return typeof t.valueOf() == "string" && (t = new Date(t)), Math.floor(t.getTime() / 1e3);
}
function xb(t) {
  if (t)
    return new Date(t * 1e3);
}
function Rb(t, e, r) {
  if (r != null) {
    if (t.match(/^Number$/i) !== null) {
      if (typeof r != "number")
        throw new Error(`${e} with value ${r} must be of type number.`);
    } else if (t.match(/^String$/i) !== null) {
      if (typeof r.valueOf() != "string")
        throw new Error(`${e} with value "${r}" must be of type string.`);
    } else if (t.match(/^Uuid$/i) !== null) {
      if (!(typeof r.valueOf() == "string" && Bb(r)))
        throw new Error(`${e} with value "${r}" must be of type string and a valid uuid.`);
    } else if (t.match(/^Boolean$/i) !== null) {
      if (typeof r != "boolean")
        throw new Error(`${e} with value ${r} must be of type boolean.`);
    } else if (t.match(/^Stream$/i) !== null) {
      const n = typeof r;
      if (n !== "string" && typeof r.pipe != "function" && // NodeJS.ReadableStream
      typeof r.tee != "function" && // browser ReadableStream
      !(r instanceof ArrayBuffer) && !ArrayBuffer.isView(r) && // File objects count as a type of Blob, so we want to use instanceof explicitly
      !((typeof Blob == "function" || typeof Blob == "object") && r instanceof Blob) && n !== "function")
        throw new Error(`${e} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
    }
  }
  return r;
}
function Sb(t, e, r) {
  if (!e)
    throw new Error(`Please provide a set of allowedValues to validate ${t} as an Enum Type.`);
  if (!e.some((s) => typeof s.valueOf() == "string" ? s.toLowerCase() === r.toLowerCase() : s === r))
    throw new Error(`${r} is not a valid value for ${t}. The valid values are: ${JSON.stringify(e)}.`);
  return r;
}
function Db(t, e) {
  if (e != null) {
    if (!(e instanceof Uint8Array))
      throw new Error(`${t} must be of type Uint8Array.`);
    e = dp(e);
  }
  return e;
}
function kb(t, e) {
  if (e != null) {
    if (!(e instanceof Uint8Array))
      throw new Error(`${t} must be of type Uint8Array.`);
    e = Nb(e);
  }
  return e;
}
function Mb(t, e, r) {
  if (e != null) {
    if (t.match(/^Date$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in ISO8601 format.`);
      e = e instanceof Date ? e.toISOString().substring(0, 10) : new Date(e).toISOString().substring(0, 10);
    } else if (t.match(/^DateTime$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in ISO8601 format.`);
      e = e instanceof Date ? e.toISOString() : new Date(e).toISOString();
    } else if (t.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in RFC-1123 format.`);
      e = e instanceof Date ? e.toUTCString() : new Date(e).toUTCString();
    } else if (t.match(/^UnixTime$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
      e = bb(e);
    } else if (t.match(/^TimeSpan$/i) !== null && !Eb(e))
      throw new Error(`${r} must be a string in ISO 8601 format. Instead was "${e}".`);
  }
  return e;
}
function Tb(t, e, r, n, s, i) {
  if (!Array.isArray(r))
    throw new Error(`${n} must be of type Array.`);
  let o = e.type.element;
  if (!o || typeof o != "object")
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}.`);
  o.type.name === "Composite" && o.type.className && (o = t.modelMappers[o.type.className] ?? o);
  const a = [];
  for (let A = 0; A < r.length; A++) {
    const c = t.serialize(o, r[A], n, i);
    if (s && o.xmlNamespace) {
      const l = o.xmlNamespacePrefix ? `xmlns:${o.xmlNamespacePrefix}` : "xmlns";
      o.type.name === "Composite" ? (a[A] = { ...c }, a[A][Lt] = { [l]: o.xmlNamespace }) : (a[A] = {}, a[A][i.xml.xmlCharKey] = c, a[A][Lt] = { [l]: o.xmlNamespace });
    } else
      a[A] = c;
  }
  return a;
}
function Fb(t, e, r, n, s, i) {
  if (typeof r != "object")
    throw new Error(`${n} must be of type object.`);
  const o = e.type.value;
  if (!o || typeof o != "object")
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}.`);
  const a = {};
  for (const A of Object.keys(r)) {
    const c = t.serialize(o, r[A], n, i);
    a[A] = gp(o, c, s, i);
  }
  if (s && e.xmlNamespace) {
    const A = e.xmlNamespacePrefix ? `xmlns:${e.xmlNamespacePrefix}` : "xmlns", c = a;
    return c[Lt] = { [A]: e.xmlNamespace }, c;
  }
  return a;
}
function vb(t, e, r) {
  const n = e.type.additionalProperties;
  return !n && e.type.className ? mp(t, e, r)?.type.additionalProperties : n;
}
function mp(t, e, r) {
  const n = e.type.className;
  if (!n)
    throw new Error(`Class name for model "${r}" is not provided in the mapper "${JSON.stringify(e, void 0, 2)}".`);
  return t.modelMappers[n];
}
function hp(t, e, r) {
  let n = e.type.modelProperties;
  if (!n) {
    const s = mp(t, e, r);
    if (!s)
      throw new Error(`mapper() cannot be null or undefined for model "${e.type.className}".`);
    if (n = s?.type.modelProperties, !n)
      throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(s)}" of type "${e.type.className}" for object "${r}".`);
  }
  return n;
}
function Lb(t, e, r, n, s, i) {
  if (Yi(t, e) && (e = fp(t, e, r, "clientName")), r != null) {
    const o = {}, a = hp(t, e, n);
    for (const c of Object.keys(a)) {
      const l = a[c];
      if (l.readOnly)
        continue;
      let d, u = o;
      if (t.isXML)
        l.xmlIsWrapped ? d = l.xmlName : d = l.xmlElementName || l.xmlName;
      else {
        const m = Xc(l.serializedName);
        d = m.pop();
        for (const h of m) {
          const f = u[h];
          f == null && (r[c] !== void 0 && r[c] !== null || l.defaultValue !== void 0) && (u[h] = {}), u = u[h];
        }
      }
      if (u != null) {
        if (s && e.xmlNamespace) {
          const y = e.xmlNamespacePrefix ? `xmlns:${e.xmlNamespacePrefix}` : "xmlns";
          u[Lt] = {
            ...u[Lt],
            [y]: e.xmlNamespace
          };
        }
        const m = l.serializedName !== "" ? n + "." + l.serializedName : n;
        let h = r[c];
        const f = Yi(t, e);
        f && f.clientName === c && h == null && (h = e.serializedName);
        const p = t.serialize(l, h, m, i);
        if (p !== void 0 && d !== void 0 && d !== null) {
          const y = gp(l, p, s, i);
          s && l.xmlIsAttribute ? (u[Lt] = u[Lt] || {}, u[Lt][d] = p) : s && l.xmlIsWrapped ? u[d] = { [l.xmlElementName]: y } : u[d] = y;
        }
      }
    }
    const A = vb(t, e, n);
    if (A) {
      const c = Object.keys(a);
      for (const l in r)
        c.every((u) => u !== l) && (o[l] = t.serialize(A, r[l], n + '["' + l + '"]', i));
    }
    return o;
  }
  return r;
}
function gp(t, e, r, n) {
  if (!r || !t.xmlNamespace)
    return e;
  const i = { [t.xmlNamespacePrefix ? `xmlns:${t.xmlNamespacePrefix}` : "xmlns"]: t.xmlNamespace };
  if (["Composite"].includes(t.type.name)) {
    if (e[Lt])
      return e;
    {
      const a = { ...e };
      return a[Lt] = i, a;
    }
  }
  const o = {};
  return o[n.xml.xmlCharKey] = e, o[Lt] = i, o;
}
function Ub(t, e) {
  return [Lt, e.xml.xmlCharKey].includes(t);
}
function Pb(t, e, r, n, s) {
  const i = s.xml.xmlCharKey ?? qs;
  Yi(t, e) && (e = fp(t, e, r, "serializedName"));
  const o = hp(t, e, n);
  let a = {};
  const A = [];
  for (const l of Object.keys(o)) {
    const d = o[l], u = Xc(o[l].serializedName);
    A.push(u[0]);
    const { serializedName: m, xmlName: h, xmlElementName: f } = d;
    let p = n;
    m !== "" && m !== void 0 && (p = n + "." + m);
    const y = d.headerCollectionPrefix;
    if (y) {
      const w = {};
      for (const R of Object.keys(r))
        R.startsWith(y) && (w[R.substring(y.length)] = t.deserialize(d.type.value, r[R], p, s)), A.push(R);
      a[l] = w;
    } else if (t.isXML)
      if (d.xmlIsAttribute && r[Lt])
        a[l] = t.deserialize(d, r[Lt][h], p, s);
      else if (d.xmlIsMsText)
        r[i] !== void 0 ? a[l] = r[i] : typeof r == "string" && (a[l] = r);
      else {
        const w = f || h || m;
        if (d.xmlIsWrapped) {
          const D = r[h]?.[f] ?? [];
          a[l] = t.deserialize(d, D, p, s), A.push(h);
        } else {
          const R = r[w];
          a[l] = t.deserialize(d, R, p, s), A.push(w);
        }
      }
    else {
      let w, R = r, D = 0;
      for (const I of u) {
        if (!R)
          break;
        D++, R = R[I];
      }
      R === null && D < u.length && (R = void 0), w = R;
      const L = e.type.polymorphicDiscriminator;
      L && l === L.clientName && w == null && (w = e.serializedName);
      let C;
      if (Array.isArray(r[l]) && o[l].serializedName === "") {
        w = r[l];
        const I = t.deserialize(d, w, p, s);
        for (const [x, g] of Object.entries(a))
          Object.prototype.hasOwnProperty.call(I, x) || (I[x] = g);
        a = I;
      } else (w !== void 0 || d.defaultValue !== void 0) && (C = t.deserialize(d, w, p, s), a[l] = C);
    }
  }
  const c = e.type.additionalProperties;
  if (c) {
    const l = (d) => {
      for (const u in o)
        if (Xc(o[u].serializedName)[0] === d)
          return !1;
      return !0;
    };
    for (const d in r)
      l(d) && (a[d] = t.deserialize(c, r[d], n + '["' + d + '"]', s));
  } else if (r && !s.ignoreUnknownProperties)
    for (const l of Object.keys(r))
      a[l] === void 0 && !A.includes(l) && !Ub(l, s) && (a[l] = r[l]);
  return a;
}
function Hb(t, e, r, n, s) {
  const i = e.type.value;
  if (!i || typeof i != "object")
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}`);
  if (r) {
    const o = {};
    for (const a of Object.keys(r))
      o[a] = t.deserialize(i, r[a], n, s);
    return o;
  }
  return r;
}
function Ob(t, e, r, n, s) {
  let i = e.type.element;
  if (!i || typeof i != "object")
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}`);
  if (r) {
    Array.isArray(r) || (r = [r]), i.type.name === "Composite" && i.type.className && (i = t.modelMappers[i.type.className] ?? i);
    const o = [];
    for (let a = 0; a < r.length; a++)
      o[a] = t.deserialize(i, r[a], `${n}[${a}]`, s);
    return o;
  }
  return r;
}
function zb(t, e, r) {
  const n = [r];
  for (; n.length; ) {
    const s = n.shift(), i = e === s ? e : s + "." + e;
    if (Object.prototype.hasOwnProperty.call(t, i))
      return t[i];
    for (const [o, a] of Object.entries(t))
      o.startsWith(s + ".") && a.type.uberParent === s && a.type.className && n.push(a.type.className);
  }
}
function fp(t, e, r, n) {
  const s = Yi(t, e);
  if (s) {
    let i = s[n];
    if (i) {
      n === "serializedName" && (i = i.replace(/\\/gi, ""));
      const o = r[i], a = e.type.uberParent ?? e.type.className;
      if (typeof o == "string" && a) {
        const A = zb(t.modelMappers.discriminators, o, a);
        A && (e = A);
      }
    }
  }
  return e;
}
function Yi(t, e) {
  return e.type.polymorphicDiscriminator || ng(t, e.type.uberParent) || ng(t, e.type.className);
}
function ng(t, e) {
  return e && t.modelMappers[e] && t.modelMappers[e].type.polymorphicDiscriminator;
}
const Jn = {
  Base64Url: "Base64Url",
  Boolean: "Boolean",
  ByteArray: "ByteArray",
  Composite: "Composite",
  Date: "Date",
  DateTime: "DateTime",
  DateTimeRfc1123: "DateTimeRfc1123",
  Dictionary: "Dictionary",
  Enum: "Enum",
  Number: "Number",
  Object: "Object",
  Sequence: "Sequence",
  String: "String",
  Stream: "Stream",
  TimeSpan: "TimeSpan",
  UnixTime: "UnixTime"
};
var xs = {}, sg;
function qb() {
  return sg || (sg = 1, Object.defineProperty(xs, "__esModule", { value: !0 }), xs.state = void 0, xs.state = {
    operationRequestMap: /* @__PURE__ */ new WeakMap()
  }), xs;
}
var Gb = qb();
const ig = Gb.state;
function _n(t, e, r) {
  let n = e.parameterPath;
  const s = e.mapper;
  let i;
  if (typeof n == "string" && (n = [n]), Array.isArray(n)) {
    if (n.length > 0)
      if (s.isConstant)
        i = s.defaultValue;
      else {
        let o = og(t, n);
        !o.propertyFound && r && (o = og(r, n));
        let a = !1;
        o.propertyFound || (a = s.required || n[0] === "options" && n.length === 2), i = a ? s.defaultValue : o.propertyValue;
      }
  } else {
    s.required && (i = {});
    for (const o in n) {
      const a = s.type.modelProperties[o], A = n[o], c = _n(t, {
        parameterPath: A,
        mapper: a
      }, r);
      c !== void 0 && (i || (i = {}), i[o] = c);
    }
  }
  return i;
}
function og(t, e) {
  const r = { propertyFound: !1 };
  let n = 0;
  for (; n < e.length; ++n) {
    const s = e[n];
    if (t && s in t)
      t = t[s];
    else
      break;
  }
  return n === e.length && (r.propertyValue = t, r.propertyFound = !0), r;
}
const pp = /* @__PURE__ */ Symbol.for("@azure/core-client original request");
function Yb(t) {
  return pp in t;
}
function is(t) {
  if (Yb(t))
    return is(t[pp]);
  let e = ig.operationRequestMap.get(t);
  return e || (e = {}, ig.operationRequestMap.set(t, e)), e;
}
const Jb = ["application/json", "text/json"], Vb = ["application/xml", "application/atom+xml"], _b = "deserializationPolicy";
function Wb(t = {}) {
  const e = t.expectedContentTypes?.json ?? Jb, r = t.expectedContentTypes?.xml ?? Vb, n = t.parseXML, s = t.serializerOptions, i = {
    xml: {
      rootName: s?.xml.rootName ?? "",
      includeRoot: s?.xml.includeRoot ?? !1,
      xmlCharKey: s?.xml.xmlCharKey ?? qs
    }
  };
  return {
    name: _b,
    async sendRequest(o, a) {
      const A = await a(o);
      return Zb(e, r, A, i, n);
    }
  };
}
function $b(t) {
  let e;
  const r = t.request, n = is(r), s = n?.operationSpec;
  return s && (n?.operationResponseGetter ? e = n?.operationResponseGetter(s, t) : e = s.responses[t.status]), e;
}
function Xb(t) {
  const e = t.request, n = is(e)?.shouldDeserialize;
  let s;
  return n === void 0 ? s = !0 : typeof n == "boolean" ? s = n : s = n(t), s;
}
async function Zb(t, e, r, n, s) {
  const i = await ex(t, e, r, n, s);
  if (!Xb(i))
    return i;
  const a = is(i.request)?.operationSpec;
  if (!a || !a.responses)
    return i;
  const A = $b(i), { error: c, shouldReturnResponse: l } = jb(i, a, A, n);
  if (c)
    throw c;
  if (l)
    return i;
  if (A) {
    if (A.bodyMapper) {
      let d = i.parsedBody;
      a.isXML && A.bodyMapper.type.name === Jn.Sequence && (d = typeof d == "object" ? d[A.bodyMapper.xmlElementName] : []);
      try {
        i.parsedBody = a.serializer.deserialize(A.bodyMapper, d, "operationRes.parsedBody", n);
      } catch (u) {
        throw new zs(`Error ${u} occurred in deserializing the responseBody - ${i.bodyAsText}`, {
          statusCode: i.status,
          request: i.request,
          response: i
        });
      }
    } else a.httpMethod === "HEAD" && (i.parsedBody = r.status >= 200 && r.status < 300);
    A.headersMapper && (i.parsedHeaders = a.serializer.deserialize(A.headersMapper, i.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: !0 }));
  }
  return i;
}
function Kb(t) {
  const e = Object.keys(t.responses);
  return e.length === 0 || e.length === 1 && e[0] === "default";
}
function jb(t, e, r, n) {
  const s = 200 <= t.status && t.status < 300;
  if (Kb(e) ? s : !!r)
    if (r) {
      if (!r.isError)
        return { error: null, shouldReturnResponse: !1 };
    } else
      return { error: null, shouldReturnResponse: !1 };
  const o = r ?? e.responses.default, a = t.request.streamResponseStatusCodes?.has(t.status) ? `Unexpected status code: ${t.status}` : t.bodyAsText, A = new zs(a, {
    statusCode: t.status,
    request: t.request,
    response: t
  });
  if (!o && !(t.parsedBody?.error?.code && t.parsedBody?.error?.message))
    throw A;
  const c = o?.bodyMapper, l = o?.headersMapper;
  try {
    if (t.parsedBody) {
      const d = t.parsedBody;
      let u;
      if (c) {
        let h = d;
        if (e.isXML && c.type.name === Jn.Sequence) {
          h = [];
          const f = c.xmlElementName;
          typeof d == "object" && f && (h = d[f]);
        }
        u = e.serializer.deserialize(c, h, "error.response.parsedBody", n);
      }
      const m = d.error || u || d;
      A.code = m.code, m.message && (A.message = m.message), c && (A.response.parsedBody = u);
    }
    t.headers && l && (A.response.parsedHeaders = e.serializer.deserialize(l, t.headers.toJSON(), "operationRes.parsedHeaders"));
  } catch (d) {
    A.message = `Error "${d.message}" occurred in deserializing the responseBody - "${t.bodyAsText}" for the default response.`;
  }
  return { error: A, shouldReturnResponse: !1 };
}
async function ex(t, e, r, n, s) {
  if (!r.request.streamResponseStatusCodes?.has(r.status) && r.bodyAsText) {
    const i = r.bodyAsText, o = r.headers.get("Content-Type") || "", a = o ? o.split(";").map((A) => A.toLowerCase()) : [];
    try {
      if (a.length === 0 || a.some((A) => t.indexOf(A) !== -1))
        return r.parsedBody = JSON.parse(i), r;
      if (a.some((A) => e.indexOf(A) !== -1)) {
        if (!s)
          throw new Error("Parsing XML not supported.");
        const A = await s(i, n.xml);
        return r.parsedBody = A, r;
      }
    } catch (A) {
      const c = `Error "${A}" occurred while parsing the response body - ${r.bodyAsText}.`, l = A.code || zs.PARSE_ERROR;
      throw new zs(c, {
        code: l,
        statusCode: r.status,
        request: r.request,
        response: r
      });
    }
  }
  return r;
}
function tx(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r in t.responses) {
    const n = t.responses[r];
    n.bodyMapper && n.bodyMapper.type.name === Jn.Stream && e.add(Number(r));
  }
  return e;
}
function $r(t) {
  const { parameterPath: e, mapper: r } = t;
  let n;
  return typeof e == "string" ? n = e : Array.isArray(e) ? n = e.join(".") : n = r.serializedName, n;
}
const rx = "serializationPolicy";
function nx(t = {}) {
  const e = t.stringifyXML;
  return {
    name: rx,
    async sendRequest(r, n) {
      const s = is(r), i = s?.operationSpec, o = s?.operationArguments;
      return i && o && (sx(r, o, i), ix(r, o, i, e)), n(r);
    }
  };
}
function sx(t, e, r) {
  if (r.headerParameters)
    for (const s of r.headerParameters) {
      let i = _n(e, s);
      if (i != null || s.mapper.required) {
        i = r.serializer.serialize(s.mapper, i, $r(s));
        const o = s.mapper.headerCollectionPrefix;
        if (o)
          for (const a of Object.keys(i))
            t.headers.set(o + a, i[a]);
        else
          t.headers.set(s.mapper.serializedName || $r(s), i);
      }
    }
  const n = e.options?.requestOptions?.customHeaders;
  if (n)
    for (const s of Object.keys(n))
      t.headers.set(s, n[s]);
}
function ix(t, e, r, n = function() {
  throw new Error("XML serialization unsupported!");
}) {
  const s = e.options?.serializerOptions, i = {
    xml: {
      rootName: s?.xml.rootName ?? "",
      includeRoot: s?.xml.includeRoot ?? !1,
      xmlCharKey: s?.xml.xmlCharKey ?? qs
    }
  }, o = i.xml.xmlCharKey;
  if (r.requestBody && r.requestBody.mapper) {
    t.body = _n(e, r.requestBody);
    const a = r.requestBody.mapper, { required: A, serializedName: c, xmlName: l, xmlElementName: d, xmlNamespace: u, xmlNamespacePrefix: m, nullable: h } = a, f = a.type.name;
    try {
      if (t.body !== void 0 && t.body !== null || h && t.body === null || A) {
        const p = $r(r.requestBody);
        t.body = r.serializer.serialize(a, t.body, p, i);
        const y = f === Jn.Stream;
        if (r.isXML) {
          const w = m ? `xmlns:${m}` : "xmlns", R = ox(u, w, f, t.body, i);
          f === Jn.Sequence ? t.body = n(ax(R, d || l || c, w, u), { rootName: l || c, xmlCharKey: o }) : y || (t.body = n(R, {
            rootName: l || c,
            xmlCharKey: o
          }));
        } else {
          if (f === Jn.String && (r.contentType?.match("text/plain") || r.mediaType === "text"))
            return;
          y || (t.body = JSON.stringify(t.body));
        }
      }
    } catch (p) {
      throw new Error(`Error "${p.message}" occurred in serializing the payload - ${JSON.stringify(c, void 0, "  ")}.`);
    }
  } else if (r.formDataParameters && r.formDataParameters.length > 0) {
    t.formData = {};
    for (const a of r.formDataParameters) {
      const A = _n(e, a);
      if (A != null) {
        const c = a.mapper.serializedName || $r(a);
        t.formData[c] = r.serializer.serialize(a.mapper, A, $r(a), i);
      }
    }
  }
}
function ox(t, e, r, n, s) {
  if (t && !["Composite", "Sequence", "Dictionary"].includes(r)) {
    const i = {};
    return i[s.xml.xmlCharKey] = n, i[Lt] = { [e]: t }, i;
  }
  return n;
}
function ax(t, e, r, n) {
  if (Array.isArray(t) || (t = [t]), !r || !n)
    return { [e]: t };
  const s = { [e]: t };
  return s[Lt] = { [r]: n }, s;
}
function Ep(t = {}) {
  const e = ab(t ?? {});
  return t.credentialOptions && e.addPolicy(cp({
    credential: t.credentialOptions.credential,
    scopes: t.credentialOptions.credentialScopes
  })), e.addPolicy(nx(t.serializationOptions), { phase: "Serialize" }), e.addPolicy(Wb(t.deserializationOptions), {
    phase: "Deserialize"
  }), e;
}
let Dc;
function Ax() {
  return Dc || (Dc = op()), Dc;
}
const cx = {
  CSV: ",",
  SSV: " ",
  Multi: "Multi",
  TSV: "	",
  Pipes: "|"
};
function lx(t, e, r, n) {
  const s = dx(e, r, n);
  let i = !1, o = ag(t, s);
  if (e.path) {
    let c = ag(e.path, s);
    e.path === "/{nextLink}" && c.startsWith("/") && (c = c.substring(1)), ux(c) ? (o = c, i = !0) : o = mx(o, c);
  }
  const { queryParams: a, sequenceParams: A } = hx(e, r, n);
  return o = fx(o, a, A, i), o;
}
function ag(t, e) {
  let r = t;
  for (const [n, s] of e)
    r = r.split(n).join(s);
  return r;
}
function dx(t, e, r) {
  const n = /* @__PURE__ */ new Map();
  if (t.urlParameters?.length)
    for (const s of t.urlParameters) {
      let i = _n(e, s, r);
      const o = $r(s);
      i = t.serializer.serialize(s.mapper, i, o), s.skipEncoding || (i = encodeURIComponent(i)), n.set(`{${s.mapper.serializedName || o}}`, i);
    }
  return n;
}
function ux(t) {
  return t.includes("://");
}
function mx(t, e) {
  if (!e)
    return t;
  const r = new URL(t);
  let n = r.pathname;
  n.endsWith("/") || (n = `${n}/`), e.startsWith("/") && (e = e.substring(1));
  const s = e.indexOf("?");
  if (s !== -1) {
    const i = e.substring(0, s), o = e.substring(s + 1);
    n = n + i, o && (r.search = r.search ? `${r.search}&${o}` : o);
  } else
    n = n + e;
  return r.pathname = n, r.toString();
}
function hx(t, e, r) {
  const n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set();
  if (t.queryParameters?.length)
    for (const i of t.queryParameters) {
      i.mapper.type.name === "Sequence" && i.mapper.serializedName && s.add(i.mapper.serializedName);
      let o = _n(e, i, r);
      if (o != null || i.mapper.required) {
        o = t.serializer.serialize(i.mapper, o, $r(i));
        const a = i.collectionFormat ? cx[i.collectionFormat] : "";
        if (Array.isArray(o) && (o = o.map((A) => A ?? "")), i.collectionFormat === "Multi" && o.length === 0)
          continue;
        Array.isArray(o) && (i.collectionFormat === "SSV" || i.collectionFormat === "TSV") && (o = o.join(a)), i.skipEncoding || (Array.isArray(o) ? o = o.map((A) => encodeURIComponent(A)) : o = encodeURIComponent(o)), Array.isArray(o) && (i.collectionFormat === "CSV" || i.collectionFormat === "Pipes") && (o = o.join(a)), n.set(i.mapper.serializedName || $r(i), o);
      }
    }
  return {
    queryParams: n,
    sequenceParams: s
  };
}
function gx(t) {
  const e = /* @__PURE__ */ new Map();
  if (!t || t[0] !== "?")
    return e;
  t = t.slice(1);
  const r = t.split("&");
  for (const n of r) {
    const [s, i] = n.split("=", 2), o = e.get(s);
    o ? Array.isArray(o) ? o.push(i) : e.set(s, [o, i]) : e.set(s, i);
  }
  return e;
}
function fx(t, e, r, n = !1) {
  if (e.size === 0)
    return t;
  const s = new URL(t), i = gx(s.search);
  for (const [a, A] of e) {
    const c = i.get(a);
    if (Array.isArray(c))
      if (Array.isArray(A)) {
        c.push(...A);
        const l = new Set(c);
        i.set(a, Array.from(l));
      } else
        c.push(A);
    else c ? (Array.isArray(A) ? A.unshift(c) : r.has(a) && i.set(a, [c, A]), n || i.set(a, A)) : i.set(a, A);
  }
  const o = [];
  for (const [a, A] of i)
    if (typeof A == "string")
      o.push(`${a}=${A}`);
    else if (Array.isArray(A))
      for (const c of A)
        o.push(`${a}=${c}`);
    else
      o.push(`${a}=${A}`);
  return s.search = o.length ? `?${o.join("&")}` : "", s.toString();
}
const px = Co("core-client");
class Ex {
  /**
   * If specified, this is the base URI that requests will be made against for this ServiceClient.
   * If it is not specified, then all OperationSpecs must contain a baseUrl property.
   */
  _endpoint;
  /**
   * The default request content type for the service.
   * Used if no requestContentType is present on an OperationSpec.
   */
  _requestContentType;
  /**
   * Set to true if the request is sent over HTTP instead of HTTPS
   */
  _allowInsecureConnection;
  /**
   * The HTTP client that will be used to send requests.
   */
  _httpClient;
  /**
   * The pipeline used by this client to make requests
   */
  pipeline;
  /**
   * The ServiceClient constructor
   * @param options - The service client options that govern the behavior of the client.
   */
  constructor(e = {}) {
    if (this._requestContentType = e.requestContentType, this._endpoint = e.endpoint ?? e.baseUri, e.baseUri && px.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead."), this._allowInsecureConnection = e.allowInsecureConnection, this._httpClient = e.httpClient || Ax(), this.pipeline = e.pipeline || Cx(e), e.additionalPolicies?.length)
      for (const { policy: r, position: n } of e.additionalPolicies) {
        const s = n === "perRetry" ? "Sign" : void 0;
        this.pipeline.addPolicy(r, {
          afterPhase: s
        });
      }
  }
  /**
   * Send the provided httpRequest.
   */
  async sendRequest(e) {
    return this.pipeline.sendRequest(this._httpClient, e);
  }
  /**
   * Send an HTTP request that is populated using the provided OperationSpec.
   * @typeParam T - The typed result of the request, based on the OperationSpec.
   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
   * @param operationSpec - The OperationSpec to use to populate the httpRequest.
   */
  async sendOperationRequest(e, r) {
    const n = r.baseUrl || this._endpoint;
    if (!n)
      throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
    const s = lx(n, r, e, this), i = Ap({
      url: s
    });
    i.method = r.httpMethod;
    const o = is(i);
    o.operationSpec = r, o.operationArguments = e;
    const a = r.contentType || this._requestContentType;
    a && r.requestBody && i.headers.set("Content-Type", a);
    const A = e.options;
    if (A) {
      const c = A.requestOptions;
      c && (c.timeout && (i.timeout = c.timeout), c.onUploadProgress && (i.onUploadProgress = c.onUploadProgress), c.onDownloadProgress && (i.onDownloadProgress = c.onDownloadProgress), c.shouldDeserialize !== void 0 && (o.shouldDeserialize = c.shouldDeserialize), c.allowInsecureConnection && (i.allowInsecureConnection = !0)), A.abortSignal && (i.abortSignal = A.abortSignal), A.tracingOptions && (i.tracingOptions = A.tracingOptions);
    }
    this._allowInsecureConnection && (i.allowInsecureConnection = !0), i.streamResponseStatusCodes === void 0 && (i.streamResponseStatusCodes = tx(r));
    try {
      const c = await this.sendRequest(i), l = rg(c, r.responses[c.status]);
      return A?.onResponse && A.onResponse(c, l), l;
    } catch (c) {
      if (typeof c == "object" && c?.response) {
        const l = c.response, d = rg(l, r.responses[c.statusCode] || r.responses.default);
        c.details = d, A?.onResponse && A.onResponse(l, d, c);
      }
      throw c;
    }
  }
}
function Cx(t) {
  const e = Bx(t), r = t.credential && e ? { credentialScopes: e, credential: t.credential } : void 0;
  return Ep({
    ...t,
    credentialOptions: r
  });
}
function Bx(t) {
  if (t.credentialScopes)
    return t.credentialScopes;
  if (t.endpoint)
    return `${t.endpoint}/.default`;
  if (t.baseUri)
    return `${t.baseUri}/.default`;
  if (t.credential && !t.credentialScopes)
    throw new Error("When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy");
}
const Cp = {
  DefaultScope: "/.default",
  /**
   * Defines constants for use with HTTP headers.
   */
  HeaderConstants: {
    /**
     * The Authorization header.
     */
    AUTHORIZATION: "authorization"
  }
};
function Ix(t) {
  return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(t);
}
const yx = async (t) => {
  const e = xx(t.request), r = wx(t.response);
  if (r) {
    const n = bx(r), s = Nx(t, n), i = Qx(n);
    if (!i)
      return !1;
    const o = await t.getAccessToken(s, {
      ...e,
      tenantId: i
    });
    return o ? (t.request.headers.set(Cp.HeaderConstants.AUTHORIZATION, `${o.tokenType ?? "Bearer"} ${o.token}`), !0) : !1;
  }
  return !1;
};
function Qx(t) {
  const n = new URL(t.authorization_uri).pathname.split("/")[1];
  if (n && Ix(n))
    return n;
}
function Nx(t, e) {
  if (!e.resource_id)
    return t.scopes;
  const r = new URL(e.resource_id);
  r.pathname = Cp.DefaultScope;
  let n = r.toString();
  return n === "https://disk.azure.com/.default" && (n = "https://disk.azure.com//.default"), [n];
}
function wx(t) {
  const e = t.headers.get("WWW-Authenticate");
  if (t.status === 401 && e)
    return e;
}
function bx(t) {
  return `${t.slice(7).trim()} `.split(" ").filter((s) => s).map((s) => (([i, o]) => ({ [i]: o }))(s.trim().split("="))).reduce((s, i) => ({ ...s, ...i }), {});
}
function xx(t) {
  return {
    abortSignal: t.abortSignal,
    requestOptions: {
      timeout: t.timeout
    },
    tracingOptions: t.tracingOptions
  };
}
const Bp = /* @__PURE__ */ Symbol("Original PipelineRequest"), Rx = /* @__PURE__ */ Symbol.for("@azure/core-client original request");
function Vl(t, e = {}) {
  const n = t[Bp], s = ap(t.headers.toJson({ preserveCase: !0 }));
  if (n)
    return n.headers = s, n;
  {
    const i = Ap({
      url: t.url,
      method: t.method,
      headers: s,
      withCredentials: t.withCredentials,
      timeout: t.timeout,
      requestId: t.requestId,
      abortSignal: t.abortSignal,
      body: t.body,
      formData: t.formData,
      disableKeepAlive: !!t.keepAlive,
      onDownloadProgress: t.onDownloadProgress,
      onUploadProgress: t.onUploadProgress,
      proxySettings: t.proxySettings,
      streamResponseStatusCodes: t.streamResponseStatusCodes,
      agent: t.agent,
      requestOverrides: t.requestOverrides
    });
    return e.originalRequest && (i[Rx] = e.originalRequest), i;
  }
}
function Io(t, e) {
  const r = e?.originalRequest ?? t, n = {
    url: t.url,
    method: t.method,
    headers: Ip(t.headers),
    withCredentials: t.withCredentials,
    timeout: t.timeout,
    requestId: t.headers.get("x-ms-client-request-id") || t.requestId,
    abortSignal: t.abortSignal,
    body: t.body,
    formData: t.formData,
    keepAlive: !!t.disableKeepAlive,
    onDownloadProgress: t.onDownloadProgress,
    onUploadProgress: t.onUploadProgress,
    proxySettings: t.proxySettings,
    streamResponseStatusCodes: t.streamResponseStatusCodes,
    agent: t.agent,
    requestOverrides: t.requestOverrides,
    clone() {
      throw new Error("Cannot clone a non-proxied WebResourceLike");
    },
    prepare() {
      throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
    },
    validateRequestProperties() {
    }
  };
  return e?.createProxy ? new Proxy(n, {
    get(s, i, o) {
      return i === Bp ? t : i === "clone" ? () => Io(Vl(n, { originalRequest: r }), {
        createProxy: !0,
        originalRequest: r
      }) : Reflect.get(s, i, o);
    },
    set(s, i, o, a) {
      return i === "keepAlive" && (t.disableKeepAlive = !o), typeof i == "string" && [
        "url",
        "method",
        "withCredentials",
        "timeout",
        "requestId",
        "abortSignal",
        "body",
        "formData",
        "onDownloadProgress",
        "onUploadProgress",
        "proxySettings",
        "streamResponseStatusCodes",
        "agent",
        "requestOverrides"
      ].includes(i) && (t[i] = o), Reflect.set(s, i, o, a);
    }
  }) : n;
}
function Ip(t) {
  return new _l(t.toJSON({ preserveCase: !0 }));
}
function Rs(t) {
  return t.toLowerCase();
}
class _l {
  _headersMap;
  constructor(e) {
    if (this._headersMap = {}, e)
      for (const r in e)
        this.set(r, e[r]);
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param headerName - The name of the header to set. This value is case-insensitive.
   * @param headerValue - The value of the header to set.
   */
  set(e, r) {
    this._headersMap[Rs(e)] = {
      name: e,
      value: r.toString()
    };
  }
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param headerName - The name of the header.
   */
  get(e) {
    const r = this._headersMap[Rs(e)];
    return r ? r.value : void 0;
  }
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   */
  contains(e) {
    return !!this._headersMap[Rs(e)];
  }
  /**
   * Remove the header with the provided headerName. Return whether or not the header existed and
   * was removed.
   * @param headerName - The name of the header to remove.
   */
  remove(e) {
    const r = this.contains(e);
    return delete this._headersMap[Rs(e)], r;
  }
  /**
   * Get the headers that are contained this collection as an object.
   */
  rawHeaders() {
    return this.toJson({ preserveCase: !0 });
  }
  /**
   * Get the headers that are contained in this collection as an array.
   */
  headersArray() {
    const e = [];
    for (const r in this._headersMap)
      e.push(this._headersMap[r]);
    return e;
  }
  /**
   * Get the header names that are contained in this collection.
   */
  headerNames() {
    const e = [], r = this.headersArray();
    for (let n = 0; n < r.length; ++n)
      e.push(r[n].name);
    return e;
  }
  /**
   * Get the header values that are contained in this collection.
   */
  headerValues() {
    const e = [], r = this.headersArray();
    for (let n = 0; n < r.length; ++n)
      e.push(r[n].value);
    return e;
  }
  /**
   * Get the JSON object representation of this HTTP header collection.
   */
  toJson(e = {}) {
    const r = {};
    if (e.preserveCase)
      for (const n in this._headersMap) {
        const s = this._headersMap[n];
        r[s.name] = s.value;
      }
    else
      for (const n in this._headersMap) {
        const s = this._headersMap[n];
        r[Rs(s.name)] = s.value;
      }
    return r;
  }
  /**
   * Get the string representation of this HTTP header collection.
   */
  toString() {
    return JSON.stringify(this.toJson({ preserveCase: !0 }));
  }
  /**
   * Create a deep clone/copy of this HttpHeaders collection.
   */
  clone() {
    const e = {};
    for (const r in this._headersMap) {
      const n = this._headersMap[r];
      e[n.name] = n.value;
    }
    return new _l(e);
  }
}
const yp = /* @__PURE__ */ Symbol("Original FullOperationResponse");
function Qp(t, e) {
  let r = Io(t.request), n = Ip(t.headers);
  return e?.createProxy ? new Proxy(t, {
    get(s, i, o) {
      return i === "headers" ? n : i === "request" ? r : i === yp ? t : Reflect.get(s, i, o);
    },
    set(s, i, o, a) {
      return i === "headers" ? n = o : i === "request" && (r = o), Reflect.set(s, i, o, a);
    }
  }) : {
    ...t,
    request: r,
    headers: n
  };
}
function Np(t) {
  const r = t[yp], n = ap(t.headers.toJson({ preserveCase: !0 }));
  return r ? (r.headers = n, r) : {
    ...t,
    headers: n,
    request: Vl(t.request)
  };
}
class Sx extends Ex {
  constructor(e) {
    super(e), e.keepAliveOptions?.enable === !1 && !gb(this.pipeline) && this.pipeline.addPolicy(hb()), e.redirectOptions?.handleRedirects === !1 && this.pipeline.removePolicy({
      name: b0
    });
  }
  /**
   * Compatible send operation request function.
   *
   * @param operationArguments - Operation arguments
   * @param operationSpec - Operation Spec
   * @returns
   */
  async sendOperationRequest(e, r) {
    const n = e?.options?.onResponse;
    let s;
    function i(a, A, c) {
      s = a, n && n(a, A, c);
    }
    e.options = {
      ...e.options,
      onResponse: i
    };
    const o = await super.sendOperationRequest(e, r);
    return s && Object.defineProperty(o, "_response", {
      value: Qp(s)
    }), o;
  }
}
var Ag;
(function(t) {
  t[t.ERROR = 1] = "ERROR", t[t.INFO = 3] = "INFO", t[t.OFF = 0] = "OFF", t[t.WARNING = 2] = "WARNING";
})(Ag || (Ag = {}));
const Dx = {
  log(t, e) {
  },
  shouldLog(t) {
    return !1;
  }
}, kx = "RequestPolicyFactoryPolicy";
function Mx(t) {
  const e = t.slice().reverse();
  return {
    name: kx,
    async sendRequest(r, n) {
      let s = {
        async sendRequest(a) {
          const A = await n(Vl(a));
          return Qp(A, { createProxy: !0 });
        }
      };
      for (const a of e)
        s = a.create(s, Dx);
      const i = Io(r, { createProxy: !0 }), o = await s.sendRequest(i);
      return Np(o);
    }
  };
}
function Tx(t) {
  return {
    sendRequest: async (e) => {
      const r = await t.sendRequest(Io(e, { createProxy: !0 }));
      return Np(r);
    }
  };
}
const wp = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Fx = wp + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", vx = "[" + wp + "][" + Fx + "]*", Lx = new RegExp("^" + vx + "$");
function bp(t, e) {
  const r = [];
  let n = e.exec(t);
  for (; n; ) {
    const s = [];
    s.startIndex = e.lastIndex - n[0].length;
    const i = n.length;
    for (let o = 0; o < i; o++)
      s.push(n[o]);
    r.push(s), n = e.exec(t);
  }
  return r;
}
const yo = function(t) {
  const e = Lx.exec(t);
  return !(e === null || typeof e > "u");
};
function Ux(t) {
  return typeof t < "u";
}
const Px = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
function xp(t, e) {
  e = Object.assign({}, Px, e);
  const r = [];
  let n = !1, s = !1;
  t[0] === "\uFEFF" && (t = t.substr(1));
  for (let i = 0; i < t.length; i++)
    if (t[i] === "<" && t[i + 1] === "?") {
      if (i += 2, i = lg(t, i), i.err) return i;
    } else if (t[i] === "<") {
      let o = i;
      if (i++, t[i] === "!") {
        i = dg(t, i);
        continue;
      } else {
        let a = !1;
        t[i] === "/" && (a = !0, i++);
        let A = "";
        for (; i < t.length && t[i] !== ">" && t[i] !== " " && t[i] !== "	" && t[i] !== `
` && t[i] !== "\r"; i++)
          A += t[i];
        if (A = A.trim(), A[A.length - 1] === "/" && (A = A.substring(0, A.length - 1), i--), !Vx(A)) {
          let d;
          return A.trim().length === 0 ? d = "Invalid space after '<'." : d = "Tag '" + A + "' is an invalid name.", Et("InvalidTag", d, Yt(t, i));
        }
        const c = zx(t, i);
        if (c === !1)
          return Et("InvalidAttr", "Attributes for '" + A + "' have open quote.", Yt(t, i));
        let l = c.value;
        if (i = c.index, l[l.length - 1] === "/") {
          const d = i - l.length;
          l = l.substring(0, l.length - 1);
          const u = ug(l, e);
          if (u === !0)
            n = !0;
          else
            return Et(u.err.code, u.err.msg, Yt(t, d + u.err.line));
        } else if (a)
          if (c.tagClosed) {
            if (l.trim().length > 0)
              return Et("InvalidTag", "Closing tag '" + A + "' can't have attributes or invalid starting.", Yt(t, o));
            if (r.length === 0)
              return Et("InvalidTag", "Closing tag '" + A + "' has not been opened.", Yt(t, o));
            {
              const d = r.pop();
              if (A !== d.tagName) {
                let u = Yt(t, d.tagStartPos);
                return Et(
                  "InvalidTag",
                  "Expected closing tag '" + d.tagName + "' (opened in line " + u.line + ", col " + u.col + ") instead of closing tag '" + A + "'.",
                  Yt(t, o)
                );
              }
              r.length == 0 && (s = !0);
            }
          } else return Et("InvalidTag", "Closing tag '" + A + "' doesn't have proper closing.", Yt(t, i));
        else {
          const d = ug(l, e);
          if (d !== !0)
            return Et(d.err.code, d.err.msg, Yt(t, i - l.length + d.err.line));
          if (s === !0)
            return Et("InvalidXml", "Multiple possible root nodes found.", Yt(t, i));
          e.unpairedTags.indexOf(A) !== -1 || r.push({ tagName: A, tagStartPos: o }), n = !0;
        }
        for (i++; i < t.length; i++)
          if (t[i] === "<")
            if (t[i + 1] === "!") {
              i++, i = dg(t, i);
              continue;
            } else if (t[i + 1] === "?") {
              if (i = lg(t, ++i), i.err) return i;
            } else
              break;
          else if (t[i] === "&") {
            const d = Yx(t, i);
            if (d == -1)
              return Et("InvalidChar", "char '&' is not expected.", Yt(t, i));
            i = d;
          } else if (s === !0 && !cg(t[i]))
            return Et("InvalidXml", "Extra text at the end", Yt(t, i));
        t[i] === "<" && i--;
      }
    } else {
      if (cg(t[i]))
        continue;
      return Et("InvalidChar", "char '" + t[i] + "' is not expected.", Yt(t, i));
    }
  if (n) {
    if (r.length == 1)
      return Et("InvalidTag", "Unclosed tag '" + r[0].tagName + "'.", Yt(t, r[0].tagStartPos));
    if (r.length > 0)
      return Et("InvalidXml", "Invalid '" + JSON.stringify(r.map((i) => i.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else return Et("InvalidXml", "Start tag expected.", 1);
  return !0;
}
function cg(t) {
  return t === " " || t === "	" || t === `
` || t === "\r";
}
function lg(t, e) {
  const r = e;
  for (; e < t.length; e++)
    if (t[e] == "?" || t[e] == " ") {
      const n = t.substr(r, e - r);
      if (e > 5 && n === "xml")
        return Et("InvalidXml", "XML declaration allowed only at the start of the document.", Yt(t, e));
      if (t[e] == "?" && t[e + 1] == ">") {
        e++;
        break;
      } else
        continue;
    }
  return e;
}
function dg(t, e) {
  if (t.length > e + 5 && t[e + 1] === "-" && t[e + 2] === "-") {
    for (e += 3; e < t.length; e++)
      if (t[e] === "-" && t[e + 1] === "-" && t[e + 2] === ">") {
        e += 2;
        break;
      }
  } else if (t.length > e + 8 && t[e + 1] === "D" && t[e + 2] === "O" && t[e + 3] === "C" && t[e + 4] === "T" && t[e + 5] === "Y" && t[e + 6] === "P" && t[e + 7] === "E") {
    let r = 1;
    for (e += 8; e < t.length; e++)
      if (t[e] === "<")
        r++;
      else if (t[e] === ">" && (r--, r === 0))
        break;
  } else if (t.length > e + 9 && t[e + 1] === "[" && t[e + 2] === "C" && t[e + 3] === "D" && t[e + 4] === "A" && t[e + 5] === "T" && t[e + 6] === "A" && t[e + 7] === "[") {
    for (e += 8; e < t.length; e++)
      if (t[e] === "]" && t[e + 1] === "]" && t[e + 2] === ">") {
        e += 2;
        break;
      }
  }
  return e;
}
const Hx = '"', Ox = "'";
function zx(t, e) {
  let r = "", n = "", s = !1;
  for (; e < t.length; e++) {
    if (t[e] === Hx || t[e] === Ox)
      n === "" ? n = t[e] : n !== t[e] || (n = "");
    else if (t[e] === ">" && n === "") {
      s = !0;
      break;
    }
    r += t[e];
  }
  return n !== "" ? !1 : {
    value: r,
    index: e,
    tagClosed: s
  };
}
const qx = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function ug(t, e) {
  const r = bp(t, qx), n = {};
  for (let s = 0; s < r.length; s++) {
    if (r[s][1].length === 0)
      return Et("InvalidAttr", "Attribute '" + r[s][2] + "' has no space in starting.", Ss(r[s]));
    if (r[s][3] !== void 0 && r[s][4] === void 0)
      return Et("InvalidAttr", "Attribute '" + r[s][2] + "' is without value.", Ss(r[s]));
    if (r[s][3] === void 0 && !e.allowBooleanAttributes)
      return Et("InvalidAttr", "boolean attribute '" + r[s][2] + "' is not allowed.", Ss(r[s]));
    const i = r[s][2];
    if (!Jx(i))
      return Et("InvalidAttr", "Attribute '" + i + "' is an invalid name.", Ss(r[s]));
    if (!n.hasOwnProperty(i))
      n[i] = 1;
    else
      return Et("InvalidAttr", "Attribute '" + i + "' is repeated.", Ss(r[s]));
  }
  return !0;
}
function Gx(t, e) {
  let r = /\d/;
  for (t[e] === "x" && (e++, r = /[\da-fA-F]/); e < t.length; e++) {
    if (t[e] === ";")
      return e;
    if (!t[e].match(r))
      break;
  }
  return -1;
}
function Yx(t, e) {
  if (e++, t[e] === ";")
    return -1;
  if (t[e] === "#")
    return e++, Gx(t, e);
  let r = 0;
  for (; e < t.length; e++, r++)
    if (!(t[e].match(/\w/) && r < 20)) {
      if (t[e] === ";")
        break;
      return -1;
    }
  return e;
}
function Et(t, e, r) {
  return {
    err: {
      code: t,
      msg: e,
      line: r.line || r,
      col: r.col
    }
  };
}
function Jx(t) {
  return yo(t);
}
function Vx(t) {
  return yo(t);
}
function Yt(t, e) {
  const r = t.substring(0, e).split(/\r?\n/);
  return {
    line: r.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: r[r.length - 1].length + 1
  };
}
function Ss(t) {
  return t.startIndex + t[1].length;
}
const _x = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(t, e) {
    return e;
  },
  attributeValueProcessor: function(t, e) {
    return e;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(t, e, r) {
    return t;
  },
  // skipEmptyListItem: false
  captureMetaData: !1
};
function Rp(t) {
  return typeof t == "boolean" ? {
    enabled: t,
    // true or false
    maxEntitySize: 1e4,
    maxExpansionDepth: 10,
    maxTotalExpansions: 1e3,
    maxExpandedLength: 1e5,
    allowedTags: null,
    tagFilter: null
  } : typeof t == "object" && t !== null ? {
    enabled: t.enabled !== !1,
    // default true if not specified
    maxEntitySize: t.maxEntitySize ?? 1e4,
    maxExpansionDepth: t.maxExpansionDepth ?? 10,
    maxTotalExpansions: t.maxTotalExpansions ?? 1e3,
    maxExpandedLength: t.maxExpandedLength ?? 1e5,
    allowedTags: t.allowedTags ?? null,
    tagFilter: t.tagFilter ?? null
  } : Rp(!0);
}
const Wx = function(t) {
  const e = Object.assign({}, _x, t);
  return e.processEntities = Rp(e.processEntities), e;
};
let Ji;
typeof Symbol != "function" ? Ji = "@@xmlMetadata" : Ji = /* @__PURE__ */ Symbol("XML Node Metadata");
class fn {
  constructor(e) {
    this.tagname = e, this.child = [], this[":@"] = {};
  }
  add(e, r) {
    e === "__proto__" && (e = "#__proto__"), this.child.push({ [e]: r });
  }
  addChild(e, r) {
    e.tagname === "__proto__" && (e.tagname = "#__proto__"), e[":@"] && Object.keys(e[":@"]).length > 0 ? this.child.push({ [e.tagname]: e.child, ":@": e[":@"] }) : this.child.push({ [e.tagname]: e.child }), r !== void 0 && (this.child[this.child.length - 1][Ji] = { startIndex: r });
  }
  /** symbol used for metadata */
  static getMetaDataSymbol() {
    return Ji;
  }
}
class $x {
  constructor(e) {
    this.suppressValidationErr = !e, this.options = e;
  }
  readDocType(e, r) {
    const n = {};
    if (e[r + 3] === "O" && e[r + 4] === "C" && e[r + 5] === "T" && e[r + 6] === "Y" && e[r + 7] === "P" && e[r + 8] === "E") {
      r = r + 9;
      let s = 1, i = !1, o = !1, a = "";
      for (; r < e.length; r++)
        if (e[r] === "<" && !o) {
          if (i && mn(e, "!ENTITY", r)) {
            r += 7;
            let A, c;
            if ([A, c, r] = this.readEntityExp(e, r + 1, this.suppressValidationErr), c.indexOf("&") === -1) {
              const l = A.replace(/[.\-+*:]/g, "\\.");
              n[A] = {
                regx: RegExp(`&${l};`, "g"),
                val: c
              };
            }
          } else if (i && mn(e, "!ELEMENT", r)) {
            r += 8;
            const { index: A } = this.readElementExp(e, r + 1);
            r = A;
          } else if (i && mn(e, "!ATTLIST", r))
            r += 8;
          else if (i && mn(e, "!NOTATION", r)) {
            r += 9;
            const { index: A } = this.readNotationExp(e, r + 1, this.suppressValidationErr);
            r = A;
          } else if (mn(e, "!--", r)) o = !0;
          else throw new Error("Invalid DOCTYPE");
          s++, a = "";
        } else if (e[r] === ">") {
          if (o ? e[r - 1] === "-" && e[r - 2] === "-" && (o = !1, s--) : s--, s === 0)
            break;
        } else e[r] === "[" ? i = !0 : a += e[r];
      if (s !== 0)
        throw new Error("Unclosed DOCTYPE");
    } else
      throw new Error("Invalid Tag instead of DOCTYPE");
    return { entities: n, i: r };
  }
  readEntityExp(e, r) {
    r = $t(e, r);
    let n = "";
    for (; r < e.length && !/\s/.test(e[r]) && e[r] !== '"' && e[r] !== "'"; )
      n += e[r], r++;
    if (Ds(n), r = $t(e, r), !this.suppressValidationErr) {
      if (e.substring(r, r + 6).toUpperCase() === "SYSTEM")
        throw new Error("External entities are not supported");
      if (e[r] === "%")
        throw new Error("Parameter entities are not supported");
    }
    let s = "";
    if ([r, s] = this.readIdentifierVal(e, r, "entity"), this.options.enabled !== !1 && this.options.maxEntitySize && s.length > this.options.maxEntitySize)
      throw new Error(
        `Entity "${n}" size (${s.length}) exceeds maximum allowed size (${this.options.maxEntitySize})`
      );
    return r--, [n, s, r];
  }
  readNotationExp(e, r) {
    r = $t(e, r);
    let n = "";
    for (; r < e.length && !/\s/.test(e[r]); )
      n += e[r], r++;
    !this.suppressValidationErr && Ds(n), r = $t(e, r);
    const s = e.substring(r, r + 6).toUpperCase();
    if (!this.suppressValidationErr && s !== "SYSTEM" && s !== "PUBLIC")
      throw new Error(`Expected SYSTEM or PUBLIC, found "${s}"`);
    r += s.length, r = $t(e, r);
    let i = null, o = null;
    if (s === "PUBLIC")
      [r, i] = this.readIdentifierVal(e, r, "publicIdentifier"), r = $t(e, r), (e[r] === '"' || e[r] === "'") && ([r, o] = this.readIdentifierVal(e, r, "systemIdentifier"));
    else if (s === "SYSTEM" && ([r, o] = this.readIdentifierVal(e, r, "systemIdentifier"), !this.suppressValidationErr && !o))
      throw new Error("Missing mandatory system identifier for SYSTEM notation");
    return { notationName: n, publicIdentifier: i, systemIdentifier: o, index: --r };
  }
  readIdentifierVal(e, r, n) {
    let s = "";
    const i = e[r];
    if (i !== '"' && i !== "'")
      throw new Error(`Expected quoted string, found "${i}"`);
    for (r++; r < e.length && e[r] !== i; )
      s += e[r], r++;
    if (e[r] !== i)
      throw new Error(`Unterminated ${n} value`);
    return r++, [r, s];
  }
  readElementExp(e, r) {
    r = $t(e, r);
    let n = "";
    for (; r < e.length && !/\s/.test(e[r]); )
      n += e[r], r++;
    if (!this.suppressValidationErr && !yo(n))
      throw new Error(`Invalid element name: "${n}"`);
    r = $t(e, r);
    let s = "";
    if (e[r] === "E" && mn(e, "MPTY", r)) r += 4;
    else if (e[r] === "A" && mn(e, "NY", r)) r += 2;
    else if (e[r] === "(") {
      for (r++; r < e.length && e[r] !== ")"; )
        s += e[r], r++;
      if (e[r] !== ")")
        throw new Error("Unterminated content model");
    } else if (!this.suppressValidationErr)
      throw new Error(`Invalid Element Expression, found "${e[r]}"`);
    return {
      elementName: n,
      contentModel: s.trim(),
      index: r
    };
  }
  readAttlistExp(e, r) {
    r = $t(e, r);
    let n = "";
    for (; r < e.length && !/\s/.test(e[r]); )
      n += e[r], r++;
    Ds(n), r = $t(e, r);
    let s = "";
    for (; r < e.length && !/\s/.test(e[r]); )
      s += e[r], r++;
    if (!Ds(s))
      throw new Error(`Invalid attribute name: "${s}"`);
    r = $t(e, r);
    let i = "";
    if (e.substring(r, r + 8).toUpperCase() === "NOTATION") {
      if (i = "NOTATION", r += 8, r = $t(e, r), e[r] !== "(")
        throw new Error(`Expected '(', found "${e[r]}"`);
      r++;
      let a = [];
      for (; r < e.length && e[r] !== ")"; ) {
        let A = "";
        for (; r < e.length && e[r] !== "|" && e[r] !== ")"; )
          A += e[r], r++;
        if (A = A.trim(), !Ds(A))
          throw new Error(`Invalid notation name: "${A}"`);
        a.push(A), e[r] === "|" && (r++, r = $t(e, r));
      }
      if (e[r] !== ")")
        throw new Error("Unterminated list of notations");
      r++, i += " (" + a.join("|") + ")";
    } else {
      for (; r < e.length && !/\s/.test(e[r]); )
        i += e[r], r++;
      const a = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
      if (!this.suppressValidationErr && !a.includes(i.toUpperCase()))
        throw new Error(`Invalid attribute type: "${i}"`);
    }
    r = $t(e, r);
    let o = "";
    return e.substring(r, r + 8).toUpperCase() === "#REQUIRED" ? (o = "#REQUIRED", r += 8) : e.substring(r, r + 7).toUpperCase() === "#IMPLIED" ? (o = "#IMPLIED", r += 7) : [r, o] = this.readIdentifierVal(e, r, "ATTLIST"), {
      elementName: n,
      attributeName: s,
      attributeType: i,
      defaultValue: o,
      index: r
    };
  }
}
const $t = (t, e) => {
  for (; e < t.length && /\s/.test(t[e]); )
    e++;
  return e;
};
function mn(t, e, r) {
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[r + n + 1]) return !1;
  return !0;
}
function Ds(t) {
  if (yo(t))
    return t;
  throw new Error(`Invalid entity name ${t}`);
}
const Xx = /^[-+]?0x[a-fA-F0-9]+$/, Zx = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, Kx = {
  hex: !0,
  // oct: false,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function jx(t, e = {}) {
  if (e = Object.assign({}, Kx, e), !t || typeof t != "string") return t;
  let r = t.trim();
  if (e.skipLike !== void 0 && e.skipLike.test(r)) return t;
  if (t === "0") return 0;
  if (e.hex && Xx.test(r))
    return nR(r, 16);
  if (r.includes("e") || r.includes("E"))
    return tR(t, r, e);
  {
    const n = Zx.exec(r);
    if (n) {
      const s = n[1] || "", i = n[2];
      let o = rR(n[3]);
      const a = s ? (
        // 0., -00., 000.
        t[i.length + 1] === "."
      ) : t[i.length] === ".";
      if (!e.leadingZeros && (i.length > 1 || i.length === 1 && !a))
        return t;
      {
        const A = Number(r), c = String(A);
        if (A === 0) return A;
        if (c.search(/[eE]/) !== -1)
          return e.eNotation ? A : t;
        if (r.indexOf(".") !== -1)
          return c === "0" || c === o || c === `${s}${o}` ? A : t;
        let l = i ? o : r;
        return i ? l === c || s + l === c ? A : t : l === c || l === s + c ? A : t;
      }
    } else
      return t;
  }
}
const eR = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
function tR(t, e, r) {
  if (!r.eNotation) return t;
  const n = e.match(eR);
  if (n) {
    let s = n[1] || "";
    const i = n[3].indexOf("e") === -1 ? "E" : "e", o = n[2], a = s ? (
      // 0E.
      t[o.length + 1] === i
    ) : t[o.length] === i;
    return o.length > 1 && a ? t : o.length === 1 && (n[3].startsWith(`.${i}`) || n[3][0] === i) ? Number(e) : r.leadingZeros && !a ? (e = (n[1] || "") + n[3], Number(e)) : t;
  } else
    return t;
}
function rR(t) {
  return t && t.indexOf(".") !== -1 && (t = t.replace(/0+$/, ""), t === "." ? t = "0" : t[0] === "." ? t = "0" + t : t[t.length - 1] === "." && (t = t.substring(0, t.length - 1))), t;
}
function nR(t, e) {
  if (parseInt) return parseInt(t, e);
  if (Number.parseInt) return Number.parseInt(t, e);
  if (window && window.parseInt) return window.parseInt(t, e);
  throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
function Sp(t) {
  return typeof t == "function" ? t : Array.isArray(t) ? (e) => {
    for (const r of t)
      if (typeof r == "string" && e === r || r instanceof RegExp && r.test(e))
        return !0;
  } : () => !1;
}
class sR {
  constructor(e) {
    if (this.options = e, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (r, n) => mg(n, 10, "&#") },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (r, n) => mg(n, 16, "&#x") }
    }, this.addExternalEntities = iR, this.parseXml = lR, this.parseTextData = oR, this.resolveNameSpace = aR, this.buildAttributesMap = cR, this.isItStopNode = hR, this.replaceEntitiesValue = uR, this.readStopNodeData = fR, this.saveTextToParentTag = mR, this.addChild = dR, this.ignoreAttributesFn = Sp(this.options.ignoreAttributes), this.entityExpansionCount = 0, this.currentExpandedLength = 0, this.options.stopNodes && this.options.stopNodes.length > 0) {
      this.stopNodesExact = /* @__PURE__ */ new Set(), this.stopNodesWildcard = /* @__PURE__ */ new Set();
      for (let r = 0; r < this.options.stopNodes.length; r++) {
        const n = this.options.stopNodes[r];
        typeof n == "string" && (n.startsWith("*.") ? this.stopNodesWildcard.add(n.substring(2)) : this.stopNodesExact.add(n));
      }
    }
  }
}
function iR(t) {
  const e = Object.keys(t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], s = n.replace(/[.\-+*:]/g, "\\.");
    this.lastEntities[n] = {
      regex: new RegExp("&" + s + ";", "g"),
      val: t[n]
    };
  }
}
function oR(t, e, r, n, s, i, o) {
  if (t !== void 0 && (this.options.trimValues && !n && (t = t.trim()), t.length > 0)) {
    o || (t = this.replaceEntitiesValue(t, e, r));
    const a = this.options.tagValueProcessor(e, t, r, s, i);
    return a == null ? t : typeof a != typeof t || a !== t ? a : this.options.trimValues ? Kc(t, this.options.parseTagValue, this.options.numberParseOptions) : t.trim() === t ? Kc(t, this.options.parseTagValue, this.options.numberParseOptions) : t;
  }
}
function aR(t) {
  if (this.options.removeNSPrefix) {
    const e = t.split(":"), r = t.charAt(0) === "/" ? "/" : "";
    if (e[0] === "xmlns")
      return "";
    e.length === 2 && (t = r + e[1]);
  }
  return t;
}
const AR = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function cR(t, e, r) {
  if (this.options.ignoreAttributes !== !0 && typeof t == "string") {
    const n = bp(t, AR), s = n.length, i = {};
    for (let o = 0; o < s; o++) {
      const a = this.resolveNameSpace(n[o][1]);
      if (this.ignoreAttributesFn(a, e))
        continue;
      let A = n[o][4], c = this.options.attributeNamePrefix + a;
      if (a.length)
        if (this.options.transformAttributeName && (c = this.options.transformAttributeName(c)), c === "__proto__" && (c = "#__proto__"), A !== void 0) {
          this.options.trimValues && (A = A.trim()), A = this.replaceEntitiesValue(A, r, e);
          const l = this.options.attributeValueProcessor(a, A, e);
          l == null ? i[c] = A : typeof l != typeof A || l !== A ? i[c] = l : i[c] = Kc(
            A,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else this.options.allowBooleanAttributes && (i[c] = !0);
    }
    if (!Object.keys(i).length)
      return;
    if (this.options.attributesGroupName) {
      const o = {};
      return o[this.options.attributesGroupName] = i, o;
    }
    return i;
  }
}
const lR = function(t) {
  t = t.replace(/\r\n?/g, `
`);
  const e = new fn("!xml");
  let r = e, n = "", s = "";
  this.entityExpansionCount = 0, this.currentExpandedLength = 0;
  const i = new $x(this.options.processEntities);
  for (let o = 0; o < t.length; o++)
    if (t[o] === "<")
      if (t[o + 1] === "/") {
        const A = En(t, ">", o, "Closing Tag is not closed.");
        let c = t.substring(o + 2, A).trim();
        if (this.options.removeNSPrefix) {
          const u = c.indexOf(":");
          u !== -1 && (c = c.substr(u + 1));
        }
        this.options.transformTagName && (c = this.options.transformTagName(c)), r && (n = this.saveTextToParentTag(n, r, s));
        const l = s.substring(s.lastIndexOf(".") + 1);
        if (c && this.options.unpairedTags.indexOf(c) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${c}>`);
        let d = 0;
        l && this.options.unpairedTags.indexOf(l) !== -1 ? (d = s.lastIndexOf(".", s.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : d = s.lastIndexOf("."), s = s.substring(0, d), r = this.tagsNodeStack.pop(), n = "", o = A;
      } else if (t[o + 1] === "?") {
        let A = Zc(t, o, !1, "?>");
        if (!A) throw new Error("Pi Tag is not closed.");
        if (n = this.saveTextToParentTag(n, r, s), !(this.options.ignoreDeclaration && A.tagName === "?xml" || this.options.ignorePiTags)) {
          const c = new fn(A.tagName);
          c.add(this.options.textNodeName, ""), A.tagName !== A.tagExp && A.attrExpPresent && (c[":@"] = this.buildAttributesMap(A.tagExp, s, A.tagName)), this.addChild(r, c, s, o);
        }
        o = A.closeIndex + 1;
      } else if (t.substr(o + 1, 3) === "!--") {
        const A = En(t, "-->", o + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const c = t.substring(o + 4, A - 2);
          n = this.saveTextToParentTag(n, r, s), r.add(this.options.commentPropName, [{ [this.options.textNodeName]: c }]);
        }
        o = A;
      } else if (t.substr(o + 1, 2) === "!D") {
        const A = i.readDocType(t, o);
        this.docTypeEntities = A.entities, o = A.i;
      } else if (t.substr(o + 1, 2) === "![") {
        const A = En(t, "]]>", o, "CDATA is not closed.") - 2, c = t.substring(o + 9, A);
        n = this.saveTextToParentTag(n, r, s);
        let l = this.parseTextData(c, r.tagname, s, !0, !1, !0, !0);
        l == null && (l = ""), this.options.cdataPropName ? r.add(this.options.cdataPropName, [{ [this.options.textNodeName]: c }]) : r.add(this.options.textNodeName, l), o = A + 2;
      } else {
        let A = Zc(t, o, this.options.removeNSPrefix), c = A.tagName;
        const l = A.rawTagName;
        let d = A.tagExp, u = A.attrExpPresent, m = A.closeIndex;
        if (this.options.transformTagName) {
          const p = this.options.transformTagName(c);
          d === c && (d = p), c = p;
        }
        r && n && r.tagname !== "!xml" && (n = this.saveTextToParentTag(n, r, s, !1));
        const h = r;
        h && this.options.unpairedTags.indexOf(h.tagname) !== -1 && (r = this.tagsNodeStack.pop(), s = s.substring(0, s.lastIndexOf("."))), c !== e.tagname && (s += s ? "." + c : c);
        const f = o;
        if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, s, c)) {
          let p = "";
          if (d.length > 0 && d.lastIndexOf("/") === d.length - 1)
            c[c.length - 1] === "/" ? (c = c.substr(0, c.length - 1), s = s.substr(0, s.length - 1), d = c) : d = d.substr(0, d.length - 1), o = A.closeIndex;
          else if (this.options.unpairedTags.indexOf(c) !== -1)
            o = A.closeIndex;
          else {
            const w = this.readStopNodeData(t, l, m + 1);
            if (!w) throw new Error(`Unexpected end of ${l}`);
            o = w.i, p = w.tagContent;
          }
          const y = new fn(c);
          c !== d && u && (y[":@"] = this.buildAttributesMap(d, s, c)), p && (p = this.parseTextData(p, c, s, !0, u, !0, !0)), s = s.substr(0, s.lastIndexOf(".")), y.add(this.options.textNodeName, p), this.addChild(r, y, s, f);
        } else {
          if (d.length > 0 && d.lastIndexOf("/") === d.length - 1) {
            if (c[c.length - 1] === "/" ? (c = c.substr(0, c.length - 1), s = s.substr(0, s.length - 1), d = c) : d = d.substr(0, d.length - 1), this.options.transformTagName) {
              const y = this.options.transformTagName(c);
              d === c && (d = y), c = y;
            }
            const p = new fn(c);
            c !== d && u && (p[":@"] = this.buildAttributesMap(d, s, c)), this.addChild(r, p, s, f), s = s.substr(0, s.lastIndexOf("."));
          } else {
            const p = new fn(c);
            this.tagsNodeStack.push(r), c !== d && u && (p[":@"] = this.buildAttributesMap(d, s, c)), this.addChild(r, p, s, f), r = p;
          }
          n = "", o = m;
        }
      }
    else
      n += t[o];
  return e.child;
};
function dR(t, e, r, n) {
  this.options.captureMetaData || (n = void 0);
  const s = this.options.updateTag(e.tagname, r, e[":@"]);
  s === !1 || (typeof s == "string" && (e.tagname = s), t.addChild(e, n));
}
const uR = function(t, e, r) {
  if (t.indexOf("&") === -1)
    return t;
  const n = this.options.processEntities;
  if (!n.enabled || n.allowedTags && !n.allowedTags.includes(e) || n.tagFilter && !n.tagFilter(e, r))
    return t;
  for (let s in this.docTypeEntities) {
    const i = this.docTypeEntities[s], o = t.match(i.regx);
    if (o) {
      if (this.entityExpansionCount += o.length, n.maxTotalExpansions && this.entityExpansionCount > n.maxTotalExpansions)
        throw new Error(
          `Entity expansion limit exceeded: ${this.entityExpansionCount} > ${n.maxTotalExpansions}`
        );
      const a = t.length;
      if (t = t.replace(i.regx, i.val), n.maxExpandedLength && (this.currentExpandedLength += t.length - a, this.currentExpandedLength > n.maxExpandedLength))
        throw new Error(
          `Total expanded content size exceeded: ${this.currentExpandedLength} > ${n.maxExpandedLength}`
        );
    }
  }
  if (t.indexOf("&") === -1) return t;
  for (let s in this.lastEntities) {
    const i = this.lastEntities[s];
    t = t.replace(i.regex, i.val);
  }
  if (t.indexOf("&") === -1) return t;
  if (this.options.htmlEntities)
    for (let s in this.htmlEntities) {
      const i = this.htmlEntities[s];
      t = t.replace(i.regex, i.val);
    }
  return t = t.replace(this.ampEntity.regex, this.ampEntity.val), t;
};
function mR(t, e, r, n) {
  return t && (n === void 0 && (n = e.child.length === 0), t = this.parseTextData(
    t,
    e.tagname,
    r,
    !1,
    e[":@"] ? Object.keys(e[":@"]).length !== 0 : !1,
    n
  ), t !== void 0 && t !== "" && e.add(this.options.textNodeName, t), t = ""), t;
}
function hR(t, e, r, n) {
  return !!(e && e.has(n) || t && t.has(r));
}
function gR(t, e, r = ">") {
  let n, s = "";
  for (let i = e; i < t.length; i++) {
    let o = t[i];
    if (n)
      o === n && (n = "");
    else if (o === '"' || o === "'")
      n = o;
    else if (o === r[0])
      if (r[1]) {
        if (t[i + 1] === r[1])
          return {
            data: s,
            index: i
          };
      } else
        return {
          data: s,
          index: i
        };
    else o === "	" && (o = " ");
    s += o;
  }
}
function En(t, e, r, n) {
  const s = t.indexOf(e, r);
  if (s === -1)
    throw new Error(n);
  return s + e.length - 1;
}
function Zc(t, e, r, n = ">") {
  const s = gR(t, e + 1, n);
  if (!s) return;
  let i = s.data;
  const o = s.index, a = i.search(/\s/);
  let A = i, c = !0;
  a !== -1 && (A = i.substring(0, a), i = i.substring(a + 1).trimStart());
  const l = A;
  if (r) {
    const d = A.indexOf(":");
    d !== -1 && (A = A.substr(d + 1), c = A !== s.data.substr(d + 1));
  }
  return {
    tagName: A,
    tagExp: i,
    closeIndex: o,
    attrExpPresent: c,
    rawTagName: l
  };
}
function fR(t, e, r) {
  const n = r;
  let s = 1;
  for (; r < t.length; r++)
    if (t[r] === "<")
      if (t[r + 1] === "/") {
        const i = En(t, ">", r, `${e} is not closed`);
        if (t.substring(r + 2, i).trim() === e && (s--, s === 0))
          return {
            tagContent: t.substring(n, r),
            i
          };
        r = i;
      } else if (t[r + 1] === "?")
        r = En(t, "?>", r + 1, "StopNode is not closed.");
      else if (t.substr(r + 1, 3) === "!--")
        r = En(t, "-->", r + 3, "StopNode is not closed.");
      else if (t.substr(r + 1, 2) === "![")
        r = En(t, "]]>", r, "StopNode is not closed.") - 2;
      else {
        const i = Zc(t, r, ">");
        i && ((i && i.tagName) === e && i.tagExp[i.tagExp.length - 1] !== "/" && s++, r = i.closeIndex);
      }
}
function Kc(t, e, r) {
  if (e && typeof t == "string") {
    const n = t.trim();
    return n === "true" ? !0 : n === "false" ? !1 : jx(t, r);
  } else
    return Ux(t) ? t : "";
}
function mg(t, e, r) {
  const n = Number.parseInt(t, e);
  return n >= 0 && n <= 1114111 ? String.fromCodePoint(n) : r + t + ";";
}
const kc = fn.getMetaDataSymbol();
function pR(t, e) {
  return Dp(t, e);
}
function Dp(t, e, r) {
  let n;
  const s = {};
  for (let i = 0; i < t.length; i++) {
    const o = t[i], a = ER(o);
    let A = "";
    if (r === void 0 ? A = a : A = r + "." + a, a === e.textNodeName)
      n === void 0 ? n = o[a] : n += "" + o[a];
    else {
      if (a === void 0)
        continue;
      if (o[a]) {
        let c = Dp(o[a], e, A);
        const l = BR(c, e);
        o[kc] !== void 0 && (c[kc] = o[kc]), o[":@"] ? CR(c, o[":@"], A, e) : Object.keys(c).length === 1 && c[e.textNodeName] !== void 0 && !e.alwaysCreateTextNode ? c = c[e.textNodeName] : Object.keys(c).length === 0 && (e.alwaysCreateTextNode ? c[e.textNodeName] = "" : c = ""), s[a] !== void 0 && s.hasOwnProperty(a) ? (Array.isArray(s[a]) || (s[a] = [s[a]]), s[a].push(c)) : e.isArray(a, A, l) ? s[a] = [c] : s[a] = c;
      }
    }
  }
  return typeof n == "string" ? n.length > 0 && (s[e.textNodeName] = n) : n !== void 0 && (s[e.textNodeName] = n), s;
}
function ER(t) {
  const e = Object.keys(t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r];
    if (n !== ":@") return n;
  }
}
function CR(t, e, r, n) {
  if (e) {
    const s = Object.keys(e), i = s.length;
    for (let o = 0; o < i; o++) {
      const a = s[o];
      n.isArray(a, r + "." + a, !0, !0) ? t[a] = [e[a]] : t[a] = e[a];
    }
  }
}
function BR(t, e) {
  const { textNodeName: r } = e, n = Object.keys(t).length;
  return !!(n === 0 || n === 1 && (t[r] || typeof t[r] == "boolean" || t[r] === 0));
}
class kp {
  constructor(e) {
    this.externalEntities = {}, this.options = Wx(e);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Uint8Array} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(e, r) {
    if (typeof e != "string" && e.toString)
      e = e.toString();
    else if (typeof e != "string")
      throw new Error("XML data is accepted in String or Bytes[] form.");
    if (r) {
      r === !0 && (r = {});
      const i = xp(e, r);
      if (i !== !0)
        throw Error(`${i.err.msg}:${i.err.line}:${i.err.col}`);
    }
    const n = new sR(this.options);
    n.addExternalEntities(this.externalEntities);
    const s = n.parseXml(e);
    return this.options.preserveOrder || s === void 0 ? s : pR(s, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(e, r) {
    if (r.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (e.indexOf("&") !== -1 || e.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (r === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[e] = r;
  }
  /**
   * Returns a Symbol that can be used to access the metadata
   * property on a node.
   * 
   * If Symbol is not available in the environment, an ordinary property is used
   * and the name of the property is here returned.
   * 
   * The XMLMetaData property is only present when `captureMetaData`
   * is true in the options.
   */
  static getMetaDataSymbol() {
    return fn.getMetaDataSymbol();
  }
}
const IR = `
`;
function yR(t, e) {
  let r = "";
  return e.format && e.indentBy.length > 0 && (r = IR), Mp(t, e, "", r);
}
function Mp(t, e, r, n) {
  let s = "", i = !1;
  for (let o = 0; o < t.length; o++) {
    const a = t[o], A = QR(a);
    if (A === void 0) continue;
    let c = "";
    if (r.length === 0 ? c = A : c = `${r}.${A}`, A === e.textNodeName) {
      let h = a[A];
      NR(c, e) || (h = e.tagValueProcessor(A, h), h = Tp(h, e)), i && (s += n), s += h, i = !1;
      continue;
    } else if (A === e.cdataPropName) {
      i && (s += n), s += `<![CDATA[${a[A][0][e.textNodeName]}]]>`, i = !1;
      continue;
    } else if (A === e.commentPropName) {
      s += n + `<!--${a[A][0][e.textNodeName]}-->`, i = !0;
      continue;
    } else if (A[0] === "?") {
      const h = hg(a[":@"], e), f = A === "?xml" ? "" : n;
      let p = a[A][0][e.textNodeName];
      p = p.length !== 0 ? " " + p : "", s += f + `<${A}${p}${h}?>`, i = !0;
      continue;
    }
    let l = n;
    l !== "" && (l += e.indentBy);
    const d = hg(a[":@"], e), u = n + `<${A}${d}`, m = Mp(a[A], e, c, l);
    e.unpairedTags.indexOf(A) !== -1 ? e.suppressUnpairedNode ? s += u + ">" : s += u + "/>" : (!m || m.length === 0) && e.suppressEmptyNode ? s += u + "/>" : m && m.endsWith(">") ? s += u + `>${m}${n}</${A}>` : (s += u + ">", m && n !== "" && (m.includes("/>") || m.includes("</")) ? s += n + e.indentBy + m + n : s += m, s += `</${A}>`), i = !0;
  }
  return s;
}
function QR(t) {
  const e = Object.keys(t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r];
    if (t.hasOwnProperty(n) && n !== ":@")
      return n;
  }
}
function hg(t, e) {
  let r = "";
  if (t && !e.ignoreAttributes)
    for (let n in t) {
      if (!t.hasOwnProperty(n)) continue;
      let s = e.attributeValueProcessor(n, t[n]);
      s = Tp(s, e), s === !0 && e.suppressBooleanAttributes ? r += ` ${n.substr(e.attributeNamePrefix.length)}` : r += ` ${n.substr(e.attributeNamePrefix.length)}="${s}"`;
    }
  return r;
}
function NR(t, e) {
  t = t.substr(0, t.length - e.textNodeName.length - 1);
  let r = t.substr(t.lastIndexOf(".") + 1);
  for (let n in e.stopNodes)
    if (e.stopNodes[n] === t || e.stopNodes[n] === "*." + r) return !0;
  return !1;
}
function Tp(t, e) {
  if (t && t.length > 0 && e.processEntities)
    for (let r = 0; r < e.entities.length; r++) {
      const n = e.entities[r];
      t = t.replace(n.regex, n.val);
    }
  return t;
}
const wR = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(t, e) {
    return e;
  },
  attributeValueProcessor: function(t, e) {
    return e;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function tn(t) {
  this.options = Object.assign({}, wR, t), this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.ignoreAttributesFn = Sp(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = RR), this.processTextOrObjNode = bR, this.options.format ? (this.indentate = xR, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
tn.prototype.build = function(t) {
  return this.options.preserveOrder ? yR(t, this.options) : (Array.isArray(t) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t = {
    [this.options.arrayNodeName]: t
  }), this.j2x(t, 0, []).val);
};
tn.prototype.j2x = function(t, e, r) {
  let n = "", s = "";
  const i = r.join(".");
  for (let o in t)
    if (Object.prototype.hasOwnProperty.call(t, o))
      if (typeof t[o] > "u")
        this.isAttribute(o) && (s += "");
      else if (t[o] === null)
        this.isAttribute(o) || o === this.options.cdataPropName ? s += "" : o[0] === "?" ? s += this.indentate(e) + "<" + o + "?" + this.tagEndChar : s += this.indentate(e) + "<" + o + "/" + this.tagEndChar;
      else if (t[o] instanceof Date)
        s += this.buildTextValNode(t[o], o, "", e);
      else if (typeof t[o] != "object") {
        const a = this.isAttribute(o);
        if (a && !this.ignoreAttributesFn(a, i))
          n += this.buildAttrPairStr(a, "" + t[o]);
        else if (!a)
          if (o === this.options.textNodeName) {
            let A = this.options.tagValueProcessor(o, "" + t[o]);
            s += this.replaceEntitiesValue(A);
          } else
            s += this.buildTextValNode(t[o], o, "", e);
      } else if (Array.isArray(t[o])) {
        const a = t[o].length;
        let A = "", c = "";
        for (let l = 0; l < a; l++) {
          const d = t[o][l];
          if (!(typeof d > "u")) if (d === null)
            o[0] === "?" ? s += this.indentate(e) + "<" + o + "?" + this.tagEndChar : s += this.indentate(e) + "<" + o + "/" + this.tagEndChar;
          else if (typeof d == "object")
            if (this.options.oneListGroup) {
              const u = this.j2x(d, e + 1, r.concat(o));
              A += u.val, this.options.attributesGroupName && d.hasOwnProperty(this.options.attributesGroupName) && (c += u.attrStr);
            } else
              A += this.processTextOrObjNode(d, o, e, r);
          else if (this.options.oneListGroup) {
            let u = this.options.tagValueProcessor(o, d);
            u = this.replaceEntitiesValue(u), A += u;
          } else
            A += this.buildTextValNode(d, o, "", e);
        }
        this.options.oneListGroup && (A = this.buildObjectNode(A, o, c, e)), s += A;
      } else if (this.options.attributesGroupName && o === this.options.attributesGroupName) {
        const a = Object.keys(t[o]), A = a.length;
        for (let c = 0; c < A; c++)
          n += this.buildAttrPairStr(a[c], "" + t[o][a[c]]);
      } else
        s += this.processTextOrObjNode(t[o], o, e, r);
  return { attrStr: n, val: s };
};
tn.prototype.buildAttrPairStr = function(t, e) {
  return e = this.options.attributeValueProcessor(t, "" + e), e = this.replaceEntitiesValue(e), this.options.suppressBooleanAttributes && e === "true" ? " " + t : " " + t + '="' + e + '"';
};
function bR(t, e, r, n) {
  const s = this.j2x(t, r + 1, n.concat(e));
  return t[this.options.textNodeName] !== void 0 && Object.keys(t).length === 1 ? this.buildTextValNode(t[this.options.textNodeName], e, s.attrStr, r) : this.buildObjectNode(s.val, e, s.attrStr, r);
}
tn.prototype.buildObjectNode = function(t, e, r, n) {
  if (t === "")
    return e[0] === "?" ? this.indentate(n) + "<" + e + r + "?" + this.tagEndChar : this.indentate(n) + "<" + e + r + this.closeTag(e) + this.tagEndChar;
  {
    let s = "</" + e + this.tagEndChar, i = "";
    return e[0] === "?" && (i = "?", s = ""), (r || r === "") && t.indexOf("<") === -1 ? this.indentate(n) + "<" + e + r + i + ">" + t + s : this.options.commentPropName !== !1 && e === this.options.commentPropName && i.length === 0 ? this.indentate(n) + `<!--${t}-->` + this.newLine : this.indentate(n) + "<" + e + r + i + this.tagEndChar + t + this.indentate(n) + s;
  }
};
tn.prototype.closeTag = function(t) {
  let e = "";
  return this.options.unpairedTags.indexOf(t) !== -1 ? this.options.suppressUnpairedNode || (e = "/") : this.options.suppressEmptyNode ? e = "/" : e = `></${t}`, e;
};
tn.prototype.buildTextValNode = function(t, e, r, n) {
  if (this.options.cdataPropName !== !1 && e === this.options.cdataPropName)
    return this.indentate(n) + `<![CDATA[${t}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && e === this.options.commentPropName)
    return this.indentate(n) + `<!--${t}-->` + this.newLine;
  if (e[0] === "?")
    return this.indentate(n) + "<" + e + r + "?" + this.tagEndChar;
  {
    let s = this.options.tagValueProcessor(e, t);
    return s = this.replaceEntitiesValue(s), s === "" ? this.indentate(n) + "<" + e + r + this.closeTag(e) + this.tagEndChar : this.indentate(n) + "<" + e + r + ">" + s + "</" + e + this.tagEndChar;
  }
};
tn.prototype.replaceEntitiesValue = function(t) {
  if (t && t.length > 0 && this.options.processEntities)
    for (let e = 0; e < this.options.entities.length; e++) {
      const r = this.options.entities[e];
      t = t.replace(r.regex, r.val);
    }
  return t;
};
function xR(t) {
  return this.options.indentBy.repeat(t);
}
function RR(t) {
  return t.startsWith(this.options.attributeNamePrefix) && t !== this.options.textNodeName ? t.substr(this.attrPrefixLen) : !1;
}
const SR = {
  validate: xp
}, DR = "$", kR = "_";
function Fp(t) {
  var e;
  return {
    attributesGroupName: DR,
    textNodeName: (e = t.xmlCharKey) !== null && e !== void 0 ? e : kR,
    ignoreAttributes: !1,
    suppressBooleanAttributes: !1
  };
}
function MR(t = {}) {
  var e, r;
  return Object.assign(Object.assign({}, Fp(t)), { attributeNamePrefix: "@_", format: !0, suppressEmptyNode: !0, indentBy: "", rootNodeName: (e = t.rootName) !== null && e !== void 0 ? e : "root", cdataPropName: (r = t.cdataPropName) !== null && r !== void 0 ? r : "__cdata" });
}
function TR(t = {}) {
  return Object.assign(Object.assign({}, Fp(t)), { parseAttributeValue: !1, parseTagValue: !1, attributeNamePrefix: "", stopNodes: t.stopNodes, processEntities: !0, trimValues: !1 });
}
function FR(t, e = {}) {
  const r = MR(e), n = new tn(r), s = { [r.rootNodeName]: t };
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${n.build(s)}`.replace(/\n/g, "");
}
async function vR(t, e = {}) {
  if (!t)
    throw new Error("Document is empty");
  const r = SR.validate(t);
  if (r !== !0)
    throw r;
  const s = new kp(TR(e)).parse(t);
  if (s["?xml"] && delete s["?xml"], !e.includeRoot)
    for (const i of Object.keys(s)) {
      const o = s[i];
      return typeof o == "object" ? Object.assign({}, o) : o;
    }
  return s;
}
const LR = Co("storage-blob");
class UR extends gl {
  buffers;
  byteLength;
  /**
   * The offset of data to be read in the current buffer.
   */
  byteOffsetInCurrentBuffer;
  /**
   * The index of buffer to be read in the array of buffers.
   */
  bufferIndex;
  /**
   * The total length of data already read.
   */
  pushedBytesLength;
  /**
   * Creates an instance of BuffersStream that will emit the data
   * contained in the array of buffers.
   *
   * @param buffers - Array of buffers containing the data
   * @param byteLength - The total length of data contained in the buffers
   */
  constructor(e, r, n) {
    super(n), this.buffers = e, this.byteLength = r, this.byteOffsetInCurrentBuffer = 0, this.bufferIndex = 0, this.pushedBytesLength = 0;
    let s = 0;
    for (const i of this.buffers)
      s += i.byteLength;
    if (s < this.byteLength)
      throw new Error("Data size shouldn't be larger than the total length of buffers.");
  }
  /**
   * Internal _read() that will be called when the stream wants to pull more data in.
   *
   * @param size - Optional. The size of data to be read
   */
  _read(e) {
    this.pushedBytesLength >= this.byteLength && this.push(null), e || (e = this.readableHighWaterMark);
    const r = [];
    let n = 0;
    for (; n < e && this.pushedBytesLength < this.byteLength; ) {
      const s = this.byteLength - this.pushedBytesLength, i = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer, o = Math.min(i, s);
      if (o > e - n) {
        const a = this.byteOffsetInCurrentBuffer + e - n;
        r.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, a)), this.pushedBytesLength += e - n, this.byteOffsetInCurrentBuffer = a, n = e;
        break;
      } else {
        const a = this.byteOffsetInCurrentBuffer + o;
        r.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, a)), o === i ? (this.byteOffsetInCurrentBuffer = 0, this.bufferIndex++) : this.byteOffsetInCurrentBuffer = a, this.pushedBytesLength += o, n += o;
      }
    }
    r.length > 1 ? this.push(Buffer.concat(r)) : r.length === 1 && this.push(r[0]);
  }
}
const bi = ur.constants.MAX_LENGTH;
class PR {
  /**
   * Internal buffers used to keep the data.
   * Each buffer has a length of the maxBufferLength except last one.
   */
  buffers = [];
  /**
   * The total size of internal buffers.
   */
  capacity;
  /**
   * The total size of data contained in internal buffers.
   */
  _size;
  /**
   * The size of the data contained in the pooled buffers.
   */
  get size() {
    return this._size;
  }
  constructor(e, r, n) {
    this.capacity = e, this._size = 0;
    const s = Math.ceil(e / bi);
    for (let i = 0; i < s; i++) {
      let o = i === s - 1 ? e % bi : bi;
      o === 0 && (o = bi), this.buffers.push(Buffer.allocUnsafe(o));
    }
    r && this.fill(r, n);
  }
  /**
   * Fill the internal buffers with data in the input buffers serially
   * with respect to the total length and the total capacity of the internal buffers.
   * Data copied will be shift out of the input buffers.
   *
   * @param buffers - Input buffers containing the data to be filled in the pooled buffer
   * @param totalLength - Total length of the data to be filled in.
   *
   */
  fill(e, r) {
    this._size = Math.min(this.capacity, r);
    let n = 0, s = 0, i = 0, o = 0, a = 0;
    for (; a < this._size; ) {
      const A = e[n], c = this.buffers[s], l = A.copy(c, i, o);
      a += l, o += l, i += l, o === A.length && (n++, o = 0), i === c.length && (s++, i = 0);
    }
    e.splice(0, n), e.length > 0 && (e[0] = e[0].slice(o));
  }
  /**
   * Get the readable stream assembled from all the data in the internal buffers.
   *
   */
  getReadableStream() {
    return new UR(this.buffers, this.size);
  }
}
class HR {
  /**
   * Size of buffers in incoming and outgoing queues. This class will try to align
   * data read from Readable stream into buffer chunks with bufferSize defined.
   */
  bufferSize;
  /**
   * How many buffers can be created or maintained.
   */
  maxBuffers;
  /**
   * A Node.js Readable stream.
   */
  readable;
  /**
   * OutgoingHandler is an async function triggered by BufferScheduler when there
   * are available buffers in outgoing array.
   */
  outgoingHandler;
  /**
   * An internal event emitter.
   */
  emitter = new Wg();
  /**
   * Concurrency of executing outgoingHandlers. (0 lesser than concurrency lesser than or equal to maxBuffers)
   */
  concurrency;
  /**
   * An internal offset marker to track data offset in bytes of next outgoingHandler.
   */
  offset = 0;
  /**
   * An internal marker to track whether stream is end.
   */
  isStreamEnd = !1;
  /**
   * An internal marker to track whether stream or outgoingHandler returns error.
   */
  isError = !1;
  /**
   * How many handlers are executing.
   */
  executingOutgoingHandlers = 0;
  /**
   * Encoding of the input Readable stream which has string data type instead of Buffer.
   */
  encoding;
  /**
   * How many buffers have been allocated.
   */
  numBuffers = 0;
  /**
   * Because this class doesn't know how much data every time stream pops, which
   * is defined by highWaterMarker of the stream. So BufferScheduler will cache
   * data received from the stream, when data in unresolvedDataArray exceeds the
   * blockSize defined, it will try to concat a blockSize of buffer, fill into available
   * buffers from incoming and push to outgoing array.
   */
  unresolvedDataArray = [];
  /**
   * How much data consisted in unresolvedDataArray.
   */
  unresolvedLength = 0;
  /**
   * The array includes all the available buffers can be used to fill data from stream.
   */
  incoming = [];
  /**
   * The array (queue) includes all the buffers filled from stream data.
   */
  outgoing = [];
  /**
   * Creates an instance of BufferScheduler.
   *
   * @param readable - A Node.js Readable stream
   * @param bufferSize - Buffer size of every maintained buffer
   * @param maxBuffers - How many buffers can be allocated
   * @param outgoingHandler - An async function scheduled to be
   *                                          triggered when a buffer fully filled
   *                                          with stream data
   * @param concurrency - Concurrency of executing outgoingHandlers (&gt;0)
   * @param encoding - [Optional] Encoding of Readable stream when it's a string stream
   */
  constructor(e, r, n, s, i, o) {
    if (r <= 0)
      throw new RangeError(`bufferSize must be larger than 0, current is ${r}`);
    if (n <= 0)
      throw new RangeError(`maxBuffers must be larger than 0, current is ${n}`);
    if (i <= 0)
      throw new RangeError(`concurrency must be larger than 0, current is ${i}`);
    this.bufferSize = r, this.maxBuffers = n, this.readable = e, this.outgoingHandler = s, this.concurrency = i, this.encoding = o;
  }
  /**
   * Start the scheduler, will return error when stream of any of the outgoingHandlers
   * returns error.
   *
   */
  async do() {
    return new Promise((e, r) => {
      this.readable.on("data", (n) => {
        n = typeof n == "string" ? Buffer.from(n, this.encoding) : n, this.appendUnresolvedData(n), this.resolveData() || this.readable.pause();
      }), this.readable.on("error", (n) => {
        this.emitter.emit("error", n);
      }), this.readable.on("end", () => {
        this.isStreamEnd = !0, this.emitter.emit("checkEnd");
      }), this.emitter.on("error", (n) => {
        this.isError = !0, this.readable.pause(), r(n);
      }), this.emitter.on("checkEnd", () => {
        if (this.outgoing.length > 0) {
          this.triggerOutgoingHandlers();
          return;
        }
        if (this.isStreamEnd && this.executingOutgoingHandlers === 0)
          if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
            const n = this.shiftBufferFromUnresolvedDataArray();
            this.outgoingHandler(() => n.getReadableStream(), n.size, this.offset).then(e).catch(r);
          } else {
            if (this.unresolvedLength >= this.bufferSize)
              return;
            e();
          }
      });
    });
  }
  /**
   * Insert a new data into unresolved array.
   *
   * @param data -
   */
  appendUnresolvedData(e) {
    this.unresolvedDataArray.push(e), this.unresolvedLength += e.length;
  }
  /**
   * Try to shift a buffer with size in blockSize. The buffer returned may be less
   * than blockSize when data in unresolvedDataArray is less than bufferSize.
   *
   */
  shiftBufferFromUnresolvedDataArray(e) {
    return e ? e.fill(this.unresolvedDataArray, this.unresolvedLength) : e = new PR(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength), this.unresolvedLength -= e.size, e;
  }
  /**
   * Resolve data in unresolvedDataArray. For every buffer with size in blockSize
   * shifted, it will try to get (or allocate a buffer) from incoming, and fill it,
   * then push it into outgoing to be handled by outgoing handler.
   *
   * Return false when available buffers in incoming are not enough, else true.
   *
   * @returns Return false when buffers in incoming are not enough, else true.
   */
  resolveData() {
    for (; this.unresolvedLength >= this.bufferSize; ) {
      let e;
      if (this.incoming.length > 0)
        e = this.incoming.shift(), this.shiftBufferFromUnresolvedDataArray(e);
      else if (this.numBuffers < this.maxBuffers)
        e = this.shiftBufferFromUnresolvedDataArray(), this.numBuffers++;
      else
        return !1;
      this.outgoing.push(e), this.triggerOutgoingHandlers();
    }
    return !0;
  }
  /**
   * Try to trigger a outgoing handler for every buffer in outgoing. Stop when
   * concurrency reaches.
   */
  async triggerOutgoingHandlers() {
    let e;
    do {
      if (this.executingOutgoingHandlers >= this.concurrency)
        return;
      e = this.outgoing.shift(), e && this.triggerOutgoingHandler(e);
    } while (e);
  }
  /**
   * Trigger a outgoing handler for a buffer shifted from outgoing.
   *
   * @param buffer -
   */
  async triggerOutgoingHandler(e) {
    const r = e.size;
    this.executingOutgoingHandlers++, this.offset += r;
    try {
      await this.outgoingHandler(() => e.getReadableStream(), r, this.offset - r);
    } catch (n) {
      this.emitter.emit("error", n);
      return;
    }
    this.executingOutgoingHandlers--, this.reuseBuffer(e), this.emitter.emit("checkEnd");
  }
  /**
   * Return buffer used by outgoing handler into incoming.
   *
   * @param buffer -
   */
  reuseBuffer(e) {
    this.incoming.push(e), !this.isError && this.resolveData() && !this.isStreamEnd && this.readable.resume();
  }
}
let Mc;
function OR() {
  return Mc || (Mc = op()), Mc;
}
class Wl {
  _nextPolicy;
  _options;
  /**
   * The main method to implement that manipulates a request/response.
   */
  constructor(e, r) {
    this._nextPolicy = e, this._options = r;
  }
  /**
   * Get whether or not a log with the provided log level should be logged.
   * @param logLevel - The log level of the log that will be logged.
   * @returns Whether or not a log with the provided log level should be logged.
   */
  shouldLog(e) {
    return this._options.shouldLog(e);
  }
  /**
   * Attempt to log the provided message to the provided logger. If no logger was provided or if
   * the log level does not meat the logger's threshold, then nothing will be logged.
   * @param logLevel - The log level of this log.
   * @param message - The message of this log.
   */
  log(e, r) {
    this._options.log(e, r);
  }
}
const Qo = {
  Parameters: {
    FORCE_BROWSER_NO_CACHE: "_",
    TIMEOUT: "timeout"
  }
}, Ge = {
  AUTHORIZATION: "Authorization",
  CONTENT_ENCODING: "Content-Encoding",
  CONTENT_LANGUAGE: "Content-Language",
  CONTENT_LENGTH: "Content-Length",
  CONTENT_MD5: "Content-Md5",
  CONTENT_TYPE: "Content-Type",
  COOKIE: "Cookie",
  DATE: "date",
  IF_MATCH: "if-match",
  IF_MODIFIED_SINCE: "if-modified-since",
  IF_NONE_MATCH: "if-none-match",
  IF_UNMODIFIED_SINCE: "if-unmodified-since",
  PREFIX_FOR_STORAGE: "x-ms-",
  RANGE: "Range",
  X_MS_DATE: "x-ms-date",
  X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
};
function No(t, e, r) {
  const n = new URL(t), s = encodeURIComponent(e), i = r ? encodeURIComponent(r) : void 0, o = n.search === "" ? "?" : n.search, a = [];
  for (const A of o.slice(1).split("&"))
    if (A) {
      const [c] = A.split("=", 2);
      c !== s && a.push(A);
    }
  return i && a.push(`${s}=${i}`), n.search = a.length ? `?${a.join("&")}` : "", n.toString();
}
function vp(t, e) {
  const r = new URL(t);
  return r.hostname = e, r.toString();
}
function Lp(t) {
  try {
    return new URL(t).pathname;
  } catch {
    return;
  }
}
function Up(t) {
  let e = new URL(t).search;
  if (!e)
    return {};
  e = e.trim(), e = e.startsWith("?") ? e.substring(1) : e;
  let r = e.split("&");
  r = r.filter((s) => {
    const i = s.indexOf("="), o = s.lastIndexOf("=");
    return i > 0 && i === o && o < s.length - 1;
  });
  const n = {};
  for (const s of r) {
    const i = s.split("="), o = i[0], a = i[1];
    n[o] = a;
  }
  return n;
}
async function Pp(t, e, r) {
  return new Promise((n, s) => {
    let i;
    const o = () => {
      i !== void 0 && clearTimeout(i), s(r);
    };
    i = setTimeout(() => {
      e !== void 0 && e.removeEventListener("abort", o), n();
    }, t), e !== void 0 && e.addEventListener("abort", o);
  });
}
class zR extends Wl {
  /**
   * Creates an instance of StorageBrowserPolicy.
   * @param nextPolicy -
   * @param options -
   */
  // The base class has a protected constructor. Adding a public one to enable constructing of this class.
  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
  constructor(e, r) {
    super(e, r);
  }
  /**
   * Sends out request.
   *
   * @param request -
   */
  async sendRequest(e) {
    return Rt ? this._nextPolicy.sendRequest(e) : ((e.method.toUpperCase() === "GET" || e.method.toUpperCase() === "HEAD") && (e.url = No(e.url, Qo.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString())), e.headers.remove(Ge.COOKIE), e.headers.remove(Ge.CONTENT_LENGTH), this._nextPolicy.sendRequest(e));
  }
}
class qR {
  /**
   * Creates a StorageBrowserPolicyFactory object.
   *
   * @param nextPolicy -
   * @param options -
   */
  create(e, r) {
    return new zR(e, r);
  }
}
class Hp extends Wl {
  /**
   * Sends out request.
   *
   * @param request -
   */
  sendRequest(e) {
    return this._nextPolicy.sendRequest(this.signRequest(e));
  }
  /**
   * Child classes must implement this method with request signing. This method
   * will be executed in {@link sendRequest}.
   *
   * @param request -
   */
  signRequest(e) {
    return e;
  }
}
class GR extends Hp {
  /**
   * Creates an instance of AnonymousCredentialPolicy.
   * @param nextPolicy -
   * @param options -
   */
  // The base class has a protected constructor. Adding a public one to enable constructing of this class.
  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
  constructor(e, r) {
    super(e, r);
  }
}
class Op {
  /**
   * Creates a RequestPolicy object.
   *
   * @param _nextPolicy -
   * @param _options -
   */
  create(e, r) {
    throw new Error("Method should be implemented in children classes.");
  }
}
class Vt extends Op {
  /**
   * Creates an {@link AnonymousCredentialPolicy} object.
   *
   * @param nextPolicy -
   * @param options -
   */
  create(e, r) {
    return new GR(e, r);
  }
}
const YR = new Uint32Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1820,
  0,
  1823,
  1825,
  1827,
  1829,
  0,
  0,
  0,
  1837,
  2051,
  0,
  0,
  1843,
  0,
  3331,
  3354,
  3356,
  3358,
  3360,
  3362,
  3364,
  3366,
  3368,
  3370,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3586,
  3593,
  3594,
  3610,
  3617,
  3619,
  3621,
  3628,
  3634,
  3637,
  3638,
  3656,
  3665,
  3696,
  3708,
  3710,
  3721,
  3722,
  3729,
  3737,
  3743,
  3746,
  3748,
  3750,
  3751,
  3753,
  0,
  0,
  0,
  1859,
  1860,
  1864,
  3586,
  3593,
  3594,
  3610,
  3617,
  3619,
  3621,
  3628,
  3634,
  3637,
  3638,
  3656,
  3665,
  3696,
  3708,
  3710,
  3721,
  3722,
  3729,
  3737,
  3743,
  3746,
  3748,
  3750,
  3751,
  3753,
  0,
  1868,
  0,
  1872,
  0
]), JR = new Uint32Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]), VR = new Uint32Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  32786,
  0,
  0,
  0,
  0,
  0,
  33298,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function zp(t, e) {
  return _R(t, e) ? -1 : 1;
}
function _R(t, e) {
  const r = [YR, JR, VR];
  let n = 0, s = 0, i = 0;
  for (; n < r.length; ) {
    if (n === r.length - 1 && s !== i)
      return s > i;
    const o = s < t.length ? r[n][t[s].charCodeAt(0)] : 1, a = i < e.length ? r[n][e[i].charCodeAt(0)] : 1;
    if (o === 1 && a === 1)
      s = 0, i = 0, ++n;
    else if (o === a)
      ++s, ++i;
    else if (o === 0)
      ++s;
    else if (a === 0)
      ++i;
    else
      return o < a;
  }
  return !1;
}
class WR extends Hp {
  /**
   * Reference to StorageSharedKeyCredential which generates StorageSharedKeyCredentialPolicy
   */
  factory;
  /**
   * Creates an instance of StorageSharedKeyCredentialPolicy.
   * @param nextPolicy -
   * @param options -
   * @param factory -
   */
  constructor(e, r, n) {
    super(e, r), this.factory = n;
  }
  /**
   * Signs request.
   *
   * @param request -
   */
  signRequest(e) {
    e.headers.set(Ge.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString()), e.body && (typeof e.body == "string" || e.body !== void 0) && e.body.length > 0 && e.headers.set(Ge.CONTENT_LENGTH, Buffer.byteLength(e.body));
    const r = [
      e.method.toUpperCase(),
      this.getHeaderValueToSign(e, Ge.CONTENT_LANGUAGE),
      this.getHeaderValueToSign(e, Ge.CONTENT_ENCODING),
      this.getHeaderValueToSign(e, Ge.CONTENT_LENGTH),
      this.getHeaderValueToSign(e, Ge.CONTENT_MD5),
      this.getHeaderValueToSign(e, Ge.CONTENT_TYPE),
      this.getHeaderValueToSign(e, Ge.DATE),
      this.getHeaderValueToSign(e, Ge.IF_MODIFIED_SINCE),
      this.getHeaderValueToSign(e, Ge.IF_MATCH),
      this.getHeaderValueToSign(e, Ge.IF_NONE_MATCH),
      this.getHeaderValueToSign(e, Ge.IF_UNMODIFIED_SINCE),
      this.getHeaderValueToSign(e, Ge.RANGE)
    ].join(`
`) + `
` + this.getCanonicalizedHeadersString(e) + this.getCanonicalizedResourceString(e), n = this.factory.computeHMACSHA256(r);
    return e.headers.set(Ge.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${n}`), e;
  }
  /**
   * Retrieve header value according to shared key sign rules.
   * @see https://learn.microsoft.com/rest/api/storageservices/authenticate-with-shared-key
   *
   * @param request -
   * @param headerName -
   */
  getHeaderValueToSign(e, r) {
    const n = e.headers.get(r);
    return !n || r === Ge.CONTENT_LENGTH && n === "0" ? "" : n;
  }
  /**
   * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
   * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
   * 2. Convert each HTTP header name to lowercase.
   * 3. Sort the headers lexicographically by header name, in ascending order.
   *    Each header may appear only once in the string.
   * 4. Replace any linear whitespace in the header value with a single space.
   * 5. Trim any whitespace around the colon in the header.
   * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
   *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
   *
   * @param request -
   */
  getCanonicalizedHeadersString(e) {
    let r = e.headers.headersArray().filter((s) => s.name.toLowerCase().startsWith(Ge.PREFIX_FOR_STORAGE));
    r.sort((s, i) => zp(s.name.toLowerCase(), i.name.toLowerCase())), r = r.filter((s, i, o) => !(i > 0 && s.name.toLowerCase() === o[i - 1].name.toLowerCase()));
    let n = "";
    return r.forEach((s) => {
      n += `${s.name.toLowerCase().trimRight()}:${s.value.trimLeft()}
`;
    }), n;
  }
  /**
   * Retrieves the webResource canonicalized resource string.
   *
   * @param request -
   */
  getCanonicalizedResourceString(e) {
    const r = Lp(e.url) || "/";
    let n = "";
    n += `/${this.factory.accountName}${r}`;
    const s = Up(e.url), i = {};
    if (s) {
      const o = [];
      for (const a in s)
        if (Object.prototype.hasOwnProperty.call(s, a)) {
          const A = a.toLowerCase();
          i[A] = s[a], o.push(A);
        }
      o.sort();
      for (const a of o)
        n += `
${a}:${decodeURIComponent(i[a])}`;
    }
    return n;
  }
}
class sr extends Op {
  /**
   * Azure Storage account name; readonly.
   */
  accountName;
  /**
   * Azure Storage account key; readonly.
   */
  accountKey;
  /**
   * Creates an instance of StorageSharedKeyCredential.
   * @param accountName -
   * @param accountKey -
   */
  constructor(e, r) {
    super(), this.accountName = e, this.accountKey = Buffer.from(r, "base64");
  }
  /**
   * Creates a StorageSharedKeyCredentialPolicy object.
   *
   * @param nextPolicy -
   * @param options -
   */
  create(e, r) {
    return new WR(e, r, this);
  }
  /**
   * Generates a hash signature for an HTTP request or for a SAS.
   *
   * @param stringToSign -
   */
  computeHMACSHA256(e) {
    return pl("sha256", this.accountKey).update(e, "utf8").digest("base64");
  }
}
const vt = Co("storage-common");
var Kr;
(function(t) {
  t[t.EXPONENTIAL = 0] = "EXPONENTIAL", t[t.FIXED = 1] = "FIXED";
})(Kr || (Kr = {}));
const Jr = {
  maxRetryDelayInMs: 120 * 1e3,
  maxTries: 4,
  retryDelayInMs: 4 * 1e3,
  retryPolicyType: Kr.EXPONENTIAL,
  secondaryHost: "",
  tryTimeoutInMs: void 0
  // Use server side default timeout strategy
}, $R = new ii("The operation was aborted.");
class XR extends Wl {
  /**
   * RetryOptions.
   */
  retryOptions;
  /**
   * Creates an instance of RetryPolicy.
   *
   * @param nextPolicy -
   * @param options -
   * @param retryOptions -
   */
  constructor(e, r, n = Jr) {
    super(e, r), this.retryOptions = {
      retryPolicyType: n.retryPolicyType ? n.retryPolicyType : Jr.retryPolicyType,
      maxTries: n.maxTries && n.maxTries >= 1 ? Math.floor(n.maxTries) : Jr.maxTries,
      tryTimeoutInMs: n.tryTimeoutInMs && n.tryTimeoutInMs >= 0 ? n.tryTimeoutInMs : Jr.tryTimeoutInMs,
      retryDelayInMs: n.retryDelayInMs && n.retryDelayInMs >= 0 ? Math.min(n.retryDelayInMs, n.maxRetryDelayInMs ? n.maxRetryDelayInMs : Jr.maxRetryDelayInMs) : Jr.retryDelayInMs,
      maxRetryDelayInMs: n.maxRetryDelayInMs && n.maxRetryDelayInMs >= 0 ? n.maxRetryDelayInMs : Jr.maxRetryDelayInMs,
      secondaryHost: n.secondaryHost ? n.secondaryHost : Jr.secondaryHost
    };
  }
  /**
   * Sends request.
   *
   * @param request -
   */
  async sendRequest(e) {
    return this.attemptSendRequest(e, !1, 1);
  }
  /**
   * Decide and perform next retry. Won't mutate request parameter.
   *
   * @param request -
   * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
   *                                   the resource was not found. This may be due to replication delay. So, in this
   *                                   case, we'll never try the secondary again for this operation.
   * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
   *                                   the attempt will be performed by this method call.
   */
  async attemptSendRequest(e, r, n) {
    const s = e.clone(), i = r || !this.retryOptions.secondaryHost || !(e.method === "GET" || e.method === "HEAD" || e.method === "OPTIONS") || n % 2 === 1;
    i || (s.url = vp(s.url, this.retryOptions.secondaryHost)), this.retryOptions.tryTimeoutInMs && (s.url = No(s.url, Qo.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString()));
    let o;
    try {
      if (vt.info(`RetryPolicy: =====> Try=${n} ${i ? "Primary" : "Secondary"}`), o = await this._nextPolicy.sendRequest(s), !this.shouldRetry(i, n, o))
        return o;
      r = r || !i && o.status === 404;
    } catch (a) {
      if (vt.error(`RetryPolicy: Caught error, message: ${a.message}, code: ${a.code}`), !this.shouldRetry(i, n, o, a))
        throw a;
    }
    return await this.delay(i, n, e.abortSignal), this.attemptSendRequest(e, r, ++n);
  }
  /**
   * Decide whether to retry according to last HTTP response and retry counters.
   *
   * @param isPrimaryRetry -
   * @param attempt -
   * @param response -
   * @param err -
   */
  shouldRetry(e, r, n, s) {
    if (r >= this.retryOptions.maxTries)
      return vt.info(`RetryPolicy: Attempt(s) ${r} >= maxTries ${this.retryOptions.maxTries}, no further try.`), !1;
    const i = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR"
      // For default xhr based http client provided in ms-rest-js
    ];
    if (s) {
      for (const o of i)
        if (s.name.toUpperCase().includes(o) || s.message.toUpperCase().includes(o) || s.code && s.code.toString().toUpperCase() === o)
          return vt.info(`RetryPolicy: Network error ${o} found, will retry.`), !0;
    }
    if (n || s) {
      const o = n ? n.status : s ? s.statusCode : 0;
      if (!e && o === 404)
        return vt.info("RetryPolicy: Secondary access with 404, will retry."), !0;
      if (o === 503 || o === 500)
        return vt.info(`RetryPolicy: Will retry for status code ${o}.`), !0;
    }
    if (n && n?.status >= 400) {
      const o = n.headers.get(Ge.X_MS_CopySourceErrorCode);
      if (o !== void 0)
        switch (o) {
          case "InternalError":
          case "OperationTimedOut":
          case "ServerBusy":
            return !0;
        }
    }
    return s?.code === "PARSE_ERROR" && s?.message.startsWith('Error "Error: Unclosed root tag') ? (vt.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0) : !1;
  }
  /**
   * Delay a calculated time between retries.
   *
   * @param isPrimaryRetry -
   * @param attempt -
   * @param abortSignal -
   */
  async delay(e, r, n) {
    let s = 0;
    if (e)
      switch (this.retryOptions.retryPolicyType) {
        case Kr.EXPONENTIAL:
          s = Math.min((Math.pow(2, r - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
          break;
        case Kr.FIXED:
          s = this.retryOptions.retryDelayInMs;
          break;
      }
    else
      s = Math.random() * 1e3;
    return vt.info(`RetryPolicy: Delay for ${s}ms`), Pp(s, n, $R);
  }
}
class ZR {
  retryOptions;
  /**
   * Creates an instance of StorageRetryPolicyFactory.
   * @param retryOptions -
   */
  constructor(e) {
    this.retryOptions = e;
  }
  /**
   * Creates a StorageRetryPolicy object.
   *
   * @param nextPolicy -
   * @param options -
   */
  create(e, r) {
    return new XR(e, r, this.retryOptions);
  }
}
const KR = "storageBrowserPolicy";
function jR() {
  return {
    name: KR,
    async sendRequest(t, e) {
      return Rt || ((t.method === "GET" || t.method === "HEAD") && (t.url = No(t.url, Qo.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString())), t.headers.delete(Ge.COOKIE), t.headers.delete(Ge.CONTENT_LENGTH)), e(t);
    }
  };
}
const eS = "StorageCorrectContentLengthPolicy";
function tS() {
  function t(e) {
    e.body && (typeof e.body == "string" || Buffer.isBuffer(e.body)) && e.body.length > 0 && e.headers.set(Ge.CONTENT_LENGTH, Buffer.byteLength(e.body));
  }
  return {
    name: eS,
    async sendRequest(e, r) {
      return t(e), r(e);
    }
  };
}
const rS = "storageRetryPolicy", zn = {
  maxRetryDelayInMs: 120 * 1e3,
  maxTries: 4,
  retryDelayInMs: 4 * 1e3,
  retryPolicyType: Kr.EXPONENTIAL,
  secondaryHost: "",
  tryTimeoutInMs: void 0
  // Use server side default timeout strategy
}, nS = [
  "ETIMEDOUT",
  "ESOCKETTIMEDOUT",
  "ECONNREFUSED",
  "ECONNRESET",
  "ENOENT",
  "ENOTFOUND",
  "TIMEOUT",
  "EPIPE",
  "REQUEST_SEND_ERROR"
], sS = new ii("The operation was aborted.");
function iS(t = {}) {
  const e = t.retryPolicyType ?? zn.retryPolicyType, r = t.maxTries ?? zn.maxTries, n = t.retryDelayInMs ?? zn.retryDelayInMs, s = t.maxRetryDelayInMs ?? zn.maxRetryDelayInMs, i = t.secondaryHost ?? zn.secondaryHost, o = t.tryTimeoutInMs ?? zn.tryTimeoutInMs;
  function a({ isPrimaryRetry: c, attempt: l, response: d, error: u }) {
    if (l >= r)
      return vt.info(`RetryPolicy: Attempt(s) ${l} >= maxTries ${r}, no further try.`), !1;
    if (u) {
      for (const m of nS)
        if (u.name.toUpperCase().includes(m) || u.message.toUpperCase().includes(m) || u.code && u.code.toString().toUpperCase() === m)
          return vt.info(`RetryPolicy: Network error ${m} found, will retry.`), !0;
      if (u?.code === "PARSE_ERROR" && u?.message.startsWith('Error "Error: Unclosed root tag'))
        return vt.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0;
    }
    if (d || u) {
      const m = d?.status ?? u?.statusCode ?? 0;
      if (!c && m === 404)
        return vt.info("RetryPolicy: Secondary access with 404, will retry."), !0;
      if (m === 503 || m === 500)
        return vt.info(`RetryPolicy: Will retry for status code ${m}.`), !0;
    }
    if (d && d?.status >= 400) {
      const m = d.headers.get(Ge.X_MS_CopySourceErrorCode);
      if (m !== void 0)
        switch (m) {
          case "InternalError":
          case "OperationTimedOut":
          case "ServerBusy":
            return !0;
        }
    }
    return !1;
  }
  function A(c, l) {
    let d = 0;
    if (c)
      switch (e) {
        case Kr.EXPONENTIAL:
          d = Math.min((Math.pow(2, l - 1) - 1) * n, s);
          break;
        case Kr.FIXED:
          d = n;
          break;
      }
    else
      d = Math.random() * 1e3;
    return vt.info(`RetryPolicy: Delay for ${d}ms`), d;
  }
  return {
    name: rS,
    async sendRequest(c, l) {
      o && (c.url = No(c.url, Qo.Parameters.TIMEOUT, String(Math.floor(o / 1e3))));
      const d = c.url, u = i ? vp(c.url, i) : void 0;
      let m = !1, h = 1, f = !0, p, y;
      for (; f; ) {
        const w = m || !u || !["GET", "HEAD", "OPTIONS"].includes(c.method) || h % 2 === 1;
        c.url = w ? d : u, p = void 0, y = void 0;
        try {
          vt.info(`RetryPolicy: =====> Try=${h} ${w ? "Primary" : "Secondary"}`), p = await l(c), m = m || !w && p.status === 404;
        } catch (R) {
          if (Jl(R))
            vt.error(`RetryPolicy: Caught error, message: ${R.message}, code: ${R.code}`), y = R;
          else
            throw vt.error(`RetryPolicy: Caught error, message: ${oi(R)}`), R;
        }
        f = a({ isPrimaryRetry: w, attempt: h, response: p, error: y }), f && await Pp(A(w, h), c.abortSignal, sS), h++;
      }
      if (p)
        return p;
      throw y ?? new zs("RetryPolicy failed without known error.");
    }
  };
}
const oS = "storageSharedKeyCredentialPolicy";
function aS(t) {
  function e(i) {
    i.headers.set(Ge.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString()), i.body && (typeof i.body == "string" || Buffer.isBuffer(i.body)) && i.body.length > 0 && i.headers.set(Ge.CONTENT_LENGTH, Buffer.byteLength(i.body));
    const o = [
      i.method.toUpperCase(),
      r(i, Ge.CONTENT_LANGUAGE),
      r(i, Ge.CONTENT_ENCODING),
      r(i, Ge.CONTENT_LENGTH),
      r(i, Ge.CONTENT_MD5),
      r(i, Ge.CONTENT_TYPE),
      r(i, Ge.DATE),
      r(i, Ge.IF_MODIFIED_SINCE),
      r(i, Ge.IF_MATCH),
      r(i, Ge.IF_NONE_MATCH),
      r(i, Ge.IF_UNMODIFIED_SINCE),
      r(i, Ge.RANGE)
    ].join(`
`) + `
` + n(i) + s(i), a = pl("sha256", t.accountKey).update(o, "utf8").digest("base64");
    i.headers.set(Ge.AUTHORIZATION, `SharedKey ${t.accountName}:${a}`);
  }
  function r(i, o) {
    const a = i.headers.get(o);
    return !a || o === Ge.CONTENT_LENGTH && a === "0" ? "" : a;
  }
  function n(i) {
    let o = [];
    for (const [A, c] of i.headers)
      A.toLowerCase().startsWith(Ge.PREFIX_FOR_STORAGE) && o.push({ name: A, value: c });
    o.sort((A, c) => zp(A.name.toLowerCase(), c.name.toLowerCase())), o = o.filter((A, c, l) => !(c > 0 && A.name.toLowerCase() === l[c - 1].name.toLowerCase()));
    let a = "";
    return o.forEach((A) => {
      a += `${A.name.toLowerCase().trimRight()}:${A.value.trimLeft()}
`;
    }), a;
  }
  function s(i) {
    const o = Lp(i.url) || "/";
    let a = "";
    a += `/${t.accountName}${o}`;
    const A = Up(i.url), c = {};
    if (A) {
      const l = [];
      for (const d in A)
        if (Object.prototype.hasOwnProperty.call(A, d)) {
          const u = d.toLowerCase();
          c[u] = A[d], l.push(u);
        }
      l.sort();
      for (const d of l)
        a += `
${d}:${decodeURIComponent(c[d])}`;
    }
    return a;
  }
  return {
    name: oS,
    async sendRequest(i, o) {
      return e(i), o(i);
    }
  };
}
const AS = "storageRequestFailureDetailsParserPolicy";
function cS() {
  return {
    name: AS,
    async sendRequest(t, e) {
      try {
        return await e(t);
      } catch (r) {
        throw typeof r == "object" && r !== null && r.response && r.response.parsedBody && r.response.parsedBody.code === "InvalidHeaderValue" && r.response.parsedBody.HeaderName === "x-ms-version" && (r.message = `The provided service version is not enabled on this storage account. Please see https://learn.microsoft.com/rest/api/storageservices/versioning-for-the-azure-storage-services for additional information.
`), r;
      }
    }
  };
}
class lS {
  /**
   * Azure Storage account name; readonly.
   */
  accountName;
  /**
   * Azure Storage user delegation key; readonly.
   */
  userDelegationKey;
  /**
   * Key value in Buffer type.
   */
  key;
  /**
   * Creates an instance of UserDelegationKeyCredential.
   * @param accountName -
   * @param userDelegationKey -
   */
  constructor(e, r) {
    this.accountName = e, this.userDelegationKey = r, this.key = Buffer.from(r.value, "base64");
  }
  /**
   * Generates a hash signature for an HTTP request or for a SAS.
   *
   * @param stringToSign -
   */
  computeHMACSHA256(e) {
    return pl("sha256", this.key).update(e, "utf8").digest("base64");
  }
}
const qp = "12.31.0", Gp = "2026-02-06", Tc = 256 * 1024 * 1024, Fc = 4e3 * 1024 * 1024, xi = 5e4, dS = 8 * 1024 * 1024, jc = 4 * 1024 * 1024, uS = 5, mS = 100 * 1e3, hS = "https://storage.azure.com/.default", Cn = {
  Parameters: {
    SNAPSHOT: "snapshot",
    VERSIONID: "versionid"
  }
}, wr = "", Yp = "*", gS = "AES256", fS = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;", pS = [
  "Access-Control-Allow-Origin",
  "Cache-Control",
  "Content-Length",
  "Content-Type",
  "Date",
  "Request-Id",
  "traceparent",
  "Transfer-Encoding",
  "User-Agent",
  "x-ms-client-request-id",
  "x-ms-date",
  "x-ms-error-code",
  "x-ms-request-id",
  "x-ms-return-client-request-id",
  "x-ms-version",
  "Accept-Ranges",
  "Content-Disposition",
  "Content-Encoding",
  "Content-Language",
  "Content-MD5",
  "Content-Range",
  "ETag",
  "Last-Modified",
  "Server",
  "Vary",
  "x-ms-content-crc64",
  "x-ms-copy-action",
  "x-ms-copy-completion-time",
  "x-ms-copy-id",
  "x-ms-copy-progress",
  "x-ms-copy-status",
  "x-ms-has-immutability-policy",
  "x-ms-has-legal-hold",
  "x-ms-lease-state",
  "x-ms-lease-status",
  "x-ms-range",
  "x-ms-request-server-encrypted",
  "x-ms-server-encrypted",
  "x-ms-snapshot",
  "x-ms-source-range",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "x-ms-access-tier",
  "x-ms-access-tier-change-time",
  "x-ms-access-tier-inferred",
  "x-ms-account-kind",
  "x-ms-archive-status",
  "x-ms-blob-append-offset",
  "x-ms-blob-cache-control",
  "x-ms-blob-committed-block-count",
  "x-ms-blob-condition-appendpos",
  "x-ms-blob-condition-maxsize",
  "x-ms-blob-content-disposition",
  "x-ms-blob-content-encoding",
  "x-ms-blob-content-language",
  "x-ms-blob-content-length",
  "x-ms-blob-content-md5",
  "x-ms-blob-content-type",
  "x-ms-blob-public-access",
  "x-ms-blob-sequence-number",
  "x-ms-blob-type",
  "x-ms-copy-destination-snapshot",
  "x-ms-creation-time",
  "x-ms-default-encryption-scope",
  "x-ms-delete-snapshots",
  "x-ms-delete-type-permanent",
  "x-ms-deny-encryption-scope-override",
  "x-ms-encryption-algorithm",
  "x-ms-if-sequence-number-eq",
  "x-ms-if-sequence-number-le",
  "x-ms-if-sequence-number-lt",
  "x-ms-incremental-copy",
  "x-ms-lease-action",
  "x-ms-lease-break-period",
  "x-ms-lease-duration",
  "x-ms-lease-id",
  "x-ms-lease-time",
  "x-ms-page-write",
  "x-ms-proposed-lease-id",
  "x-ms-range-get-content-md5",
  "x-ms-rehydrate-priority",
  "x-ms-sequence-number-action",
  "x-ms-sku-name",
  "x-ms-source-content-md5",
  "x-ms-source-if-match",
  "x-ms-source-if-modified-since",
  "x-ms-source-if-none-match",
  "x-ms-source-if-unmodified-since",
  "x-ms-tag-count",
  "x-ms-encryption-key-sha256",
  "x-ms-copy-source-error-code",
  "x-ms-copy-source-status-code",
  "x-ms-if-tags",
  "x-ms-source-if-tags"
], ES = [
  "comp",
  "maxresults",
  "rscc",
  "rscd",
  "rsce",
  "rscl",
  "rsct",
  "se",
  "si",
  "sip",
  "sp",
  "spr",
  "sr",
  "srt",
  "ss",
  "st",
  "sv",
  "include",
  "marker",
  "prefix",
  "copyid",
  "restype",
  "blockid",
  "blocklisttype",
  "delimiter",
  "prevsnapshot",
  "ske",
  "skoid",
  "sks",
  "skt",
  "sktid",
  "skv",
  "snapshot"
], CS = "BlobUsesCustomerSpecifiedEncryption", BS = "BlobDoesNotUseCustomerSpecifiedEncryption", IS = [
  "10000",
  "10001",
  "10002",
  "10003",
  "10004",
  "10100",
  "10101",
  "10102",
  "10103",
  "10104",
  "11000",
  "11001",
  "11002",
  "11003",
  "11004",
  "11100",
  "11101",
  "11102",
  "11103",
  "11104"
];
function wo(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = t;
  return Array.isArray(e.factories) && typeof e.options == "object" && typeof e.toServiceClientOptions == "function";
}
class yS {
  /**
   * A list of chained request policy factories.
   */
  factories;
  /**
   * Configures pipeline logger and HTTP client.
   */
  options;
  /**
   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
   *
   * @param factories -
   * @param options -
   */
  constructor(e, r = {}) {
    this.factories = e, this.options = r;
  }
  /**
   * Transfer Pipeline object to ServiceClientOptions object which is required by
   * ServiceClient constructor.
   *
   * @returns The ServiceClientOptions object from this Pipeline.
   */
  toServiceClientOptions() {
    return {
      httpClient: this.options.httpClient,
      requestPolicyFactories: this.factories
    };
  }
}
function Pt(t, e = {}) {
  t || (t = new Vt());
  const r = new yS([], e);
  return r._credential = t, r;
}
function QS(t) {
  const e = [
    wS,
    Vp,
    bS,
    xS,
    RS,
    SS,
    kS
  ];
  if (t.factories.length) {
    const r = t.factories.filter((n) => !e.some((s) => s(n)));
    if (r.length) {
      const n = r.some((s) => DS(s));
      return {
        wrappedPolicies: Mx(r),
        afterRetry: n
      };
    }
  }
}
function NS(t) {
  const { httpClient: e, ...r } = t.options;
  let n = t._coreHttpClient;
  n || (n = e ? Tx(e) : OR(), t._coreHttpClient = n);
  let s = t._corePipeline;
  if (!s) {
    const i = `azsdk-js-azure-storage-blob/${qp}`, o = r.userAgentOptions && r.userAgentOptions.userAgentPrefix ? `${r.userAgentOptions.userAgentPrefix} ${i}` : `${i}`;
    s = Ep({
      ...r,
      loggingOptions: {
        additionalAllowedHeaderNames: pS,
        additionalAllowedQueryParameters: ES,
        logger: LR.info
      },
      userAgentOptions: {
        userAgentPrefix: o
      },
      serializationOptions: {
        stringifyXML: FR,
        serializerOptions: {
          xml: {
            // Use customized XML char key of "#" so we can deserialize metadata
            // with "_" key
            xmlCharKey: "#"
          }
        }
      },
      deserializationOptions: {
        parseXML: vR,
        serializerOptions: {
          xml: {
            // Use customized XML char key of "#" so we can deserialize metadata
            // with "_" key
            xmlCharKey: "#"
          }
        }
      }
    }), s.removePolicy({ phase: "Retry" }), s.removePolicy({ name: H0 }), s.addPolicy(tS()), s.addPolicy(iS(r.retryOptions), { phase: "Retry" }), s.addPolicy(cS()), s.addPolicy(jR());
    const a = QS(t);
    a && s.addPolicy(a.wrappedPolicies, a.afterRetry ? { afterPhase: "Retry" } : void 0);
    const A = Jp(t);
    kn(A) ? s.addPolicy(cp({
      credential: A,
      scopes: r.audience ?? hS,
      challengeCallbacks: { authorizeRequestOnChallenge: yx }
    }), { phase: "Sign" }) : A instanceof sr && s.addPolicy(aS({
      accountName: A.accountName,
      accountKey: A.accountKey
    }), { phase: "Sign" }), t._corePipeline = s;
  }
  return {
    ...r,
    allowInsecureConnection: !0,
    httpClient: n,
    pipeline: s
  };
}
function Jp(t) {
  if (t._credential)
    return t._credential;
  let e = new Vt();
  for (const r of t.factories)
    if (kn(r.credential))
      e = r.credential;
    else if (Vp(r))
      return r;
  return e;
}
function Vp(t) {
  return t instanceof sr ? !0 : t.constructor.name === "StorageSharedKeyCredential";
}
function wS(t) {
  return t instanceof Vt ? !0 : t.constructor.name === "AnonymousCredential";
}
function bS(t) {
  return kn(t.credential);
}
function xS(t) {
  return t instanceof qR ? !0 : t.constructor.name === "StorageBrowserPolicyFactory";
}
function RS(t) {
  return t instanceof ZR ? !0 : t.constructor.name === "StorageRetryPolicyFactory";
}
function SS(t) {
  return t.constructor.name === "TelemetryPolicyFactory";
}
function DS(t) {
  return t.constructor.name === "InjectorPolicyFactory";
}
function kS(t) {
  const e = [
    "GenerateClientRequestIdPolicy",
    "TracingPolicy",
    "LogPolicy",
    "ProxyPolicy",
    "DisableResponseDecompressionPolicy",
    "KeepAlivePolicy",
    "DeserializationPolicy"
  ], r = {
    sendRequest: async (o) => ({
      request: o,
      headers: o.headers.clone(),
      status: 500
    })
  }, n = {
    log(o, a) {
    },
    shouldLog(o) {
      return !1;
    }
  }, i = t.create(r, n).constructor.name;
  return e.some((o) => i.startsWith(o));
}
var gg;
(function(t) {
  t.AES256 = "AES256";
})(gg || (gg = {}));
var fg;
(function(t) {
  t.Backup = "backup";
})(fg || (fg = {}));
var pg;
(function(t) {
  t.NeverExpire = "NeverExpire", t.RelativeToCreation = "RelativeToCreation", t.RelativeToNow = "RelativeToNow", t.Absolute = "Absolute";
})(pg || (pg = {}));
var Eg;
(function(t) {
  t.AccountAlreadyExists = "AccountAlreadyExists", t.AccountBeingCreated = "AccountBeingCreated", t.AccountIsDisabled = "AccountIsDisabled", t.AuthenticationFailed = "AuthenticationFailed", t.AuthorizationFailure = "AuthorizationFailure", t.ConditionHeadersNotSupported = "ConditionHeadersNotSupported", t.ConditionNotMet = "ConditionNotMet", t.EmptyMetadataKey = "EmptyMetadataKey", t.InsufficientAccountPermissions = "InsufficientAccountPermissions", t.InternalError = "InternalError", t.InvalidAuthenticationInfo = "InvalidAuthenticationInfo", t.InvalidHeaderValue = "InvalidHeaderValue", t.InvalidHttpVerb = "InvalidHttpVerb", t.InvalidInput = "InvalidInput", t.InvalidMd5 = "InvalidMd5", t.InvalidMetadata = "InvalidMetadata", t.InvalidQueryParameterValue = "InvalidQueryParameterValue", t.InvalidRange = "InvalidRange", t.InvalidResourceName = "InvalidResourceName", t.InvalidUri = "InvalidUri", t.InvalidXmlDocument = "InvalidXmlDocument", t.InvalidXmlNodeValue = "InvalidXmlNodeValue", t.Md5Mismatch = "Md5Mismatch", t.MetadataTooLarge = "MetadataTooLarge", t.MissingContentLengthHeader = "MissingContentLengthHeader", t.MissingRequiredQueryParameter = "MissingRequiredQueryParameter", t.MissingRequiredHeader = "MissingRequiredHeader", t.MissingRequiredXmlNode = "MissingRequiredXmlNode", t.MultipleConditionHeadersNotSupported = "MultipleConditionHeadersNotSupported", t.OperationTimedOut = "OperationTimedOut", t.OutOfRangeInput = "OutOfRangeInput", t.OutOfRangeQueryParameterValue = "OutOfRangeQueryParameterValue", t.RequestBodyTooLarge = "RequestBodyTooLarge", t.ResourceTypeMismatch = "ResourceTypeMismatch", t.RequestUrlFailedToParse = "RequestUrlFailedToParse", t.ResourceAlreadyExists = "ResourceAlreadyExists", t.ResourceNotFound = "ResourceNotFound", t.ServerBusy = "ServerBusy", t.UnsupportedHeader = "UnsupportedHeader", t.UnsupportedXmlNode = "UnsupportedXmlNode", t.UnsupportedQueryParameter = "UnsupportedQueryParameter", t.UnsupportedHttpVerb = "UnsupportedHttpVerb", t.AppendPositionConditionNotMet = "AppendPositionConditionNotMet", t.BlobAlreadyExists = "BlobAlreadyExists", t.BlobImmutableDueToPolicy = "BlobImmutableDueToPolicy", t.BlobNotFound = "BlobNotFound", t.BlobOverwritten = "BlobOverwritten", t.BlobTierInadequateForContentLength = "BlobTierInadequateForContentLength", t.BlobUsesCustomerSpecifiedEncryption = "BlobUsesCustomerSpecifiedEncryption", t.BlockCountExceedsLimit = "BlockCountExceedsLimit", t.BlockListTooLong = "BlockListTooLong", t.CannotChangeToLowerTier = "CannotChangeToLowerTier", t.CannotVerifyCopySource = "CannotVerifyCopySource", t.ContainerAlreadyExists = "ContainerAlreadyExists", t.ContainerBeingDeleted = "ContainerBeingDeleted", t.ContainerDisabled = "ContainerDisabled", t.ContainerNotFound = "ContainerNotFound", t.ContentLengthLargerThanTierLimit = "ContentLengthLargerThanTierLimit", t.CopyAcrossAccountsNotSupported = "CopyAcrossAccountsNotSupported", t.CopyIdMismatch = "CopyIdMismatch", t.FeatureVersionMismatch = "FeatureVersionMismatch", t.IncrementalCopyBlobMismatch = "IncrementalCopyBlobMismatch", t.IncrementalCopyOfEarlierVersionSnapshotNotAllowed = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed", t.IncrementalCopySourceMustBeSnapshot = "IncrementalCopySourceMustBeSnapshot", t.InfiniteLeaseDurationRequired = "InfiniteLeaseDurationRequired", t.InvalidBlobOrBlock = "InvalidBlobOrBlock", t.InvalidBlobTier = "InvalidBlobTier", t.InvalidBlobType = "InvalidBlobType", t.InvalidBlockId = "InvalidBlockId", t.InvalidBlockList = "InvalidBlockList", t.InvalidOperation = "InvalidOperation", t.InvalidPageRange = "InvalidPageRange", t.InvalidSourceBlobType = "InvalidSourceBlobType", t.InvalidSourceBlobUrl = "InvalidSourceBlobUrl", t.InvalidVersionForPageBlobOperation = "InvalidVersionForPageBlobOperation", t.LeaseAlreadyPresent = "LeaseAlreadyPresent", t.LeaseAlreadyBroken = "LeaseAlreadyBroken", t.LeaseIdMismatchWithBlobOperation = "LeaseIdMismatchWithBlobOperation", t.LeaseIdMismatchWithContainerOperation = "LeaseIdMismatchWithContainerOperation", t.LeaseIdMismatchWithLeaseOperation = "LeaseIdMismatchWithLeaseOperation", t.LeaseIdMissing = "LeaseIdMissing", t.LeaseIsBreakingAndCannotBeAcquired = "LeaseIsBreakingAndCannotBeAcquired", t.LeaseIsBreakingAndCannotBeChanged = "LeaseIsBreakingAndCannotBeChanged", t.LeaseIsBrokenAndCannotBeRenewed = "LeaseIsBrokenAndCannotBeRenewed", t.LeaseLost = "LeaseLost", t.LeaseNotPresentWithBlobOperation = "LeaseNotPresentWithBlobOperation", t.LeaseNotPresentWithContainerOperation = "LeaseNotPresentWithContainerOperation", t.LeaseNotPresentWithLeaseOperation = "LeaseNotPresentWithLeaseOperation", t.MaxBlobSizeConditionNotMet = "MaxBlobSizeConditionNotMet", t.NoAuthenticationInformation = "NoAuthenticationInformation", t.NoPendingCopyOperation = "NoPendingCopyOperation", t.OperationNotAllowedOnIncrementalCopyBlob = "OperationNotAllowedOnIncrementalCopyBlob", t.PendingCopyOperation = "PendingCopyOperation", t.PreviousSnapshotCannotBeNewer = "PreviousSnapshotCannotBeNewer", t.PreviousSnapshotNotFound = "PreviousSnapshotNotFound", t.PreviousSnapshotOperationNotSupported = "PreviousSnapshotOperationNotSupported", t.SequenceNumberConditionNotMet = "SequenceNumberConditionNotMet", t.SequenceNumberIncrementTooLarge = "SequenceNumberIncrementTooLarge", t.SnapshotCountExceeded = "SnapshotCountExceeded", t.SnapshotOperationRateExceeded = "SnapshotOperationRateExceeded", t.SnapshotsPresent = "SnapshotsPresent", t.SourceConditionNotMet = "SourceConditionNotMet", t.SystemInUse = "SystemInUse", t.TargetConditionNotMet = "TargetConditionNotMet", t.UnauthorizedBlobOverwrite = "UnauthorizedBlobOverwrite", t.BlobBeingRehydrated = "BlobBeingRehydrated", t.BlobArchived = "BlobArchived", t.BlobNotArchived = "BlobNotArchived", t.AuthorizationSourceIPMismatch = "AuthorizationSourceIPMismatch", t.AuthorizationProtocolMismatch = "AuthorizationProtocolMismatch", t.AuthorizationPermissionMismatch = "AuthorizationPermissionMismatch", t.AuthorizationServiceMismatch = "AuthorizationServiceMismatch", t.AuthorizationResourceTypeMismatch = "AuthorizationResourceTypeMismatch", t.BlobAccessTierNotSupportedForAccountType = "BlobAccessTierNotSupportedForAccountType";
})(Eg || (Eg = {}));
const $l = {
  serializedName: "BlobServiceProperties",
  xmlName: "StorageServiceProperties",
  type: {
    name: "Composite",
    className: "BlobServiceProperties",
    modelProperties: {
      blobAnalyticsLogging: {
        serializedName: "Logging",
        xmlName: "Logging",
        type: {
          name: "Composite",
          className: "Logging"
        }
      },
      hourMetrics: {
        serializedName: "HourMetrics",
        xmlName: "HourMetrics",
        type: {
          name: "Composite",
          className: "Metrics"
        }
      },
      minuteMetrics: {
        serializedName: "MinuteMetrics",
        xmlName: "MinuteMetrics",
        type: {
          name: "Composite",
          className: "Metrics"
        }
      },
      cors: {
        serializedName: "Cors",
        xmlName: "Cors",
        xmlIsWrapped: !0,
        xmlElementName: "CorsRule",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CorsRule"
            }
          }
        }
      },
      defaultServiceVersion: {
        serializedName: "DefaultServiceVersion",
        xmlName: "DefaultServiceVersion",
        type: {
          name: "String"
        }
      },
      deleteRetentionPolicy: {
        serializedName: "DeleteRetentionPolicy",
        xmlName: "DeleteRetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      },
      staticWebsite: {
        serializedName: "StaticWebsite",
        xmlName: "StaticWebsite",
        type: {
          name: "Composite",
          className: "StaticWebsite"
        }
      }
    }
  }
}, MS = {
  serializedName: "Logging",
  type: {
    name: "Composite",
    className: "Logging",
    modelProperties: {
      version: {
        serializedName: "Version",
        required: !0,
        xmlName: "Version",
        type: {
          name: "String"
        }
      },
      deleteProperty: {
        serializedName: "Delete",
        required: !0,
        xmlName: "Delete",
        type: {
          name: "Boolean"
        }
      },
      read: {
        serializedName: "Read",
        required: !0,
        xmlName: "Read",
        type: {
          name: "Boolean"
        }
      },
      write: {
        serializedName: "Write",
        required: !0,
        xmlName: "Write",
        type: {
          name: "Boolean"
        }
      },
      retentionPolicy: {
        serializedName: "RetentionPolicy",
        xmlName: "RetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      }
    }
  }
}, TS = {
  serializedName: "RetentionPolicy",
  type: {
    name: "Composite",
    className: "RetentionPolicy",
    modelProperties: {
      enabled: {
        serializedName: "Enabled",
        required: !0,
        xmlName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      days: {
        constraints: {
          InclusiveMinimum: 1
        },
        serializedName: "Days",
        xmlName: "Days",
        type: {
          name: "Number"
        }
      }
    }
  }
}, FS = {
  serializedName: "Metrics",
  type: {
    name: "Composite",
    className: "Metrics",
    modelProperties: {
      version: {
        serializedName: "Version",
        xmlName: "Version",
        type: {
          name: "String"
        }
      },
      enabled: {
        serializedName: "Enabled",
        required: !0,
        xmlName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      includeAPIs: {
        serializedName: "IncludeAPIs",
        xmlName: "IncludeAPIs",
        type: {
          name: "Boolean"
        }
      },
      retentionPolicy: {
        serializedName: "RetentionPolicy",
        xmlName: "RetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      }
    }
  }
}, vS = {
  serializedName: "CorsRule",
  type: {
    name: "Composite",
    className: "CorsRule",
    modelProperties: {
      allowedOrigins: {
        serializedName: "AllowedOrigins",
        required: !0,
        xmlName: "AllowedOrigins",
        type: {
          name: "String"
        }
      },
      allowedMethods: {
        serializedName: "AllowedMethods",
        required: !0,
        xmlName: "AllowedMethods",
        type: {
          name: "String"
        }
      },
      allowedHeaders: {
        serializedName: "AllowedHeaders",
        required: !0,
        xmlName: "AllowedHeaders",
        type: {
          name: "String"
        }
      },
      exposedHeaders: {
        serializedName: "ExposedHeaders",
        required: !0,
        xmlName: "ExposedHeaders",
        type: {
          name: "String"
        }
      },
      maxAgeInSeconds: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "MaxAgeInSeconds",
        required: !0,
        xmlName: "MaxAgeInSeconds",
        type: {
          name: "Number"
        }
      }
    }
  }
}, LS = {
  serializedName: "StaticWebsite",
  type: {
    name: "Composite",
    className: "StaticWebsite",
    modelProperties: {
      enabled: {
        serializedName: "Enabled",
        required: !0,
        xmlName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      indexDocument: {
        serializedName: "IndexDocument",
        xmlName: "IndexDocument",
        type: {
          name: "String"
        }
      },
      errorDocument404Path: {
        serializedName: "ErrorDocument404Path",
        xmlName: "ErrorDocument404Path",
        type: {
          name: "String"
        }
      },
      defaultIndexDocumentPath: {
        serializedName: "DefaultIndexDocumentPath",
        xmlName: "DefaultIndexDocumentPath",
        type: {
          name: "String"
        }
      }
    }
  }
}, Ie = {
  serializedName: "StorageError",
  type: {
    name: "Composite",
    className: "StorageError",
    modelProperties: {
      message: {
        serializedName: "Message",
        xmlName: "Message",
        type: {
          name: "String"
        }
      },
      copySourceStatusCode: {
        serializedName: "CopySourceStatusCode",
        xmlName: "CopySourceStatusCode",
        type: {
          name: "Number"
        }
      },
      copySourceErrorCode: {
        serializedName: "CopySourceErrorCode",
        xmlName: "CopySourceErrorCode",
        type: {
          name: "String"
        }
      },
      copySourceErrorMessage: {
        serializedName: "CopySourceErrorMessage",
        xmlName: "CopySourceErrorMessage",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "Code",
        xmlName: "Code",
        type: {
          name: "String"
        }
      },
      authenticationErrorDetail: {
        serializedName: "AuthenticationErrorDetail",
        xmlName: "AuthenticationErrorDetail",
        type: {
          name: "String"
        }
      }
    }
  }
}, _p = {
  serializedName: "BlobServiceStatistics",
  xmlName: "StorageServiceStats",
  type: {
    name: "Composite",
    className: "BlobServiceStatistics",
    modelProperties: {
      geoReplication: {
        serializedName: "GeoReplication",
        xmlName: "GeoReplication",
        type: {
          name: "Composite",
          className: "GeoReplication"
        }
      }
    }
  }
}, US = {
  serializedName: "GeoReplication",
  type: {
    name: "Composite",
    className: "GeoReplication",
    modelProperties: {
      status: {
        serializedName: "Status",
        required: !0,
        xmlName: "Status",
        type: {
          name: "Enum",
          allowedValues: ["live", "bootstrap", "unavailable"]
        }
      },
      lastSyncOn: {
        serializedName: "LastSyncTime",
        required: !0,
        xmlName: "LastSyncTime",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, Wp = {
  serializedName: "ListContainersSegmentResponse",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "ListContainersSegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      prefix: {
        serializedName: "Prefix",
        xmlName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        serializedName: "Marker",
        xmlName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        serializedName: "MaxResults",
        xmlName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      containerItems: {
        serializedName: "ContainerItems",
        required: !0,
        xmlName: "Containers",
        xmlIsWrapped: !0,
        xmlElementName: "Container",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ContainerItem"
            }
          }
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, PS = {
  serializedName: "ContainerItem",
  xmlName: "Container",
  type: {
    name: "Composite",
    className: "ContainerItem",
    modelProperties: {
      name: {
        serializedName: "Name",
        required: !0,
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      deleted: {
        serializedName: "Deleted",
        xmlName: "Deleted",
        type: {
          name: "Boolean"
        }
      },
      version: {
        serializedName: "Version",
        xmlName: "Version",
        type: {
          name: "String"
        }
      },
      properties: {
        serializedName: "Properties",
        xmlName: "Properties",
        type: {
          name: "Composite",
          className: "ContainerProperties"
        }
      },
      metadata: {
        serializedName: "Metadata",
        xmlName: "Metadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      }
    }
  }
}, HS = {
  serializedName: "ContainerProperties",
  type: {
    name: "Composite",
    className: "ContainerProperties",
    modelProperties: {
      lastModified: {
        serializedName: "Last-Modified",
        required: !0,
        xmlName: "Last-Modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "Etag",
        required: !0,
        xmlName: "Etag",
        type: {
          name: "String"
        }
      },
      leaseStatus: {
        serializedName: "LeaseStatus",
        xmlName: "LeaseStatus",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      leaseState: {
        serializedName: "LeaseState",
        xmlName: "LeaseState",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseDuration: {
        serializedName: "LeaseDuration",
        xmlName: "LeaseDuration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      publicAccess: {
        serializedName: "PublicAccess",
        xmlName: "PublicAccess",
        type: {
          name: "Enum",
          allowedValues: ["container", "blob"]
        }
      },
      hasImmutabilityPolicy: {
        serializedName: "HasImmutabilityPolicy",
        xmlName: "HasImmutabilityPolicy",
        type: {
          name: "Boolean"
        }
      },
      hasLegalHold: {
        serializedName: "HasLegalHold",
        xmlName: "HasLegalHold",
        type: {
          name: "Boolean"
        }
      },
      defaultEncryptionScope: {
        serializedName: "DefaultEncryptionScope",
        xmlName: "DefaultEncryptionScope",
        type: {
          name: "String"
        }
      },
      preventEncryptionScopeOverride: {
        serializedName: "DenyEncryptionScopeOverride",
        xmlName: "DenyEncryptionScopeOverride",
        type: {
          name: "Boolean"
        }
      },
      deletedOn: {
        serializedName: "DeletedTime",
        xmlName: "DeletedTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      remainingRetentionDays: {
        serializedName: "RemainingRetentionDays",
        xmlName: "RemainingRetentionDays",
        type: {
          name: "Number"
        }
      },
      isImmutableStorageWithVersioningEnabled: {
        serializedName: "ImmutableStorageWithVersioningEnabled",
        xmlName: "ImmutableStorageWithVersioningEnabled",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, $p = {
  serializedName: "KeyInfo",
  type: {
    name: "Composite",
    className: "KeyInfo",
    modelProperties: {
      startsOn: {
        serializedName: "Start",
        required: !0,
        xmlName: "Start",
        type: {
          name: "String"
        }
      },
      expiresOn: {
        serializedName: "Expiry",
        required: !0,
        xmlName: "Expiry",
        type: {
          name: "String"
        }
      }
    }
  }
}, Xp = {
  serializedName: "UserDelegationKey",
  type: {
    name: "Composite",
    className: "UserDelegationKey",
    modelProperties: {
      signedObjectId: {
        serializedName: "SignedOid",
        required: !0,
        xmlName: "SignedOid",
        type: {
          name: "String"
        }
      },
      signedTenantId: {
        serializedName: "SignedTid",
        required: !0,
        xmlName: "SignedTid",
        type: {
          name: "String"
        }
      },
      signedStartsOn: {
        serializedName: "SignedStart",
        required: !0,
        xmlName: "SignedStart",
        type: {
          name: "String"
        }
      },
      signedExpiresOn: {
        serializedName: "SignedExpiry",
        required: !0,
        xmlName: "SignedExpiry",
        type: {
          name: "String"
        }
      },
      signedService: {
        serializedName: "SignedService",
        required: !0,
        xmlName: "SignedService",
        type: {
          name: "String"
        }
      },
      signedVersion: {
        serializedName: "SignedVersion",
        required: !0,
        xmlName: "SignedVersion",
        type: {
          name: "String"
        }
      },
      value: {
        serializedName: "Value",
        required: !0,
        xmlName: "Value",
        type: {
          name: "String"
        }
      }
    }
  }
}, Xl = {
  serializedName: "FilterBlobSegment",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "FilterBlobSegment",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      where: {
        serializedName: "Where",
        required: !0,
        xmlName: "Where",
        type: {
          name: "String"
        }
      },
      blobs: {
        serializedName: "Blobs",
        required: !0,
        xmlName: "Blobs",
        xmlIsWrapped: !0,
        xmlElementName: "Blob",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "FilterBlobItem"
            }
          }
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, OS = {
  serializedName: "FilterBlobItem",
  xmlName: "Blob",
  type: {
    name: "Composite",
    className: "FilterBlobItem",
    modelProperties: {
      name: {
        serializedName: "Name",
        required: !0,
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      containerName: {
        serializedName: "ContainerName",
        required: !0,
        xmlName: "ContainerName",
        type: {
          name: "String"
        }
      },
      tags: {
        serializedName: "Tags",
        xmlName: "Tags",
        type: {
          name: "Composite",
          className: "BlobTags"
        }
      }
    }
  }
}, Zl = {
  serializedName: "BlobTags",
  xmlName: "Tags",
  type: {
    name: "Composite",
    className: "BlobTags",
    modelProperties: {
      blobTagSet: {
        serializedName: "BlobTagSet",
        required: !0,
        xmlName: "TagSet",
        xmlIsWrapped: !0,
        xmlElementName: "Tag",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobTag"
            }
          }
        }
      }
    }
  }
}, zS = {
  serializedName: "BlobTag",
  xmlName: "Tag",
  type: {
    name: "Composite",
    className: "BlobTag",
    modelProperties: {
      key: {
        serializedName: "Key",
        required: !0,
        xmlName: "Key",
        type: {
          name: "String"
        }
      },
      value: {
        serializedName: "Value",
        required: !0,
        xmlName: "Value",
        type: {
          name: "String"
        }
      }
    }
  }
}, qS = {
  serializedName: "SignedIdentifier",
  xmlName: "SignedIdentifier",
  type: {
    name: "Composite",
    className: "SignedIdentifier",
    modelProperties: {
      id: {
        serializedName: "Id",
        required: !0,
        xmlName: "Id",
        type: {
          name: "String"
        }
      },
      accessPolicy: {
        serializedName: "AccessPolicy",
        xmlName: "AccessPolicy",
        type: {
          name: "Composite",
          className: "AccessPolicy"
        }
      }
    }
  }
}, GS = {
  serializedName: "AccessPolicy",
  type: {
    name: "Composite",
    className: "AccessPolicy",
    modelProperties: {
      startsOn: {
        serializedName: "Start",
        xmlName: "Start",
        type: {
          name: "String"
        }
      },
      expiresOn: {
        serializedName: "Expiry",
        xmlName: "Expiry",
        type: {
          name: "String"
        }
      },
      permissions: {
        serializedName: "Permission",
        xmlName: "Permission",
        type: {
          name: "String"
        }
      }
    }
  }
}, Zp = {
  serializedName: "ListBlobsFlatSegmentResponse",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "ListBlobsFlatSegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      containerName: {
        serializedName: "ContainerName",
        required: !0,
        xmlName: "ContainerName",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      prefix: {
        serializedName: "Prefix",
        xmlName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        serializedName: "Marker",
        xmlName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        serializedName: "MaxResults",
        xmlName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      segment: {
        serializedName: "Segment",
        xmlName: "Blobs",
        type: {
          name: "Composite",
          className: "BlobFlatListSegment"
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, YS = {
  serializedName: "BlobFlatListSegment",
  xmlName: "Blobs",
  type: {
    name: "Composite",
    className: "BlobFlatListSegment",
    modelProperties: {
      blobItems: {
        serializedName: "BlobItems",
        required: !0,
        xmlName: "BlobItems",
        xmlElementName: "Blob",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobItemInternal"
            }
          }
        }
      }
    }
  }
}, JS = {
  serializedName: "BlobItemInternal",
  xmlName: "Blob",
  type: {
    name: "Composite",
    className: "BlobItemInternal",
    modelProperties: {
      name: {
        serializedName: "Name",
        xmlName: "Name",
        type: {
          name: "Composite",
          className: "BlobName"
        }
      },
      deleted: {
        serializedName: "Deleted",
        required: !0,
        xmlName: "Deleted",
        type: {
          name: "Boolean"
        }
      },
      snapshot: {
        serializedName: "Snapshot",
        required: !0,
        xmlName: "Snapshot",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "VersionId",
        xmlName: "VersionId",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        serializedName: "IsCurrentVersion",
        xmlName: "IsCurrentVersion",
        type: {
          name: "Boolean"
        }
      },
      properties: {
        serializedName: "Properties",
        xmlName: "Properties",
        type: {
          name: "Composite",
          className: "BlobPropertiesInternal"
        }
      },
      metadata: {
        serializedName: "Metadata",
        xmlName: "Metadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      blobTags: {
        serializedName: "BlobTags",
        xmlName: "Tags",
        type: {
          name: "Composite",
          className: "BlobTags"
        }
      },
      objectReplicationMetadata: {
        serializedName: "ObjectReplicationMetadata",
        xmlName: "OrMetadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      hasVersionsOnly: {
        serializedName: "HasVersionsOnly",
        xmlName: "HasVersionsOnly",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, VS = {
  serializedName: "BlobName",
  type: {
    name: "Composite",
    className: "BlobName",
    modelProperties: {
      encoded: {
        serializedName: "Encoded",
        xmlName: "Encoded",
        xmlIsAttribute: !0,
        type: {
          name: "Boolean"
        }
      },
      content: {
        serializedName: "content",
        xmlName: "content",
        xmlIsMsText: !0,
        type: {
          name: "String"
        }
      }
    }
  }
}, _S = {
  serializedName: "BlobPropertiesInternal",
  xmlName: "Properties",
  type: {
    name: "Composite",
    className: "BlobPropertiesInternal",
    modelProperties: {
      createdOn: {
        serializedName: "Creation-Time",
        xmlName: "Creation-Time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      lastModified: {
        serializedName: "Last-Modified",
        required: !0,
        xmlName: "Last-Modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "Etag",
        required: !0,
        xmlName: "Etag",
        type: {
          name: "String"
        }
      },
      contentLength: {
        serializedName: "Content-Length",
        xmlName: "Content-Length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "Content-Type",
        xmlName: "Content-Type",
        type: {
          name: "String"
        }
      },
      contentEncoding: {
        serializedName: "Content-Encoding",
        xmlName: "Content-Encoding",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "Content-Language",
        xmlName: "Content-Language",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "Content-MD5",
        xmlName: "Content-MD5",
        type: {
          name: "ByteArray"
        }
      },
      contentDisposition: {
        serializedName: "Content-Disposition",
        xmlName: "Content-Disposition",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "Cache-Control",
        xmlName: "Cache-Control",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "BlobType",
        xmlName: "BlobType",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      leaseStatus: {
        serializedName: "LeaseStatus",
        xmlName: "LeaseStatus",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      leaseState: {
        serializedName: "LeaseState",
        xmlName: "LeaseState",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseDuration: {
        serializedName: "LeaseDuration",
        xmlName: "LeaseDuration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      copyId: {
        serializedName: "CopyId",
        xmlName: "CopyId",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "CopyStatus",
        xmlName: "CopyStatus",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      copySource: {
        serializedName: "CopySource",
        xmlName: "CopySource",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "CopyProgress",
        xmlName: "CopyProgress",
        type: {
          name: "String"
        }
      },
      copyCompletedOn: {
        serializedName: "CopyCompletionTime",
        xmlName: "CopyCompletionTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "CopyStatusDescription",
        xmlName: "CopyStatusDescription",
        type: {
          name: "String"
        }
      },
      serverEncrypted: {
        serializedName: "ServerEncrypted",
        xmlName: "ServerEncrypted",
        type: {
          name: "Boolean"
        }
      },
      incrementalCopy: {
        serializedName: "IncrementalCopy",
        xmlName: "IncrementalCopy",
        type: {
          name: "Boolean"
        }
      },
      destinationSnapshot: {
        serializedName: "DestinationSnapshot",
        xmlName: "DestinationSnapshot",
        type: {
          name: "String"
        }
      },
      deletedOn: {
        serializedName: "DeletedTime",
        xmlName: "DeletedTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      remainingRetentionDays: {
        serializedName: "RemainingRetentionDays",
        xmlName: "RemainingRetentionDays",
        type: {
          name: "Number"
        }
      },
      accessTier: {
        serializedName: "AccessTier",
        xmlName: "AccessTier",
        type: {
          name: "Enum",
          allowedValues: [
            "P4",
            "P6",
            "P10",
            "P15",
            "P20",
            "P30",
            "P40",
            "P50",
            "P60",
            "P70",
            "P80",
            "Hot",
            "Cool",
            "Archive",
            "Cold"
          ]
        }
      },
      accessTierInferred: {
        serializedName: "AccessTierInferred",
        xmlName: "AccessTierInferred",
        type: {
          name: "Boolean"
        }
      },
      archiveStatus: {
        serializedName: "ArchiveStatus",
        xmlName: "ArchiveStatus",
        type: {
          name: "Enum",
          allowedValues: [
            "rehydrate-pending-to-hot",
            "rehydrate-pending-to-cool",
            "rehydrate-pending-to-cold"
          ]
        }
      },
      customerProvidedKeySha256: {
        serializedName: "CustomerProvidedKeySha256",
        xmlName: "CustomerProvidedKeySha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "EncryptionScope",
        xmlName: "EncryptionScope",
        type: {
          name: "String"
        }
      },
      accessTierChangedOn: {
        serializedName: "AccessTierChangeTime",
        xmlName: "AccessTierChangeTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      tagCount: {
        serializedName: "TagCount",
        xmlName: "TagCount",
        type: {
          name: "Number"
        }
      },
      expiresOn: {
        serializedName: "Expiry-Time",
        xmlName: "Expiry-Time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "Sealed",
        xmlName: "Sealed",
        type: {
          name: "Boolean"
        }
      },
      rehydratePriority: {
        serializedName: "RehydratePriority",
        xmlName: "RehydratePriority",
        type: {
          name: "Enum",
          allowedValues: ["High", "Standard"]
        }
      },
      lastAccessedOn: {
        serializedName: "LastAccessTime",
        xmlName: "LastAccessTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiresOn: {
        serializedName: "ImmutabilityPolicyUntilDate",
        xmlName: "ImmutabilityPolicyUntilDate",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "ImmutabilityPolicyMode",
        xmlName: "ImmutabilityPolicyMode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      },
      legalHold: {
        serializedName: "LegalHold",
        xmlName: "LegalHold",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, Kp = {
  serializedName: "ListBlobsHierarchySegmentResponse",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "ListBlobsHierarchySegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      containerName: {
        serializedName: "ContainerName",
        required: !0,
        xmlName: "ContainerName",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      prefix: {
        serializedName: "Prefix",
        xmlName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        serializedName: "Marker",
        xmlName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        serializedName: "MaxResults",
        xmlName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      delimiter: {
        serializedName: "Delimiter",
        xmlName: "Delimiter",
        type: {
          name: "String"
        }
      },
      segment: {
        serializedName: "Segment",
        xmlName: "Blobs",
        type: {
          name: "Composite",
          className: "BlobHierarchyListSegment"
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, WS = {
  serializedName: "BlobHierarchyListSegment",
  xmlName: "Blobs",
  type: {
    name: "Composite",
    className: "BlobHierarchyListSegment",
    modelProperties: {
      blobPrefixes: {
        serializedName: "BlobPrefixes",
        xmlName: "BlobPrefixes",
        xmlElementName: "BlobPrefix",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobPrefix"
            }
          }
        }
      },
      blobItems: {
        serializedName: "BlobItems",
        required: !0,
        xmlName: "BlobItems",
        xmlElementName: "Blob",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobItemInternal"
            }
          }
        }
      }
    }
  }
}, $S = {
  serializedName: "BlobPrefix",
  type: {
    name: "Composite",
    className: "BlobPrefix",
    modelProperties: {
      name: {
        serializedName: "Name",
        xmlName: "Name",
        type: {
          name: "Composite",
          className: "BlobName"
        }
      }
    }
  }
}, jp = {
  serializedName: "BlockLookupList",
  xmlName: "BlockList",
  type: {
    name: "Composite",
    className: "BlockLookupList",
    modelProperties: {
      committed: {
        serializedName: "Committed",
        xmlName: "Committed",
        xmlElementName: "Committed",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      uncommitted: {
        serializedName: "Uncommitted",
        xmlName: "Uncommitted",
        xmlElementName: "Uncommitted",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      latest: {
        serializedName: "Latest",
        xmlName: "Latest",
        xmlElementName: "Latest",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
}, eE = {
  serializedName: "BlockList",
  type: {
    name: "Composite",
    className: "BlockList",
    modelProperties: {
      committedBlocks: {
        serializedName: "CommittedBlocks",
        xmlName: "CommittedBlocks",
        xmlIsWrapped: !0,
        xmlElementName: "Block",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Block"
            }
          }
        }
      },
      uncommittedBlocks: {
        serializedName: "UncommittedBlocks",
        xmlName: "UncommittedBlocks",
        xmlIsWrapped: !0,
        xmlElementName: "Block",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Block"
            }
          }
        }
      }
    }
  }
}, XS = {
  serializedName: "Block",
  type: {
    name: "Composite",
    className: "Block",
    modelProperties: {
      name: {
        serializedName: "Name",
        required: !0,
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      size: {
        serializedName: "Size",
        required: !0,
        xmlName: "Size",
        type: {
          name: "Number"
        }
      }
    }
  }
}, Kl = {
  serializedName: "PageList",
  type: {
    name: "Composite",
    className: "PageList",
    modelProperties: {
      pageRange: {
        serializedName: "PageRange",
        xmlName: "PageRange",
        xmlElementName: "PageRange",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "PageRange"
            }
          }
        }
      },
      clearRange: {
        serializedName: "ClearRange",
        xmlName: "ClearRange",
        xmlElementName: "ClearRange",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ClearRange"
            }
          }
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, ZS = {
  serializedName: "PageRange",
  xmlName: "PageRange",
  type: {
    name: "Composite",
    className: "PageRange",
    modelProperties: {
      start: {
        serializedName: "Start",
        required: !0,
        xmlName: "Start",
        type: {
          name: "Number"
        }
      },
      end: {
        serializedName: "End",
        required: !0,
        xmlName: "End",
        type: {
          name: "Number"
        }
      }
    }
  }
}, KS = {
  serializedName: "ClearRange",
  xmlName: "ClearRange",
  type: {
    name: "Composite",
    className: "ClearRange",
    modelProperties: {
      start: {
        serializedName: "Start",
        required: !0,
        xmlName: "Start",
        type: {
          name: "Number"
        }
      },
      end: {
        serializedName: "End",
        required: !0,
        xmlName: "End",
        type: {
          name: "Number"
        }
      }
    }
  }
}, tE = {
  serializedName: "QueryRequest",
  xmlName: "QueryRequest",
  type: {
    name: "Composite",
    className: "QueryRequest",
    modelProperties: {
      queryType: {
        serializedName: "QueryType",
        required: !0,
        xmlName: "QueryType",
        type: {
          name: "String"
        }
      },
      expression: {
        serializedName: "Expression",
        required: !0,
        xmlName: "Expression",
        type: {
          name: "String"
        }
      },
      inputSerialization: {
        serializedName: "InputSerialization",
        xmlName: "InputSerialization",
        type: {
          name: "Composite",
          className: "QuerySerialization"
        }
      },
      outputSerialization: {
        serializedName: "OutputSerialization",
        xmlName: "OutputSerialization",
        type: {
          name: "Composite",
          className: "QuerySerialization"
        }
      }
    }
  }
}, jS = {
  serializedName: "QuerySerialization",
  type: {
    name: "Composite",
    className: "QuerySerialization",
    modelProperties: {
      format: {
        serializedName: "Format",
        xmlName: "Format",
        type: {
          name: "Composite",
          className: "QueryFormat"
        }
      }
    }
  }
}, eD = {
  serializedName: "QueryFormat",
  type: {
    name: "Composite",
    className: "QueryFormat",
    modelProperties: {
      type: {
        serializedName: "Type",
        required: !0,
        xmlName: "Type",
        type: {
          name: "Enum",
          allowedValues: ["delimited", "json", "arrow", "parquet"]
        }
      },
      delimitedTextConfiguration: {
        serializedName: "DelimitedTextConfiguration",
        xmlName: "DelimitedTextConfiguration",
        type: {
          name: "Composite",
          className: "DelimitedTextConfiguration"
        }
      },
      jsonTextConfiguration: {
        serializedName: "JsonTextConfiguration",
        xmlName: "JsonTextConfiguration",
        type: {
          name: "Composite",
          className: "JsonTextConfiguration"
        }
      },
      arrowConfiguration: {
        serializedName: "ArrowConfiguration",
        xmlName: "ArrowConfiguration",
        type: {
          name: "Composite",
          className: "ArrowConfiguration"
        }
      },
      parquetTextConfiguration: {
        serializedName: "ParquetTextConfiguration",
        xmlName: "ParquetTextConfiguration",
        type: {
          name: "Dictionary",
          value: { type: { name: "any" } }
        }
      }
    }
  }
}, tD = {
  serializedName: "DelimitedTextConfiguration",
  xmlName: "DelimitedTextConfiguration",
  type: {
    name: "Composite",
    className: "DelimitedTextConfiguration",
    modelProperties: {
      columnSeparator: {
        serializedName: "ColumnSeparator",
        xmlName: "ColumnSeparator",
        type: {
          name: "String"
        }
      },
      fieldQuote: {
        serializedName: "FieldQuote",
        xmlName: "FieldQuote",
        type: {
          name: "String"
        }
      },
      recordSeparator: {
        serializedName: "RecordSeparator",
        xmlName: "RecordSeparator",
        type: {
          name: "String"
        }
      },
      escapeChar: {
        serializedName: "EscapeChar",
        xmlName: "EscapeChar",
        type: {
          name: "String"
        }
      },
      headersPresent: {
        serializedName: "HeadersPresent",
        xmlName: "HasHeaders",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, rD = {
  serializedName: "JsonTextConfiguration",
  xmlName: "JsonTextConfiguration",
  type: {
    name: "Composite",
    className: "JsonTextConfiguration",
    modelProperties: {
      recordSeparator: {
        serializedName: "RecordSeparator",
        xmlName: "RecordSeparator",
        type: {
          name: "String"
        }
      }
    }
  }
}, nD = {
  serializedName: "ArrowConfiguration",
  xmlName: "ArrowConfiguration",
  type: {
    name: "Composite",
    className: "ArrowConfiguration",
    modelProperties: {
      schema: {
        serializedName: "Schema",
        required: !0,
        xmlName: "Schema",
        xmlIsWrapped: !0,
        xmlElementName: "Field",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ArrowField"
            }
          }
        }
      }
    }
  }
}, sD = {
  serializedName: "ArrowField",
  xmlName: "Field",
  type: {
    name: "Composite",
    className: "ArrowField",
    modelProperties: {
      type: {
        serializedName: "Type",
        required: !0,
        xmlName: "Type",
        type: {
          name: "String"
        }
      },
      name: {
        serializedName: "Name",
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      precision: {
        serializedName: "Precision",
        xmlName: "Precision",
        type: {
          name: "Number"
        }
      },
      scale: {
        serializedName: "Scale",
        xmlName: "Scale",
        type: {
          name: "Number"
        }
      }
    }
  }
}, rE = {
  serializedName: "Service_setPropertiesHeaders",
  type: {
    name: "Composite",
    className: "ServiceSetPropertiesHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, nE = {
  serializedName: "Service_setPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceSetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, sE = {
  serializedName: "Service_getPropertiesHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetPropertiesHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, iE = {
  serializedName: "Service_getPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, oE = {
  serializedName: "Service_getStatisticsHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetStatisticsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, aE = {
  serializedName: "Service_getStatisticsExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetStatisticsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, AE = {
  serializedName: "Service_listContainersSegmentHeaders",
  type: {
    name: "Composite",
    className: "ServiceListContainersSegmentHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, cE = {
  serializedName: "Service_listContainersSegmentExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceListContainersSegmentExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, lE = {
  serializedName: "Service_getUserDelegationKeyHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetUserDelegationKeyHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, dE = {
  serializedName: "Service_getUserDelegationKeyExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetUserDelegationKeyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, uE = {
  serializedName: "Service_getAccountInfoHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        xmlName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        xmlName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      isHierarchicalNamespaceEnabled: {
        serializedName: "x-ms-is-hns-enabled",
        xmlName: "x-ms-is-hns-enabled",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, mE = {
  serializedName: "Service_getAccountInfoExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetAccountInfoExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, hE = {
  serializedName: "Service_submitBatchHeaders",
  type: {
    name: "Composite",
    className: "ServiceSubmitBatchHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, gE = {
  serializedName: "Service_submitBatchExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceSubmitBatchExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, fE = {
  serializedName: "Service_filterBlobsHeaders",
  type: {
    name: "Composite",
    className: "ServiceFilterBlobsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, pE = {
  serializedName: "Service_filterBlobsExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceFilterBlobsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, EE = {
  serializedName: "Container_createHeaders",
  type: {
    name: "Composite",
    className: "ContainerCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, CE = {
  serializedName: "Container_createExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerCreateExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BE = {
  serializedName: "Container_getPropertiesHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetPropertiesHeaders",
    modelProperties: {
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobPublicAccess: {
        serializedName: "x-ms-blob-public-access",
        xmlName: "x-ms-blob-public-access",
        type: {
          name: "Enum",
          allowedValues: ["container", "blob"]
        }
      },
      hasImmutabilityPolicy: {
        serializedName: "x-ms-has-immutability-policy",
        xmlName: "x-ms-has-immutability-policy",
        type: {
          name: "Boolean"
        }
      },
      hasLegalHold: {
        serializedName: "x-ms-has-legal-hold",
        xmlName: "x-ms-has-legal-hold",
        type: {
          name: "Boolean"
        }
      },
      defaultEncryptionScope: {
        serializedName: "x-ms-default-encryption-scope",
        xmlName: "x-ms-default-encryption-scope",
        type: {
          name: "String"
        }
      },
      denyEncryptionScopeOverride: {
        serializedName: "x-ms-deny-encryption-scope-override",
        xmlName: "x-ms-deny-encryption-scope-override",
        type: {
          name: "Boolean"
        }
      },
      isImmutableStorageWithVersioningEnabled: {
        serializedName: "x-ms-immutable-storage-with-versioning-enabled",
        xmlName: "x-ms-immutable-storage-with-versioning-enabled",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, IE = {
  serializedName: "Container_getPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, yE = {
  serializedName: "Container_deleteHeaders",
  type: {
    name: "Composite",
    className: "ContainerDeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, QE = {
  serializedName: "Container_deleteExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerDeleteExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, NE = {
  serializedName: "Container_setMetadataHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetMetadataHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, wE = {
  serializedName: "Container_setMetadataExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetMetadataExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, bE = {
  serializedName: "Container_getAccessPolicyHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccessPolicyHeaders",
    modelProperties: {
      blobPublicAccess: {
        serializedName: "x-ms-blob-public-access",
        xmlName: "x-ms-blob-public-access",
        type: {
          name: "Enum",
          allowedValues: ["container", "blob"]
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, xE = {
  serializedName: "Container_getAccessPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccessPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, RE = {
  serializedName: "Container_setAccessPolicyHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetAccessPolicyHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, SE = {
  serializedName: "Container_setAccessPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetAccessPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, DE = {
  serializedName: "Container_restoreHeaders",
  type: {
    name: "Composite",
    className: "ContainerRestoreHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, kE = {
  serializedName: "Container_restoreExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerRestoreExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ME = {
  serializedName: "Container_renameHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenameHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, TE = {
  serializedName: "Container_renameExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenameExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, FE = {
  serializedName: "Container_submitBatchHeaders",
  type: {
    name: "Composite",
    className: "ContainerSubmitBatchHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      }
    }
  }
}, vE = {
  serializedName: "Container_submitBatchExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerSubmitBatchExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, LE = {
  serializedName: "Container_filterBlobsHeaders",
  type: {
    name: "Composite",
    className: "ContainerFilterBlobsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, UE = {
  serializedName: "Container_filterBlobsExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerFilterBlobsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PE = {
  serializedName: "Container_acquireLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerAcquireLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, HE = {
  serializedName: "Container_acquireLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerAcquireLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, OE = {
  serializedName: "Container_releaseLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerReleaseLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, zE = {
  serializedName: "Container_releaseLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerReleaseLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, qE = {
  serializedName: "Container_renewLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenewLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, GE = {
  serializedName: "Container_renewLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenewLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, YE = {
  serializedName: "Container_breakLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerBreakLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseTime: {
        serializedName: "x-ms-lease-time",
        xmlName: "x-ms-lease-time",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, JE = {
  serializedName: "Container_breakLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerBreakLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, VE = {
  serializedName: "Container_changeLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerChangeLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, _E = {
  serializedName: "Container_changeLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerChangeLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, WE = {
  serializedName: "Container_listBlobFlatSegmentHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobFlatSegmentHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, $E = {
  serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobFlatSegmentExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, XE = {
  serializedName: "Container_listBlobHierarchySegmentHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobHierarchySegmentHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ZE = {
  serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobHierarchySegmentExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, KE = {
  serializedName: "Container_getAccountInfoHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        xmlName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        xmlName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      isHierarchicalNamespaceEnabled: {
        serializedName: "x-ms-is-hns-enabled",
        xmlName: "x-ms-is-hns-enabled",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, jE = {
  serializedName: "Container_getAccountInfoExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccountInfoExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, el = {
  serializedName: "Blob_downloadHeaders",
  type: {
    name: "Composite",
    className: "BlobDownloadHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      createdOn: {
        serializedName: "x-ms-creation-time",
        xmlName: "x-ms-creation-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      objectReplicationPolicyId: {
        serializedName: "x-ms-or-policy-id",
        xmlName: "x-ms-or-policy-id",
        type: {
          name: "String"
        }
      },
      objectReplicationRules: {
        serializedName: "x-ms-or",
        headerCollectionPrefix: "x-ms-or-",
        xmlName: "x-ms-or",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      contentLength: {
        serializedName: "content-length",
        xmlName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      contentRange: {
        serializedName: "content-range",
        xmlName: "content-range",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        xmlName: "content-encoding",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        xmlName: "cache-control",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        xmlName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        xmlName: "content-language",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        xmlName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      copyCompletedOn: {
        serializedName: "x-ms-copy-completion-time",
        xmlName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        xmlName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        xmlName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        serializedName: "x-ms-is-current-version",
        xmlName: "x-ms-is-current-version",
        type: {
          name: "Boolean"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        xmlName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        xmlName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      blobContentMD5: {
        serializedName: "x-ms-blob-content-md5",
        xmlName: "x-ms-blob-content-md5",
        type: {
          name: "ByteArray"
        }
      },
      tagCount: {
        serializedName: "x-ms-tag-count",
        xmlName: "x-ms-tag-count",
        type: {
          name: "Number"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        xmlName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      },
      lastAccessed: {
        serializedName: "x-ms-last-access-time",
        xmlName: "x-ms-last-access-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiresOn: {
        serializedName: "x-ms-immutability-policy-until-date",
        xmlName: "x-ms-immutability-policy-until-date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "x-ms-immutability-policy-mode",
        xmlName: "x-ms-immutability-policy-mode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      },
      legalHold: {
        serializedName: "x-ms-legal-hold",
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      contentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      }
    }
  }
}, eC = {
  serializedName: "Blob_downloadExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobDownloadExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, tC = {
  serializedName: "Blob_getPropertiesHeaders",
  type: {
    name: "Composite",
    className: "BlobGetPropertiesHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      createdOn: {
        serializedName: "x-ms-creation-time",
        xmlName: "x-ms-creation-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      objectReplicationPolicyId: {
        serializedName: "x-ms-or-policy-id",
        xmlName: "x-ms-or-policy-id",
        type: {
          name: "String"
        }
      },
      objectReplicationRules: {
        serializedName: "x-ms-or",
        headerCollectionPrefix: "x-ms-or-",
        xmlName: "x-ms-or",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        xmlName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      copyCompletedOn: {
        serializedName: "x-ms-copy-completion-time",
        xmlName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        xmlName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        xmlName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      isIncrementalCopy: {
        serializedName: "x-ms-incremental-copy",
        xmlName: "x-ms-incremental-copy",
        type: {
          name: "Boolean"
        }
      },
      destinationSnapshot: {
        serializedName: "x-ms-copy-destination-snapshot",
        xmlName: "x-ms-copy-destination-snapshot",
        type: {
          name: "String"
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      contentLength: {
        serializedName: "content-length",
        xmlName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        xmlName: "content-encoding",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        xmlName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        xmlName: "content-language",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        xmlName: "cache-control",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        xmlName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        xmlName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      accessTier: {
        serializedName: "x-ms-access-tier",
        xmlName: "x-ms-access-tier",
        type: {
          name: "String"
        }
      },
      accessTierInferred: {
        serializedName: "x-ms-access-tier-inferred",
        xmlName: "x-ms-access-tier-inferred",
        type: {
          name: "Boolean"
        }
      },
      archiveStatus: {
        serializedName: "x-ms-archive-status",
        xmlName: "x-ms-archive-status",
        type: {
          name: "String"
        }
      },
      accessTierChangedOn: {
        serializedName: "x-ms-access-tier-change-time",
        xmlName: "x-ms-access-tier-change-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        serializedName: "x-ms-is-current-version",
        xmlName: "x-ms-is-current-version",
        type: {
          name: "Boolean"
        }
      },
      tagCount: {
        serializedName: "x-ms-tag-count",
        xmlName: "x-ms-tag-count",
        type: {
          name: "Number"
        }
      },
      expiresOn: {
        serializedName: "x-ms-expiry-time",
        xmlName: "x-ms-expiry-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        xmlName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      },
      rehydratePriority: {
        serializedName: "x-ms-rehydrate-priority",
        xmlName: "x-ms-rehydrate-priority",
        type: {
          name: "Enum",
          allowedValues: ["High", "Standard"]
        }
      },
      lastAccessed: {
        serializedName: "x-ms-last-access-time",
        xmlName: "x-ms-last-access-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiresOn: {
        serializedName: "x-ms-immutability-policy-until-date",
        xmlName: "x-ms-immutability-policy-until-date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "x-ms-immutability-policy-mode",
        xmlName: "x-ms-immutability-policy-mode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      },
      legalHold: {
        serializedName: "x-ms-legal-hold",
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, rC = {
  serializedName: "Blob_getPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobGetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, nC = {
  serializedName: "Blob_deleteHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, sC = {
  serializedName: "Blob_deleteExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, iC = {
  serializedName: "Blob_undeleteHeaders",
  type: {
    name: "Composite",
    className: "BlobUndeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, oC = {
  serializedName: "Blob_undeleteExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobUndeleteExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, aC = {
  serializedName: "Blob_setExpiryHeaders",
  type: {
    name: "Composite",
    className: "BlobSetExpiryHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, AC = {
  serializedName: "Blob_setExpiryExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetExpiryExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, cC = {
  serializedName: "Blob_setHttpHeadersHeaders",
  type: {
    name: "Composite",
    className: "BlobSetHttpHeadersHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, lC = {
  serializedName: "Blob_setHttpHeadersExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetHttpHeadersExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, dC = {
  serializedName: "Blob_setImmutabilityPolicyHeaders",
  type: {
    name: "Composite",
    className: "BlobSetImmutabilityPolicyHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiry: {
        serializedName: "x-ms-immutability-policy-until-date",
        xmlName: "x-ms-immutability-policy-until-date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "x-ms-immutability-policy-mode",
        xmlName: "x-ms-immutability-policy-mode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      }
    }
  }
}, uC = {
  serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetImmutabilityPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, mC = {
  serializedName: "Blob_deleteImmutabilityPolicyHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteImmutabilityPolicyHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, hC = {
  serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, gC = {
  serializedName: "Blob_setLegalHoldHeaders",
  type: {
    name: "Composite",
    className: "BlobSetLegalHoldHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      legalHold: {
        serializedName: "x-ms-legal-hold",
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, fC = {
  serializedName: "Blob_setLegalHoldExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetLegalHoldExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, pC = {
  serializedName: "Blob_setMetadataHeaders",
  type: {
    name: "Composite",
    className: "BlobSetMetadataHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, EC = {
  serializedName: "Blob_setMetadataExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetMetadataExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, CC = {
  serializedName: "Blob_acquireLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobAcquireLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, BC = {
  serializedName: "Blob_acquireLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobAcquireLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, IC = {
  serializedName: "Blob_releaseLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobReleaseLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, yC = {
  serializedName: "Blob_releaseLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobReleaseLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, QC = {
  serializedName: "Blob_renewLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobRenewLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, NC = {
  serializedName: "Blob_renewLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobRenewLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, wC = {
  serializedName: "Blob_changeLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobChangeLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, bC = {
  serializedName: "Blob_changeLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobChangeLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, xC = {
  serializedName: "Blob_breakLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobBreakLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseTime: {
        serializedName: "x-ms-lease-time",
        xmlName: "x-ms-lease-time",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, RC = {
  serializedName: "Blob_breakLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobBreakLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, SC = {
  serializedName: "Blob_createSnapshotHeaders",
  type: {
    name: "Composite",
    className: "BlobCreateSnapshotHeaders",
    modelProperties: {
      snapshot: {
        serializedName: "x-ms-snapshot",
        xmlName: "x-ms-snapshot",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, DC = {
  serializedName: "Blob_createSnapshotExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobCreateSnapshotExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, kC = {
  serializedName: "Blob_startCopyFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlobStartCopyFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, MC = {
  serializedName: "Blob_startCopyFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobStartCopyFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      copySourceErrorCode: {
        serializedName: "x-ms-copy-source-error-code",
        xmlName: "x-ms-copy-source-error-code",
        type: {
          name: "String"
        }
      },
      copySourceStatusCode: {
        serializedName: "x-ms-copy-source-status-code",
        xmlName: "x-ms-copy-source-status-code",
        type: {
          name: "Number"
        }
      }
    }
  }
}, TC = {
  serializedName: "Blob_copyFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlobCopyFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        defaultValue: "success",
        isConstant: !0,
        serializedName: "x-ms-copy-status",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, FC = {
  serializedName: "Blob_copyFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobCopyFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      copySourceErrorCode: {
        serializedName: "x-ms-copy-source-error-code",
        xmlName: "x-ms-copy-source-error-code",
        type: {
          name: "String"
        }
      },
      copySourceStatusCode: {
        serializedName: "x-ms-copy-source-status-code",
        xmlName: "x-ms-copy-source-status-code",
        type: {
          name: "Number"
        }
      }
    }
  }
}, vC = {
  serializedName: "Blob_abortCopyFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlobAbortCopyFromURLHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, LC = {
  serializedName: "Blob_abortCopyFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobAbortCopyFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, tl = {
  serializedName: "Blob_setTierHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTierHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, UC = {
  serializedName: "Blob_setTierExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTierExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PC = {
  serializedName: "Blob_getAccountInfoHeaders",
  type: {
    name: "Composite",
    className: "BlobGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        xmlName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        xmlName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      isHierarchicalNamespaceEnabled: {
        serializedName: "x-ms-is-hns-enabled",
        xmlName: "x-ms-is-hns-enabled",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, HC = {
  serializedName: "Blob_getAccountInfoExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobGetAccountInfoExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, rl = {
  serializedName: "Blob_queryHeaders",
  type: {
    name: "Composite",
    className: "BlobQueryHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      contentLength: {
        serializedName: "content-length",
        xmlName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      contentRange: {
        serializedName: "content-range",
        xmlName: "content-range",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        xmlName: "content-encoding",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        xmlName: "cache-control",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        xmlName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        xmlName: "content-language",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        xmlName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      copyCompletionTime: {
        serializedName: "x-ms-copy-completion-time",
        xmlName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        xmlName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        xmlName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        xmlName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        xmlName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      blobContentMD5: {
        serializedName: "x-ms-blob-content-md5",
        xmlName: "x-ms-blob-content-md5",
        type: {
          name: "ByteArray"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      contentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      }
    }
  }
}, OC = {
  serializedName: "Blob_queryExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobQueryExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, zC = {
  serializedName: "Blob_getTagsHeaders",
  type: {
    name: "Composite",
    className: "BlobGetTagsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, qC = {
  serializedName: "Blob_getTagsExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobGetTagsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, GC = {
  serializedName: "Blob_setTagsHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTagsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, YC = {
  serializedName: "Blob_setTagsExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTagsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, JC = {
  serializedName: "PageBlob_createHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, VC = {
  serializedName: "PageBlob_createExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCreateExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, _C = {
  serializedName: "PageBlob_uploadPagesHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, WC = {
  serializedName: "PageBlob_uploadPagesExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, $C = {
  serializedName: "PageBlob_clearPagesHeaders",
  type: {
    name: "Composite",
    className: "PageBlobClearPagesHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, XC = {
  serializedName: "PageBlob_clearPagesExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobClearPagesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ZC = {
  serializedName: "PageBlob_uploadPagesFromURLHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, KC = {
  serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      copySourceErrorCode: {
        serializedName: "x-ms-copy-source-error-code",
        xmlName: "x-ms-copy-source-error-code",
        type: {
          name: "String"
        }
      },
      copySourceStatusCode: {
        serializedName: "x-ms-copy-source-status-code",
        xmlName: "x-ms-copy-source-status-code",
        type: {
          name: "Number"
        }
      }
    }
  }
}, jC = {
  serializedName: "PageBlob_getPageRangesHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        xmlName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, eB = {
  serializedName: "PageBlob_getPageRangesExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, tB = {
  serializedName: "PageBlob_getPageRangesDiffHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesDiffHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        xmlName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, rB = {
  serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesDiffExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, nB = {
  serializedName: "PageBlob_resizeHeaders",
  type: {
    name: "Composite",
    className: "PageBlobResizeHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, sB = {
  serializedName: "PageBlob_resizeExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobResizeExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, iB = {
  serializedName: "PageBlob_updateSequenceNumberHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUpdateSequenceNumberHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, oB = {
  serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUpdateSequenceNumberExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, aB = {
  serializedName: "PageBlob_copyIncrementalHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCopyIncrementalHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, AB = {
  serializedName: "PageBlob_copyIncrementalExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCopyIncrementalExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, cB = {
  serializedName: "AppendBlob_createHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, lB = {
  serializedName: "AppendBlob_createExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobCreateExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, dB = {
  serializedName: "AppendBlob_appendBlockHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobAppendOffset: {
        serializedName: "x-ms-blob-append-offset",
        xmlName: "x-ms-blob-append-offset",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, uB = {
  serializedName: "AppendBlob_appendBlockExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, mB = {
  serializedName: "AppendBlob_appendBlockFromUrlHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockFromUrlHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobAppendOffset: {
        serializedName: "x-ms-blob-append-offset",
        xmlName: "x-ms-blob-append-offset",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, hB = {
  serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      copySourceErrorCode: {
        serializedName: "x-ms-copy-source-error-code",
        xmlName: "x-ms-copy-source-error-code",
        type: {
          name: "String"
        }
      },
      copySourceStatusCode: {
        serializedName: "x-ms-copy-source-status-code",
        xmlName: "x-ms-copy-source-status-code",
        type: {
          name: "Number"
        }
      }
    }
  }
}, gB = {
  serializedName: "AppendBlob_sealHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobSealHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        xmlName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, fB = {
  serializedName: "AppendBlob_sealExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobSealExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, pB = {
  serializedName: "BlockBlob_uploadHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobUploadHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, EB = {
  serializedName: "BlockBlob_uploadExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobUploadExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, CB = {
  serializedName: "BlockBlob_putBlobFromUrlHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobPutBlobFromUrlHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BB = {
  serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobPutBlobFromUrlExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      copySourceErrorCode: {
        serializedName: "x-ms-copy-source-error-code",
        xmlName: "x-ms-copy-source-error-code",
        type: {
          name: "String"
        }
      },
      copySourceStatusCode: {
        serializedName: "x-ms-copy-source-status-code",
        xmlName: "x-ms-copy-source-status-code",
        type: {
          name: "Number"
        }
      }
    }
  }
}, IB = {
  serializedName: "BlockBlob_stageBlockHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockHeaders",
    modelProperties: {
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, yB = {
  serializedName: "BlockBlob_stageBlockExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, QB = {
  serializedName: "BlockBlob_stageBlockFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockFromURLHeaders",
    modelProperties: {
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, NB = {
  serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      copySourceErrorCode: {
        serializedName: "x-ms-copy-source-error-code",
        xmlName: "x-ms-copy-source-error-code",
        type: {
          name: "String"
        }
      },
      copySourceStatusCode: {
        serializedName: "x-ms-copy-source-status-code",
        xmlName: "x-ms-copy-source-status-code",
        type: {
          name: "Number"
        }
      }
    }
  }
}, wB = {
  serializedName: "BlockBlob_commitBlockListHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobCommitBlockListHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, bB = {
  serializedName: "BlockBlob_commitBlockListExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobCommitBlockListExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, xB = {
  serializedName: "BlockBlob_getBlockListHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobGetBlockListHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        xmlName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, RB = {
  serializedName: "BlockBlob_getBlockListExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobGetBlockListExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, os = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AccessPolicy: GS,
  AppendBlobAppendBlockExceptionHeaders: uB,
  AppendBlobAppendBlockFromUrlExceptionHeaders: hB,
  AppendBlobAppendBlockFromUrlHeaders: mB,
  AppendBlobAppendBlockHeaders: dB,
  AppendBlobCreateExceptionHeaders: lB,
  AppendBlobCreateHeaders: cB,
  AppendBlobSealExceptionHeaders: fB,
  AppendBlobSealHeaders: gB,
  ArrowConfiguration: nD,
  ArrowField: sD,
  BlobAbortCopyFromURLExceptionHeaders: LC,
  BlobAbortCopyFromURLHeaders: vC,
  BlobAcquireLeaseExceptionHeaders: BC,
  BlobAcquireLeaseHeaders: CC,
  BlobBreakLeaseExceptionHeaders: RC,
  BlobBreakLeaseHeaders: xC,
  BlobChangeLeaseExceptionHeaders: bC,
  BlobChangeLeaseHeaders: wC,
  BlobCopyFromURLExceptionHeaders: FC,
  BlobCopyFromURLHeaders: TC,
  BlobCreateSnapshotExceptionHeaders: DC,
  BlobCreateSnapshotHeaders: SC,
  BlobDeleteExceptionHeaders: sC,
  BlobDeleteHeaders: nC,
  BlobDeleteImmutabilityPolicyExceptionHeaders: hC,
  BlobDeleteImmutabilityPolicyHeaders: mC,
  BlobDownloadExceptionHeaders: eC,
  BlobDownloadHeaders: el,
  BlobFlatListSegment: YS,
  BlobGetAccountInfoExceptionHeaders: HC,
  BlobGetAccountInfoHeaders: PC,
  BlobGetPropertiesExceptionHeaders: rC,
  BlobGetPropertiesHeaders: tC,
  BlobGetTagsExceptionHeaders: qC,
  BlobGetTagsHeaders: zC,
  BlobHierarchyListSegment: WS,
  BlobItemInternal: JS,
  BlobName: VS,
  BlobPrefix: $S,
  BlobPropertiesInternal: _S,
  BlobQueryExceptionHeaders: OC,
  BlobQueryHeaders: rl,
  BlobReleaseLeaseExceptionHeaders: yC,
  BlobReleaseLeaseHeaders: IC,
  BlobRenewLeaseExceptionHeaders: NC,
  BlobRenewLeaseHeaders: QC,
  BlobServiceProperties: $l,
  BlobServiceStatistics: _p,
  BlobSetExpiryExceptionHeaders: AC,
  BlobSetExpiryHeaders: aC,
  BlobSetHttpHeadersExceptionHeaders: lC,
  BlobSetHttpHeadersHeaders: cC,
  BlobSetImmutabilityPolicyExceptionHeaders: uC,
  BlobSetImmutabilityPolicyHeaders: dC,
  BlobSetLegalHoldExceptionHeaders: fC,
  BlobSetLegalHoldHeaders: gC,
  BlobSetMetadataExceptionHeaders: EC,
  BlobSetMetadataHeaders: pC,
  BlobSetTagsExceptionHeaders: YC,
  BlobSetTagsHeaders: GC,
  BlobSetTierExceptionHeaders: UC,
  BlobSetTierHeaders: tl,
  BlobStartCopyFromURLExceptionHeaders: MC,
  BlobStartCopyFromURLHeaders: kC,
  BlobTag: zS,
  BlobTags: Zl,
  BlobUndeleteExceptionHeaders: oC,
  BlobUndeleteHeaders: iC,
  Block: XS,
  BlockBlobCommitBlockListExceptionHeaders: bB,
  BlockBlobCommitBlockListHeaders: wB,
  BlockBlobGetBlockListExceptionHeaders: RB,
  BlockBlobGetBlockListHeaders: xB,
  BlockBlobPutBlobFromUrlExceptionHeaders: BB,
  BlockBlobPutBlobFromUrlHeaders: CB,
  BlockBlobStageBlockExceptionHeaders: yB,
  BlockBlobStageBlockFromURLExceptionHeaders: NB,
  BlockBlobStageBlockFromURLHeaders: QB,
  BlockBlobStageBlockHeaders: IB,
  BlockBlobUploadExceptionHeaders: EB,
  BlockBlobUploadHeaders: pB,
  BlockList: eE,
  BlockLookupList: jp,
  ClearRange: KS,
  ContainerAcquireLeaseExceptionHeaders: HE,
  ContainerAcquireLeaseHeaders: PE,
  ContainerBreakLeaseExceptionHeaders: JE,
  ContainerBreakLeaseHeaders: YE,
  ContainerChangeLeaseExceptionHeaders: _E,
  ContainerChangeLeaseHeaders: VE,
  ContainerCreateExceptionHeaders: CE,
  ContainerCreateHeaders: EE,
  ContainerDeleteExceptionHeaders: QE,
  ContainerDeleteHeaders: yE,
  ContainerFilterBlobsExceptionHeaders: UE,
  ContainerFilterBlobsHeaders: LE,
  ContainerGetAccessPolicyExceptionHeaders: xE,
  ContainerGetAccessPolicyHeaders: bE,
  ContainerGetAccountInfoExceptionHeaders: jE,
  ContainerGetAccountInfoHeaders: KE,
  ContainerGetPropertiesExceptionHeaders: IE,
  ContainerGetPropertiesHeaders: BE,
  ContainerItem: PS,
  ContainerListBlobFlatSegmentExceptionHeaders: $E,
  ContainerListBlobFlatSegmentHeaders: WE,
  ContainerListBlobHierarchySegmentExceptionHeaders: ZE,
  ContainerListBlobHierarchySegmentHeaders: XE,
  ContainerProperties: HS,
  ContainerReleaseLeaseExceptionHeaders: zE,
  ContainerReleaseLeaseHeaders: OE,
  ContainerRenameExceptionHeaders: TE,
  ContainerRenameHeaders: ME,
  ContainerRenewLeaseExceptionHeaders: GE,
  ContainerRenewLeaseHeaders: qE,
  ContainerRestoreExceptionHeaders: kE,
  ContainerRestoreHeaders: DE,
  ContainerSetAccessPolicyExceptionHeaders: SE,
  ContainerSetAccessPolicyHeaders: RE,
  ContainerSetMetadataExceptionHeaders: wE,
  ContainerSetMetadataHeaders: NE,
  ContainerSubmitBatchExceptionHeaders: vE,
  ContainerSubmitBatchHeaders: FE,
  CorsRule: vS,
  DelimitedTextConfiguration: tD,
  FilterBlobItem: OS,
  FilterBlobSegment: Xl,
  GeoReplication: US,
  JsonTextConfiguration: rD,
  KeyInfo: $p,
  ListBlobsFlatSegmentResponse: Zp,
  ListBlobsHierarchySegmentResponse: Kp,
  ListContainersSegmentResponse: Wp,
  Logging: MS,
  Metrics: FS,
  PageBlobClearPagesExceptionHeaders: XC,
  PageBlobClearPagesHeaders: $C,
  PageBlobCopyIncrementalExceptionHeaders: AB,
  PageBlobCopyIncrementalHeaders: aB,
  PageBlobCreateExceptionHeaders: VC,
  PageBlobCreateHeaders: JC,
  PageBlobGetPageRangesDiffExceptionHeaders: rB,
  PageBlobGetPageRangesDiffHeaders: tB,
  PageBlobGetPageRangesExceptionHeaders: eB,
  PageBlobGetPageRangesHeaders: jC,
  PageBlobResizeExceptionHeaders: sB,
  PageBlobResizeHeaders: nB,
  PageBlobUpdateSequenceNumberExceptionHeaders: oB,
  PageBlobUpdateSequenceNumberHeaders: iB,
  PageBlobUploadPagesExceptionHeaders: WC,
  PageBlobUploadPagesFromURLExceptionHeaders: KC,
  PageBlobUploadPagesFromURLHeaders: ZC,
  PageBlobUploadPagesHeaders: _C,
  PageList: Kl,
  PageRange: ZS,
  QueryFormat: eD,
  QueryRequest: tE,
  QuerySerialization: jS,
  RetentionPolicy: TS,
  ServiceFilterBlobsExceptionHeaders: pE,
  ServiceFilterBlobsHeaders: fE,
  ServiceGetAccountInfoExceptionHeaders: mE,
  ServiceGetAccountInfoHeaders: uE,
  ServiceGetPropertiesExceptionHeaders: iE,
  ServiceGetPropertiesHeaders: sE,
  ServiceGetStatisticsExceptionHeaders: aE,
  ServiceGetStatisticsHeaders: oE,
  ServiceGetUserDelegationKeyExceptionHeaders: dE,
  ServiceGetUserDelegationKeyHeaders: lE,
  ServiceListContainersSegmentExceptionHeaders: cE,
  ServiceListContainersSegmentHeaders: AE,
  ServiceSetPropertiesExceptionHeaders: nE,
  ServiceSetPropertiesHeaders: rE,
  ServiceSubmitBatchExceptionHeaders: gE,
  ServiceSubmitBatchHeaders: hE,
  SignedIdentifier: qS,
  StaticWebsite: LS,
  StorageError: Ie,
  UserDelegationKey: Xp
}, Symbol.toStringTag, { value: "Module" })), as = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
}, iD = {
  parameterPath: "blobServiceProperties",
  mapper: $l
}, rn = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
}, ye = {
  parameterPath: "url",
  mapper: {
    serializedName: "url",
    required: !0,
    xmlName: "url",
    type: {
      name: "String"
    }
  },
  skipEncoding: !0
}, bo = {
  parameterPath: "restype",
  mapper: {
    defaultValue: "service",
    isConstant: !0,
    serializedName: "restype",
    type: {
      name: "String"
    }
  }
}, nn = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "properties",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Qe = {
  parameterPath: ["options", "timeoutInSeconds"],
  mapper: {
    constraints: {
      InclusiveMinimum: 0
    },
    serializedName: "timeout",
    xmlName: "timeout",
    type: {
      name: "Number"
    }
  }
}, Ne = {
  parameterPath: "version",
  mapper: {
    defaultValue: "2026-02-06",
    isConstant: !0,
    serializedName: "x-ms-version",
    type: {
      name: "String"
    }
  }
}, we = {
  parameterPath: ["options", "requestId"],
  mapper: {
    serializedName: "x-ms-client-request-id",
    xmlName: "x-ms-client-request-id",
    type: {
      name: "String"
    }
  }
}, Me = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
}, oD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "stats",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, jl = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "list",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, ed = {
  parameterPath: ["options", "prefix"],
  mapper: {
    serializedName: "prefix",
    xmlName: "prefix",
    type: {
      name: "String"
    }
  }
}, Mn = {
  parameterPath: ["options", "marker"],
  mapper: {
    serializedName: "marker",
    xmlName: "marker",
    type: {
      name: "String"
    }
  }
}, Tn = {
  parameterPath: ["options", "maxPageSize"],
  mapper: {
    constraints: {
      InclusiveMinimum: 1
    },
    serializedName: "maxresults",
    xmlName: "maxresults",
    type: {
      name: "Number"
    }
  }
}, aD = {
  parameterPath: ["options", "include"],
  mapper: {
    serializedName: "include",
    xmlName: "include",
    xmlElementName: "ListContainersIncludeType",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: ["metadata", "deleted", "system"]
        }
      }
    }
  },
  collectionFormat: "CSV"
}, AD = {
  parameterPath: "keyInfo",
  mapper: $p
}, cD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "userdelegationkey",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, td = {
  parameterPath: "restype",
  mapper: {
    defaultValue: "account",
    isConstant: !0,
    serializedName: "restype",
    type: {
      name: "String"
    }
  }
}, SB = {
  parameterPath: "body",
  mapper: {
    serializedName: "body",
    required: !0,
    xmlName: "body",
    type: {
      name: "Stream"
    }
  }
}, DB = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "batch",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, ar = {
  parameterPath: "contentLength",
  mapper: {
    serializedName: "Content-Length",
    required: !0,
    xmlName: "Content-Length",
    type: {
      name: "Number"
    }
  }
}, kB = {
  parameterPath: "multipartContentType",
  mapper: {
    serializedName: "Content-Type",
    required: !0,
    xmlName: "Content-Type",
    type: {
      name: "String"
    }
  }
}, MB = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "blobs",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, TB = {
  parameterPath: ["options", "where"],
  mapper: {
    serializedName: "where",
    xmlName: "where",
    type: {
      name: "String"
    }
  }
}, Ut = {
  parameterPath: "restype",
  mapper: {
    defaultValue: "container",
    isConstant: !0,
    serializedName: "restype",
    type: {
      name: "String"
    }
  }
}, yr = {
  parameterPath: ["options", "metadata"],
  mapper: {
    serializedName: "x-ms-meta",
    xmlName: "x-ms-meta",
    headerCollectionPrefix: "x-ms-meta-",
    type: {
      name: "Dictionary",
      value: { type: { name: "String" } }
    }
  }
}, FB = {
  parameterPath: ["options", "access"],
  mapper: {
    serializedName: "x-ms-blob-public-access",
    xmlName: "x-ms-blob-public-access",
    type: {
      name: "Enum",
      allowedValues: ["container", "blob"]
    }
  }
}, lD = {
  parameterPath: [
    "options",
    "containerEncryptionScope",
    "defaultEncryptionScope"
  ],
  mapper: {
    serializedName: "x-ms-default-encryption-scope",
    xmlName: "x-ms-default-encryption-scope",
    type: {
      name: "String"
    }
  }
}, dD = {
  parameterPath: [
    "options",
    "containerEncryptionScope",
    "preventEncryptionScopeOverride"
  ],
  mapper: {
    serializedName: "x-ms-deny-encryption-scope-override",
    xmlName: "x-ms-deny-encryption-scope-override",
    type: {
      name: "Boolean"
    }
  }
}, Ke = {
  parameterPath: ["options", "leaseAccessConditions", "leaseId"],
  mapper: {
    serializedName: "x-ms-lease-id",
    xmlName: "x-ms-lease-id",
    type: {
      name: "String"
    }
  }
}, Je = {
  parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
  mapper: {
    serializedName: "If-Modified-Since",
    xmlName: "If-Modified-Since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, Ve = {
  parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
  mapper: {
    serializedName: "If-Unmodified-Since",
    xmlName: "If-Unmodified-Since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, vB = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "metadata",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, LB = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "acl",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, uD = {
  parameterPath: ["options", "containerAcl"],
  mapper: {
    serializedName: "containerAcl",
    xmlName: "SignedIdentifiers",
    xmlIsWrapped: !0,
    xmlElementName: "SignedIdentifier",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Composite",
          className: "SignedIdentifier"
        }
      }
    }
  }
}, UB = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "undelete",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, mD = {
  parameterPath: ["options", "deletedContainerName"],
  mapper: {
    serializedName: "x-ms-deleted-container-name",
    xmlName: "x-ms-deleted-container-name",
    type: {
      name: "String"
    }
  }
}, hD = {
  parameterPath: ["options", "deletedContainerVersion"],
  mapper: {
    serializedName: "x-ms-deleted-container-version",
    xmlName: "x-ms-deleted-container-version",
    type: {
      name: "String"
    }
  }
}, gD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "rename",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, fD = {
  parameterPath: "sourceContainerName",
  mapper: {
    serializedName: "x-ms-source-container-name",
    required: !0,
    xmlName: "x-ms-source-container-name",
    type: {
      name: "String"
    }
  }
}, pD = {
  parameterPath: ["options", "sourceLeaseId"],
  mapper: {
    serializedName: "x-ms-source-lease-id",
    xmlName: "x-ms-source-lease-id",
    type: {
      name: "String"
    }
  }
}, Mr = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "lease",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, PB = {
  parameterPath: "action",
  mapper: {
    defaultValue: "acquire",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, HB = {
  parameterPath: ["options", "duration"],
  mapper: {
    serializedName: "x-ms-lease-duration",
    xmlName: "x-ms-lease-duration",
    type: {
      name: "Number"
    }
  }
}, OB = {
  parameterPath: ["options", "proposedLeaseId"],
  mapper: {
    serializedName: "x-ms-proposed-lease-id",
    xmlName: "x-ms-proposed-lease-id",
    type: {
      name: "String"
    }
  }
}, zB = {
  parameterPath: "action",
  mapper: {
    defaultValue: "release",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, As = {
  parameterPath: "leaseId",
  mapper: {
    serializedName: "x-ms-lease-id",
    required: !0,
    xmlName: "x-ms-lease-id",
    type: {
      name: "String"
    }
  }
}, qB = {
  parameterPath: "action",
  mapper: {
    defaultValue: "renew",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, GB = {
  parameterPath: "action",
  mapper: {
    defaultValue: "break",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, YB = {
  parameterPath: ["options", "breakPeriod"],
  mapper: {
    serializedName: "x-ms-lease-break-period",
    xmlName: "x-ms-lease-break-period",
    type: {
      name: "Number"
    }
  }
}, JB = {
  parameterPath: "action",
  mapper: {
    defaultValue: "change",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, VB = {
  parameterPath: "proposedLeaseId",
  mapper: {
    serializedName: "x-ms-proposed-lease-id",
    required: !0,
    xmlName: "x-ms-proposed-lease-id",
    type: {
      name: "String"
    }
  }
}, _B = {
  parameterPath: ["options", "include"],
  mapper: {
    serializedName: "include",
    xmlName: "include",
    xmlElementName: "ListBlobsIncludeItem",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: [
            "copy",
            "deleted",
            "metadata",
            "snapshots",
            "uncommittedblobs",
            "versions",
            "tags",
            "immutabilitypolicy",
            "legalhold",
            "deletedwithversions"
          ]
        }
      }
    }
  },
  collectionFormat: "CSV"
}, WB = {
  parameterPath: ["options", "startFrom"],
  mapper: {
    serializedName: "startFrom",
    xmlName: "startFrom",
    type: {
      name: "String"
    }
  }
}, ED = {
  parameterPath: "delimiter",
  mapper: {
    serializedName: "delimiter",
    required: !0,
    xmlName: "delimiter",
    type: {
      name: "String"
    }
  }
}, hr = {
  parameterPath: ["options", "snapshot"],
  mapper: {
    serializedName: "snapshot",
    xmlName: "snapshot",
    type: {
      name: "String"
    }
  }
}, qr = {
  parameterPath: ["options", "versionId"],
  mapper: {
    serializedName: "versionid",
    xmlName: "versionid",
    type: {
      name: "String"
    }
  }
}, ai = {
  parameterPath: ["options", "range"],
  mapper: {
    serializedName: "x-ms-range",
    xmlName: "x-ms-range",
    type: {
      name: "String"
    }
  }
}, CD = {
  parameterPath: ["options", "rangeGetContentMD5"],
  mapper: {
    serializedName: "x-ms-range-get-content-md5",
    xmlName: "x-ms-range-get-content-md5",
    type: {
      name: "Boolean"
    }
  }
}, BD = {
  parameterPath: ["options", "rangeGetContentCRC64"],
  mapper: {
    serializedName: "x-ms-range-get-content-crc64",
    xmlName: "x-ms-range-get-content-crc64",
    type: {
      name: "Boolean"
    }
  }
}, kt = {
  parameterPath: ["options", "cpkInfo", "encryptionKey"],
  mapper: {
    serializedName: "x-ms-encryption-key",
    xmlName: "x-ms-encryption-key",
    type: {
      name: "String"
    }
  }
}, Mt = {
  parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
  mapper: {
    serializedName: "x-ms-encryption-key-sha256",
    xmlName: "x-ms-encryption-key-sha256",
    type: {
      name: "String"
    }
  }
}, Tt = {
  parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
  mapper: {
    serializedName: "x-ms-encryption-algorithm",
    xmlName: "x-ms-encryption-algorithm",
    type: {
      name: "String"
    }
  }
}, ot = {
  parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
  mapper: {
    serializedName: "If-Match",
    xmlName: "If-Match",
    type: {
      name: "String"
    }
  }
}, at = {
  parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
  mapper: {
    serializedName: "If-None-Match",
    xmlName: "If-None-Match",
    type: {
      name: "String"
    }
  }
}, et = {
  parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
  mapper: {
    serializedName: "x-ms-if-tags",
    xmlName: "x-ms-if-tags",
    type: {
      name: "String"
    }
  }
}, ID = {
  parameterPath: ["options", "deleteSnapshots"],
  mapper: {
    serializedName: "x-ms-delete-snapshots",
    xmlName: "x-ms-delete-snapshots",
    type: {
      name: "Enum",
      allowedValues: ["include", "only"]
    }
  }
}, yD = {
  parameterPath: ["options", "blobDeleteType"],
  mapper: {
    serializedName: "deletetype",
    xmlName: "deletetype",
    type: {
      name: "String"
    }
  }
}, QD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "expiry",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, ND = {
  parameterPath: "expiryOptions",
  mapper: {
    serializedName: "x-ms-expiry-option",
    required: !0,
    xmlName: "x-ms-expiry-option",
    type: {
      name: "String"
    }
  }
}, wD = {
  parameterPath: ["options", "expiresOn"],
  mapper: {
    serializedName: "x-ms-expiry-time",
    xmlName: "x-ms-expiry-time",
    type: {
      name: "String"
    }
  }
}, cs = {
  parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
  mapper: {
    serializedName: "x-ms-blob-cache-control",
    xmlName: "x-ms-blob-cache-control",
    type: {
      name: "String"
    }
  }
}, ls = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
  mapper: {
    serializedName: "x-ms-blob-content-type",
    xmlName: "x-ms-blob-content-type",
    type: {
      name: "String"
    }
  }
}, ds = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
  mapper: {
    serializedName: "x-ms-blob-content-md5",
    xmlName: "x-ms-blob-content-md5",
    type: {
      name: "ByteArray"
    }
  }
}, us = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
  mapper: {
    serializedName: "x-ms-blob-content-encoding",
    xmlName: "x-ms-blob-content-encoding",
    type: {
      name: "String"
    }
  }
}, ms = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
  mapper: {
    serializedName: "x-ms-blob-content-language",
    xmlName: "x-ms-blob-content-language",
    type: {
      name: "String"
    }
  }
}, hs = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
  mapper: {
    serializedName: "x-ms-blob-content-disposition",
    xmlName: "x-ms-blob-content-disposition",
    type: {
      name: "String"
    }
  }
}, $B = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "immutabilityPolicies",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Fn = {
  parameterPath: ["options", "immutabilityPolicyExpiry"],
  mapper: {
    serializedName: "x-ms-immutability-policy-until-date",
    xmlName: "x-ms-immutability-policy-until-date",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, vn = {
  parameterPath: ["options", "immutabilityPolicyMode"],
  mapper: {
    serializedName: "x-ms-immutability-policy-mode",
    xmlName: "x-ms-immutability-policy-mode",
    type: {
      name: "Enum",
      allowedValues: ["Mutable", "Unlocked", "Locked"]
    }
  }
}, bD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "legalhold",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, xD = {
  parameterPath: "legalHold",
  mapper: {
    serializedName: "x-ms-legal-hold",
    required: !0,
    xmlName: "x-ms-legal-hold",
    type: {
      name: "Boolean"
    }
  }
}, qt = {
  parameterPath: ["options", "encryptionScope"],
  mapper: {
    serializedName: "x-ms-encryption-scope",
    xmlName: "x-ms-encryption-scope",
    type: {
      name: "String"
    }
  }
}, RD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "snapshot",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, gs = {
  parameterPath: ["options", "tier"],
  mapper: {
    serializedName: "x-ms-access-tier",
    xmlName: "x-ms-access-tier",
    type: {
      name: "Enum",
      allowedValues: [
        "P4",
        "P6",
        "P10",
        "P15",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "Hot",
        "Cool",
        "Archive",
        "Cold"
      ]
    }
  }
}, XB = {
  parameterPath: ["options", "rehydratePriority"],
  mapper: {
    serializedName: "x-ms-rehydrate-priority",
    xmlName: "x-ms-rehydrate-priority",
    type: {
      name: "Enum",
      allowedValues: ["High", "Standard"]
    }
  }
}, fs = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfModifiedSince"
  ],
  mapper: {
    serializedName: "x-ms-source-if-modified-since",
    xmlName: "x-ms-source-if-modified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, ps = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfUnmodifiedSince"
  ],
  mapper: {
    serializedName: "x-ms-source-if-unmodified-since",
    xmlName: "x-ms-source-if-unmodified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, Es = {
  parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
  mapper: {
    serializedName: "x-ms-source-if-match",
    xmlName: "x-ms-source-if-match",
    type: {
      name: "String"
    }
  }
}, Cs = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfNoneMatch"
  ],
  mapper: {
    serializedName: "x-ms-source-if-none-match",
    xmlName: "x-ms-source-if-none-match",
    type: {
      name: "String"
    }
  }
}, ZB = {
  parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
  mapper: {
    serializedName: "x-ms-source-if-tags",
    xmlName: "x-ms-source-if-tags",
    type: {
      name: "String"
    }
  }
}, xo = {
  parameterPath: "copySource",
  mapper: {
    serializedName: "x-ms-copy-source",
    required: !0,
    xmlName: "x-ms-copy-source",
    type: {
      name: "String"
    }
  }
}, Ln = {
  parameterPath: ["options", "blobTagsString"],
  mapper: {
    serializedName: "x-ms-tags",
    xmlName: "x-ms-tags",
    type: {
      name: "String"
    }
  }
}, SD = {
  parameterPath: ["options", "sealBlob"],
  mapper: {
    serializedName: "x-ms-seal-blob",
    xmlName: "x-ms-seal-blob",
    type: {
      name: "Boolean"
    }
  }
}, Bs = {
  parameterPath: ["options", "legalHold"],
  mapper: {
    serializedName: "x-ms-legal-hold",
    xmlName: "x-ms-legal-hold",
    type: {
      name: "Boolean"
    }
  }
}, DD = {
  parameterPath: "xMsRequiresSync",
  mapper: {
    defaultValue: "true",
    isConstant: !0,
    serializedName: "x-ms-requires-sync",
    type: {
      name: "String"
    }
  }
}, Ai = {
  parameterPath: ["options", "sourceContentMD5"],
  mapper: {
    serializedName: "x-ms-source-content-md5",
    xmlName: "x-ms-source-content-md5",
    type: {
      name: "ByteArray"
    }
  }
}, ci = {
  parameterPath: ["options", "copySourceAuthorization"],
  mapper: {
    serializedName: "x-ms-copy-source-authorization",
    xmlName: "x-ms-copy-source-authorization",
    type: {
      name: "String"
    }
  }
}, KB = {
  parameterPath: ["options", "copySourceTags"],
  mapper: {
    serializedName: "x-ms-copy-source-tag-option",
    xmlName: "x-ms-copy-source-tag-option",
    type: {
      name: "Enum",
      allowedValues: ["REPLACE", "COPY"]
    }
  }
}, li = {
  parameterPath: ["options", "fileRequestIntent"],
  mapper: {
    serializedName: "x-ms-file-request-intent",
    xmlName: "x-ms-file-request-intent",
    type: {
      name: "String"
    }
  }
}, kD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "copy",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, MD = {
  parameterPath: "copyActionAbortConstant",
  mapper: {
    defaultValue: "abort",
    isConstant: !0,
    serializedName: "x-ms-copy-action",
    type: {
      name: "String"
    }
  }
}, TD = {
  parameterPath: "copyId",
  mapper: {
    serializedName: "copyid",
    required: !0,
    xmlName: "copyid",
    type: {
      name: "String"
    }
  }
}, FD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "tier",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, vD = {
  parameterPath: "tier",
  mapper: {
    serializedName: "x-ms-access-tier",
    required: !0,
    xmlName: "x-ms-access-tier",
    type: {
      name: "Enum",
      allowedValues: [
        "P4",
        "P6",
        "P10",
        "P15",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "Hot",
        "Cool",
        "Archive",
        "Cold"
      ]
    }
  }
}, LD = {
  parameterPath: ["options", "queryRequest"],
  mapper: tE
}, UD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "query",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, jB = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "tags",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, eI = {
  parameterPath: ["options", "blobModifiedAccessConditions", "ifModifiedSince"],
  mapper: {
    serializedName: "x-ms-blob-if-modified-since",
    xmlName: "x-ms-blob-if-modified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, tI = {
  parameterPath: [
    "options",
    "blobModifiedAccessConditions",
    "ifUnmodifiedSince"
  ],
  mapper: {
    serializedName: "x-ms-blob-if-unmodified-since",
    xmlName: "x-ms-blob-if-unmodified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, rI = {
  parameterPath: ["options", "blobModifiedAccessConditions", "ifMatch"],
  mapper: {
    serializedName: "x-ms-blob-if-match",
    xmlName: "x-ms-blob-if-match",
    type: {
      name: "String"
    }
  }
}, nI = {
  parameterPath: ["options", "blobModifiedAccessConditions", "ifNoneMatch"],
  mapper: {
    serializedName: "x-ms-blob-if-none-match",
    xmlName: "x-ms-blob-if-none-match",
    type: {
      name: "String"
    }
  }
}, PD = {
  parameterPath: ["options", "tags"],
  mapper: Zl
}, sn = {
  parameterPath: ["options", "transactionalContentMD5"],
  mapper: {
    serializedName: "Content-MD5",
    xmlName: "Content-MD5",
    type: {
      name: "ByteArray"
    }
  }
}, Is = {
  parameterPath: ["options", "transactionalContentCrc64"],
  mapper: {
    serializedName: "x-ms-content-crc64",
    xmlName: "x-ms-content-crc64",
    type: {
      name: "ByteArray"
    }
  }
}, HD = {
  parameterPath: "blobType",
  mapper: {
    defaultValue: "PageBlob",
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    type: {
      name: "String"
    }
  }
}, sI = {
  parameterPath: "blobContentLength",
  mapper: {
    serializedName: "x-ms-blob-content-length",
    required: !0,
    xmlName: "x-ms-blob-content-length",
    type: {
      name: "Number"
    }
  }
}, iI = {
  parameterPath: ["options", "blobSequenceNumber"],
  mapper: {
    defaultValue: 0,
    serializedName: "x-ms-blob-sequence-number",
    xmlName: "x-ms-blob-sequence-number",
    type: {
      name: "Number"
    }
  }
}, Ro = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/octet-stream",
    isConstant: !0,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
}, So = {
  parameterPath: "body",
  mapper: {
    serializedName: "body",
    required: !0,
    xmlName: "body",
    type: {
      name: "Stream"
    }
  }
}, Do = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
}, rd = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "page",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, oI = {
  parameterPath: "pageWrite",
  mapper: {
    defaultValue: "update",
    isConstant: !0,
    serializedName: "x-ms-page-write",
    type: {
      name: "String"
    }
  }
}, nd = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberLessThanOrEqualTo"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-le",
    xmlName: "x-ms-if-sequence-number-le",
    type: {
      name: "Number"
    }
  }
}, sd = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberLessThan"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-lt",
    xmlName: "x-ms-if-sequence-number-lt",
    type: {
      name: "Number"
    }
  }
}, id = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberEqualTo"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-eq",
    xmlName: "x-ms-if-sequence-number-eq",
    type: {
      name: "Number"
    }
  }
}, OD = {
  parameterPath: "pageWrite",
  mapper: {
    defaultValue: "clear",
    isConstant: !0,
    serializedName: "x-ms-page-write",
    type: {
      name: "String"
    }
  }
}, od = {
  parameterPath: "sourceUrl",
  mapper: {
    serializedName: "x-ms-copy-source",
    required: !0,
    xmlName: "x-ms-copy-source",
    type: {
      name: "String"
    }
  }
}, zD = {
  parameterPath: "sourceRange",
  mapper: {
    serializedName: "x-ms-source-range",
    required: !0,
    xmlName: "x-ms-source-range",
    type: {
      name: "String"
    }
  }
}, ad = {
  parameterPath: ["options", "sourceContentCrc64"],
  mapper: {
    serializedName: "x-ms-source-content-crc64",
    xmlName: "x-ms-source-content-crc64",
    type: {
      name: "ByteArray"
    }
  }
}, qD = {
  parameterPath: "range",
  mapper: {
    serializedName: "x-ms-range",
    required: !0,
    xmlName: "x-ms-range",
    type: {
      name: "String"
    }
  }
}, aI = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "pagelist",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, GD = {
  parameterPath: ["options", "prevsnapshot"],
  mapper: {
    serializedName: "prevsnapshot",
    xmlName: "prevsnapshot",
    type: {
      name: "String"
    }
  }
}, YD = {
  parameterPath: ["options", "prevSnapshotUrl"],
  mapper: {
    serializedName: "x-ms-previous-snapshot-url",
    xmlName: "x-ms-previous-snapshot-url",
    type: {
      name: "String"
    }
  }
}, JD = {
  parameterPath: "sequenceNumberAction",
  mapper: {
    serializedName: "x-ms-sequence-number-action",
    required: !0,
    xmlName: "x-ms-sequence-number-action",
    type: {
      name: "Enum",
      allowedValues: ["max", "update", "increment"]
    }
  }
}, VD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "incrementalcopy",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, _D = {
  parameterPath: "blobType",
  mapper: {
    defaultValue: "AppendBlob",
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    type: {
      name: "String"
    }
  }
}, AI = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "appendblock",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, cI = {
  parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
  mapper: {
    serializedName: "x-ms-blob-condition-maxsize",
    xmlName: "x-ms-blob-condition-maxsize",
    type: {
      name: "Number"
    }
  }
}, Ad = {
  parameterPath: [
    "options",
    "appendPositionAccessConditions",
    "appendPosition"
  ],
  mapper: {
    serializedName: "x-ms-blob-condition-appendpos",
    xmlName: "x-ms-blob-condition-appendpos",
    type: {
      name: "Number"
    }
  }
}, lI = {
  parameterPath: ["options", "sourceRange"],
  mapper: {
    serializedName: "x-ms-source-range",
    xmlName: "x-ms-source-range",
    type: {
      name: "String"
    }
  }
}, WD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "seal",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, dI = {
  parameterPath: "blobType",
  mapper: {
    defaultValue: "BlockBlob",
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    type: {
      name: "String"
    }
  }
}, $D = {
  parameterPath: ["options", "copySourceBlobProperties"],
  mapper: {
    serializedName: "x-ms-copy-source-blob-properties",
    xmlName: "x-ms-copy-source-blob-properties",
    type: {
      name: "Boolean"
    }
  }
}, uI = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "block",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, mI = {
  parameterPath: "blockId",
  mapper: {
    serializedName: "blockid",
    required: !0,
    xmlName: "blockid",
    type: {
      name: "String"
    }
  }
}, XD = {
  parameterPath: "blocks",
  mapper: jp
}, hI = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "blocklist",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, ZD = {
  parameterPath: "listType",
  mapper: {
    defaultValue: "committed",
    serializedName: "blocklisttype",
    required: !0,
    xmlName: "blocklisttype",
    type: {
      name: "Enum",
      allowedValues: ["committed", "uncommitted", "all"]
    }
  }
};
class KD {
  client;
  /**
   * Initialize a new instance of the class Service class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * Sets properties for a storage account's Blob service endpoint, including properties for Storage
   * Analytics and CORS (Cross-Origin Resource Sharing) rules
   * @param blobServiceProperties The StorageService properties.
   * @param options The options parameters.
   */
  setProperties(e, r) {
    return this.client.sendOperationRequest({ blobServiceProperties: e, options: r }, jD);
  }
  /**
   * gets the properties of a storage account's Blob service, including properties for Storage Analytics
   * and CORS (Cross-Origin Resource Sharing) rules.
   * @param options The options parameters.
   */
  getProperties(e) {
    return this.client.sendOperationRequest({ options: e }, ek);
  }
  /**
   * Retrieves statistics related to replication for the Blob service. It is only available on the
   * secondary location endpoint when read-access geo-redundant replication is enabled for the storage
   * account.
   * @param options The options parameters.
   */
  getStatistics(e) {
    return this.client.sendOperationRequest({ options: e }, tk);
  }
  /**
   * The List Containers Segment operation returns a list of the containers under the specified account
   * @param options The options parameters.
   */
  listContainersSegment(e) {
    return this.client.sendOperationRequest({ options: e }, rk);
  }
  /**
   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
   * bearer token authentication.
   * @param keyInfo Key information
   * @param options The options parameters.
   */
  getUserDelegationKey(e, r) {
    return this.client.sendOperationRequest({ keyInfo: e, options: r }, nk);
  }
  /**
   * Returns the sku name and account kind
   * @param options The options parameters.
   */
  getAccountInfo(e) {
    return this.client.sendOperationRequest({ options: e }, sk);
  }
  /**
   * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
   * @param contentLength The length of the request.
   * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
   *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
   * @param body Initial data
   * @param options The options parameters.
   */
  submitBatch(e, r, n, s) {
    return this.client.sendOperationRequest({ contentLength: e, multipartContentType: r, body: n, options: s }, ik);
  }
  /**
   * The Filter Blobs operation enables callers to list blobs across all containers whose tags match a
   * given search expression.  Filter blobs searches across all containers within a storage account but
   * can be scoped within the expression to a single container.
   * @param options The options parameters.
   */
  filterBlobs(e) {
    return this.client.sendOperationRequest({ options: e }, ok);
  }
}
const on = ss(
  os,
  /* isXml */
  !0
), jD = {
  path: "/",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: rE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: nE
    }
  },
  requestBody: iD,
  queryParameters: [
    bo,
    nn,
    Qe
  ],
  urlParameters: [ye],
  headerParameters: [
    as,
    rn,
    Ne,
    we
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: on
}, ek = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: $l,
      headersMapper: sE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: iE
    }
  },
  queryParameters: [
    bo,
    nn,
    Qe
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: on
}, tk = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: _p,
      headersMapper: oE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: aE
    }
  },
  queryParameters: [
    bo,
    Qe,
    oD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: on
}, rk = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Wp,
      headersMapper: AE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: cE
    }
  },
  queryParameters: [
    Qe,
    jl,
    ed,
    Mn,
    Tn,
    aD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: on
}, nk = {
  path: "/",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Xp,
      headersMapper: lE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: dE
    }
  },
  requestBody: AD,
  queryParameters: [
    bo,
    Qe,
    cD
  ],
  urlParameters: [ye],
  headerParameters: [
    as,
    rn,
    Ne,
    we
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: on
}, sk = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: uE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: mE
    }
  },
  queryParameters: [
    nn,
    Qe,
    td
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: on
}, ik = {
  path: "/",
  httpMethod: "POST",
  responses: {
    202: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: hE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: gE
    }
  },
  requestBody: SB,
  queryParameters: [Qe, DB],
  urlParameters: [ye],
  headerParameters: [
    rn,
    Ne,
    we,
    ar,
    kB
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: on
}, ok = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Xl,
      headersMapper: fE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: pE
    }
  },
  queryParameters: [
    Qe,
    Mn,
    Tn,
    MB,
    TB
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: on
};
class ak {
  client;
  /**
   * Initialize a new instance of the class Container class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * creates a new container under the specified account. If the container with the same name already
   * exists, the operation fails
   * @param options The options parameters.
   */
  create(e) {
    return this.client.sendOperationRequest({ options: e }, Ak);
  }
  /**
   * returns all user-defined metadata and system properties for the specified container. The data
   * returned does not include the container's list of blobs
   * @param options The options parameters.
   */
  getProperties(e) {
    return this.client.sendOperationRequest({ options: e }, ck);
  }
  /**
   * operation marks the specified container for deletion. The container and any blobs contained within
   * it are later deleted during garbage collection
   * @param options The options parameters.
   */
  delete(e) {
    return this.client.sendOperationRequest({ options: e }, lk);
  }
  /**
   * operation sets one or more user-defined name-value pairs for the specified container.
   * @param options The options parameters.
   */
  setMetadata(e) {
    return this.client.sendOperationRequest({ options: e }, dk);
  }
  /**
   * gets the permissions for the specified container. The permissions indicate whether container data
   * may be accessed publicly.
   * @param options The options parameters.
   */
  getAccessPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, uk);
  }
  /**
   * sets the permissions for the specified container. The permissions indicate whether blobs in a
   * container may be accessed publicly.
   * @param options The options parameters.
   */
  setAccessPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, mk);
  }
  /**
   * Restores a previously-deleted container.
   * @param options The options parameters.
   */
  restore(e) {
    return this.client.sendOperationRequest({ options: e }, hk);
  }
  /**
   * Renames an existing container.
   * @param sourceContainerName Required.  Specifies the name of the container to rename.
   * @param options The options parameters.
   */
  rename(e, r) {
    return this.client.sendOperationRequest({ sourceContainerName: e, options: r }, gk);
  }
  /**
   * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
   * @param contentLength The length of the request.
   * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
   *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
   * @param body Initial data
   * @param options The options parameters.
   */
  submitBatch(e, r, n, s) {
    return this.client.sendOperationRequest({ contentLength: e, multipartContentType: r, body: n, options: s }, fk);
  }
  /**
   * The Filter Blobs operation enables callers to list blobs in a container whose tags match a given
   * search expression.  Filter blobs searches within the given container.
   * @param options The options parameters.
   */
  filterBlobs(e) {
    return this.client.sendOperationRequest({ options: e }, pk);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param options The options parameters.
   */
  acquireLease(e) {
    return this.client.sendOperationRequest({ options: e }, Ek);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  releaseLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, Ck);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  renewLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, Bk);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param options The options parameters.
   */
  breakLease(e) {
    return this.client.sendOperationRequest({ options: e }, Ik);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param leaseId Specifies the current lease ID on the resource.
   * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
   *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
   *                        (String) for a list of valid GUID string formats.
   * @param options The options parameters.
   */
  changeLease(e, r, n) {
    return this.client.sendOperationRequest({ leaseId: e, proposedLeaseId: r, options: n }, yk);
  }
  /**
   * [Update] The List Blobs operation returns a list of the blobs under the specified container
   * @param options The options parameters.
   */
  listBlobFlatSegment(e) {
    return this.client.sendOperationRequest({ options: e }, Qk);
  }
  /**
   * [Update] The List Blobs operation returns a list of the blobs under the specified container
   * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix
   *                  element in the response body that acts as a placeholder for all blobs whose names begin with the
   *                  same substring up to the appearance of the delimiter character. The delimiter may be a single
   *                  character or a string.
   * @param options The options parameters.
   */
  listBlobHierarchySegment(e, r) {
    return this.client.sendOperationRequest({ delimiter: e, options: r }, Nk);
  }
  /**
   * Returns the sku name and account kind
   * @param options The options parameters.
   */
  getAccountInfo(e) {
    return this.client.sendOperationRequest({ options: e }, wk);
  }
}
const Ft = ss(
  os,
  /* isXml */
  !0
), Ak = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: EE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: CE
    }
  },
  queryParameters: [Qe, Ut],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    yr,
    FB,
    lD,
    dD
  ],
  isXML: !0,
  serializer: Ft
}, ck = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: BE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: IE
    }
  },
  queryParameters: [Qe, Ut],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke
  ],
  isXML: !0,
  serializer: Ft
}, lk = {
  path: "/{containerName}",
  httpMethod: "DELETE",
  responses: {
    202: {
      headersMapper: yE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: QE
    }
  },
  queryParameters: [Qe, Ut],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve
  ],
  isXML: !0,
  serializer: Ft
}, dk = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: NE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: wE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    vB
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    yr,
    Ke,
    Je
  ],
  isXML: !0,
  serializer: Ft
}, uk = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: { name: "Composite", className: "SignedIdentifier" }
          }
        },
        serializedName: "SignedIdentifiers",
        xmlName: "SignedIdentifiers",
        xmlIsWrapped: !0,
        xmlElementName: "SignedIdentifier"
      },
      headersMapper: bE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: xE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    LB
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke
  ],
  isXML: !0,
  serializer: Ft
}, mk = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: RE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: SE
    }
  },
  requestBody: uD,
  queryParameters: [
    Qe,
    Ut,
    LB
  ],
  urlParameters: [ye],
  headerParameters: [
    as,
    rn,
    Ne,
    we,
    FB,
    Ke,
    Je,
    Ve
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: Ft
}, hk = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: DE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: kE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    UB
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    mD,
    hD
  ],
  isXML: !0,
  serializer: Ft
}, gk = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: ME
    },
    default: {
      bodyMapper: Ie,
      headersMapper: TE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    gD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    fD,
    pD
  ],
  isXML: !0,
  serializer: Ft
}, fk = {
  path: "/{containerName}",
  httpMethod: "POST",
  responses: {
    202: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: FE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: vE
    }
  },
  requestBody: SB,
  queryParameters: [
    Qe,
    DB,
    Ut
  ],
  urlParameters: [ye],
  headerParameters: [
    rn,
    Ne,
    we,
    ar,
    kB
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: Ft
}, pk = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Xl,
      headersMapper: LE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: UE
    }
  },
  queryParameters: [
    Qe,
    Mn,
    Tn,
    MB,
    TB,
    Ut
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: Ft
}, Ek = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: PE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: HE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    Mr
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    PB,
    HB,
    OB
  ],
  isXML: !0,
  serializer: Ft
}, Ck = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: OE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: zE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    Mr
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    zB,
    As
  ],
  isXML: !0,
  serializer: Ft
}, Bk = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: qE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: GE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    Mr
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    As,
    qB
  ],
  isXML: !0,
  serializer: Ft
}, Ik = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: YE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: JE
    }
  },
  queryParameters: [
    Qe,
    Ut,
    Mr
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    GB,
    YB
  ],
  isXML: !0,
  serializer: Ft
}, yk = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: VE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: _E
    }
  },
  queryParameters: [
    Qe,
    Ut,
    Mr
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    As,
    JB,
    VB
  ],
  isXML: !0,
  serializer: Ft
}, Qk = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Zp,
      headersMapper: WE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: $E
    }
  },
  queryParameters: [
    Qe,
    jl,
    ed,
    Mn,
    Tn,
    Ut,
    _B,
    WB
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: Ft
}, Nk = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Kp,
      headersMapper: XE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: ZE
    }
  },
  queryParameters: [
    Qe,
    jl,
    ed,
    Mn,
    Tn,
    Ut,
    _B,
    WB,
    ED
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: Ft
}, wk = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: KE
    },
    default: {
      bodyMapper: Ie,
      headersMapper: jE
    }
  },
  queryParameters: [
    nn,
    Qe,
    td
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: Ft
};
class bk {
  client;
  /**
   * Initialize a new instance of the class Blob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Download operation reads or downloads a blob from the system, including its metadata and
   * properties. You can also call Download to read a snapshot.
   * @param options The options parameters.
   */
  download(e) {
    return this.client.sendOperationRequest({ options: e }, xk);
  }
  /**
   * The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system
   * properties for the blob. It does not return the content of the blob.
   * @param options The options parameters.
   */
  getProperties(e) {
    return this.client.sendOperationRequest({ options: e }, Rk);
  }
  /**
   * If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
   * permanently removed from the storage account. If the storage account's soft delete feature is
   * enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
   * immediately. However, the blob service retains the blob or snapshot for the number of days specified
   * by the DeleteRetentionPolicy section of [Storage service properties]
   * (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is
   * permanently removed from the storage account. Note that you continue to be charged for the
   * soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the
   * "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You
   * can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a
   * soft-deleted blob or snapshot causes the service to return an HTTP status code of 404
   * (ResourceNotFound).
   * @param options The options parameters.
   */
  delete(e) {
    return this.client.sendOperationRequest({ options: e }, Sk);
  }
  /**
   * Undelete a blob that was previously soft deleted
   * @param options The options parameters.
   */
  undelete(e) {
    return this.client.sendOperationRequest({ options: e }, Dk);
  }
  /**
   * Sets the time a blob will expire and be deleted.
   * @param expiryOptions Required. Indicates mode of the expiry time
   * @param options The options parameters.
   */
  setExpiry(e, r) {
    return this.client.sendOperationRequest({ expiryOptions: e, options: r }, kk);
  }
  /**
   * The Set HTTP Headers operation sets system properties on the blob
   * @param options The options parameters.
   */
  setHttpHeaders(e) {
    return this.client.sendOperationRequest({ options: e }, Mk);
  }
  /**
   * The Set Immutability Policy operation sets the immutability policy on the blob
   * @param options The options parameters.
   */
  setImmutabilityPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, Tk);
  }
  /**
   * The Delete Immutability Policy operation deletes the immutability policy on the blob
   * @param options The options parameters.
   */
  deleteImmutabilityPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, Fk);
  }
  /**
   * The Set Legal Hold operation sets a legal hold on the blob.
   * @param legalHold Specified if a legal hold should be set on the blob.
   * @param options The options parameters.
   */
  setLegalHold(e, r) {
    return this.client.sendOperationRequest({ legalHold: e, options: r }, vk);
  }
  /**
   * The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more
   * name-value pairs
   * @param options The options parameters.
   */
  setMetadata(e) {
    return this.client.sendOperationRequest({ options: e }, Lk);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param options The options parameters.
   */
  acquireLease(e) {
    return this.client.sendOperationRequest({ options: e }, Uk);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  releaseLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, Pk);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  renewLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, Hk);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
   *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
   *                        (String) for a list of valid GUID string formats.
   * @param options The options parameters.
   */
  changeLease(e, r, n) {
    return this.client.sendOperationRequest({ leaseId: e, proposedLeaseId: r, options: n }, Ok);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param options The options parameters.
   */
  breakLease(e) {
    return this.client.sendOperationRequest({ options: e }, zk);
  }
  /**
   * The Create Snapshot operation creates a read-only snapshot of a blob
   * @param options The options parameters.
   */
  createSnapshot(e) {
    return this.client.sendOperationRequest({ options: e }, qk);
  }
  /**
   * The Start Copy From URL operation copies a blob or an internet resource to a new blob.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  startCopyFromURL(e, r) {
    return this.client.sendOperationRequest({ copySource: e, options: r }, Gk);
  }
  /**
   * The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return
   * a response until the copy is complete.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  copyFromURL(e, r) {
    return this.client.sendOperationRequest({ copySource: e, options: r }, Yk);
  }
  /**
   * The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination
   * blob with zero length and full metadata.
   * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy Blob
   *               operation.
   * @param options The options parameters.
   */
  abortCopyFromURL(e, r) {
    return this.client.sendOperationRequest({ copyId: e, options: r }, Jk);
  }
  /**
   * The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium
   * storage account and on a block blob in a blob storage account (locally redundant storage only). A
   * premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block
   * blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's
   * ETag.
   * @param tier Indicates the tier to be set on the blob.
   * @param options The options parameters.
   */
  setTier(e, r) {
    return this.client.sendOperationRequest({ tier: e, options: r }, Vk);
  }
  /**
   * Returns the sku name and account kind
   * @param options The options parameters.
   */
  getAccountInfo(e) {
    return this.client.sendOperationRequest({ options: e }, _k);
  }
  /**
   * The Query operation enables users to select/project on blob data by providing simple query
   * expressions.
   * @param options The options parameters.
   */
  query(e) {
    return this.client.sendOperationRequest({ options: e }, Wk);
  }
  /**
   * The Get Tags operation enables users to get the tags associated with a blob.
   * @param options The options parameters.
   */
  getTags(e) {
    return this.client.sendOperationRequest({ options: e }, $k);
  }
  /**
   * The Set Tags operation enables users to set tags on a blob.
   * @param options The options parameters.
   */
  setTags(e) {
    return this.client.sendOperationRequest({ options: e }, Xk);
  }
}
const mt = ss(
  os,
  /* isXml */
  !0
), xk = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: el
    },
    206: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: el
    },
    default: {
      bodyMapper: Ie,
      headersMapper: eC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    ai,
    CD,
    BD,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: mt
}, Rk = {
  path: "/{containerName}/{blob}",
  httpMethod: "HEAD",
  responses: {
    200: {
      headersMapper: tC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: rC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: mt
}, Sk = {
  path: "/{containerName}/{blob}",
  httpMethod: "DELETE",
  responses: {
    202: {
      headersMapper: nC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: sC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr,
    yD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    ot,
    at,
    et,
    ID
  ],
  isXML: !0,
  serializer: mt
}, Dk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: iC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: oC
    }
  },
  queryParameters: [Qe, UB],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: mt
}, kk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: aC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: AC
    }
  },
  queryParameters: [Qe, QD],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ND,
    wD
  ],
  isXML: !0,
  serializer: mt
}, Mk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: cC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: lC
    }
  },
  queryParameters: [nn, Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    ot,
    at,
    et,
    cs,
    ls,
    ds,
    us,
    ms,
    hs
  ],
  isXML: !0,
  serializer: mt
}, Tk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: dC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: uC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr,
    $B
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ve,
    Fn,
    vn
  ],
  isXML: !0,
  serializer: mt
}, Fk = {
  path: "/{containerName}/{blob}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: mC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: hC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr,
    $B
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: mt
}, vk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: gC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: fC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr,
    bD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    xD
  ],
  isXML: !0,
  serializer: mt
}, Lk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: pC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: EC
    }
  },
  queryParameters: [Qe, vB],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    yr,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt
  ],
  isXML: !0,
  serializer: mt
}, Uk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: CC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: BC
    }
  },
  queryParameters: [Qe, Mr],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    PB,
    HB,
    OB,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: mt
}, Pk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: IC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: yC
    }
  },
  queryParameters: [Qe, Mr],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    zB,
    As,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: mt
}, Hk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: QC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: NC
    }
  },
  queryParameters: [Qe, Mr],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    As,
    qB,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: mt
}, Ok = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: wC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: bC
    }
  },
  queryParameters: [Qe, Mr],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    As,
    JB,
    VB,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: mt
}, zk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: xC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: RC
    }
  },
  queryParameters: [Qe, Mr],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    GB,
    YB,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: mt
}, qk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: SC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: DC
    }
  },
  queryParameters: [Qe, RD],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    yr,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt
  ],
  isXML: !0,
  serializer: mt
}, Gk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: kC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: MC
    }
  },
  queryParameters: [Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    yr,
    Ke,
    Je,
    Ve,
    ot,
    at,
    et,
    Fn,
    vn,
    gs,
    XB,
    fs,
    ps,
    Es,
    Cs,
    ZB,
    xo,
    Ln,
    SD,
    Bs
  ],
  isXML: !0,
  serializer: mt
}, Yk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: TC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: FC
    }
  },
  queryParameters: [Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    yr,
    Ke,
    Je,
    Ve,
    ot,
    at,
    et,
    Fn,
    vn,
    qt,
    gs,
    fs,
    ps,
    Es,
    Cs,
    xo,
    Ln,
    Bs,
    DD,
    Ai,
    ci,
    KB,
    li
  ],
  isXML: !0,
  serializer: mt
}, Jk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    204: {
      headersMapper: vC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: LC
    }
  },
  queryParameters: [
    Qe,
    kD,
    TD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    MD
  ],
  isXML: !0,
  serializer: mt
}, Vk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: tl
    },
    202: {
      headersMapper: tl
    },
    default: {
      bodyMapper: Ie,
      headersMapper: UC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr,
    FD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    et,
    XB,
    vD
  ],
  isXML: !0,
  serializer: mt
}, _k = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: PC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: HC
    }
  },
  queryParameters: [
    nn,
    Qe,
    td
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me
  ],
  isXML: !0,
  serializer: mt
}, Wk = {
  path: "/{containerName}/{blob}",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: rl
    },
    206: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: rl
    },
    default: {
      bodyMapper: Ie,
      headersMapper: OC
    }
  },
  requestBody: LD,
  queryParameters: [
    Qe,
    hr,
    UD
  ],
  urlParameters: [ye],
  headerParameters: [
    as,
    rn,
    Ne,
    we,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: mt
}, $k = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Zl,
      headersMapper: zC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: qC
    }
  },
  queryParameters: [
    Qe,
    hr,
    qr,
    jB
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    et,
    eI,
    tI,
    rI,
    nI
  ],
  isXML: !0,
  serializer: mt
}, Xk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    204: {
      headersMapper: GC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: YC
    }
  },
  requestBody: PD,
  queryParameters: [
    Qe,
    qr,
    jB
  ],
  urlParameters: [ye],
  headerParameters: [
    as,
    rn,
    Ne,
    we,
    Ke,
    et,
    eI,
    tI,
    rI,
    nI,
    sn,
    Is
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: mt
};
class Zk {
  client;
  /**
   * Initialize a new instance of the class PageBlob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Create operation creates a new page blob.
   * @param contentLength The length of the request.
   * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
   *                          page blob size must be aligned to a 512-byte boundary.
   * @param options The options parameters.
   */
  create(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, blobContentLength: r, options: n }, Kk);
  }
  /**
   * The Upload Pages operation writes a range of pages to a page blob
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  uploadPages(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, body: r, options: n }, jk);
  }
  /**
   * The Clear Pages operation clears a set of pages from a page blob
   * @param contentLength The length of the request.
   * @param options The options parameters.
   */
  clearPages(e, r) {
    return this.client.sendOperationRequest({ contentLength: e, options: r }, eM);
  }
  /**
   * The Upload Pages operation writes a range of pages to a page blob where the contents are read from a
   * URL
   * @param sourceUrl Specify a URL to the copy source.
   * @param sourceRange Bytes of source data in the specified range. The length of this range should
   *                    match the ContentLength header and x-ms-range/Range destination range header.
   * @param contentLength The length of the request.
   * @param range The range of bytes to which the source range would be written. The range should be 512
   *              aligned and range-end is required.
   * @param options The options parameters.
   */
  uploadPagesFromURL(e, r, n, s, i) {
    return this.client.sendOperationRequest({ sourceUrl: e, sourceRange: r, contentLength: n, range: s, options: i }, tM);
  }
  /**
   * The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a
   * page blob
   * @param options The options parameters.
   */
  getPageRanges(e) {
    return this.client.sendOperationRequest({ options: e }, rM);
  }
  /**
   * The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that were
   * changed between target blob and previous snapshot.
   * @param options The options parameters.
   */
  getPageRangesDiff(e) {
    return this.client.sendOperationRequest({ options: e }, nM);
  }
  /**
   * Resize the Blob
   * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
   *                          page blob size must be aligned to a 512-byte boundary.
   * @param options The options parameters.
   */
  resize(e, r) {
    return this.client.sendOperationRequest({ blobContentLength: e, options: r }, sM);
  }
  /**
   * Update the sequence number of the blob
   * @param sequenceNumberAction Required if the x-ms-blob-sequence-number header is set for the request.
   *                             This property applies to page blobs only. This property indicates how the service should modify the
   *                             blob's sequence number
   * @param options The options parameters.
   */
  updateSequenceNumber(e, r) {
    return this.client.sendOperationRequest({ sequenceNumberAction: e, options: r }, iM);
  }
  /**
   * The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob.
   * The snapshot is copied such that only the differential changes between the previously copied
   * snapshot are transferred to the destination. The copied snapshots are complete copies of the
   * original snapshot and can be read or copied from as usual. This API is supported since REST version
   * 2016-05-31.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  copyIncremental(e, r) {
    return this.client.sendOperationRequest({ copySource: e, options: r }, oM);
  }
}
const Gr = ss(
  os,
  /* isXml */
  !0
), Kk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: JC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: VC
    }
  },
  queryParameters: [Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ar,
    yr,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    cs,
    ls,
    ds,
    us,
    ms,
    hs,
    Fn,
    vn,
    qt,
    gs,
    Ln,
    Bs,
    HD,
    sI,
    iI
  ],
  isXML: !0,
  serializer: Gr
}, jk = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: _C
    },
    default: {
      bodyMapper: Ie,
      headersMapper: WC
    }
  },
  requestBody: So,
  queryParameters: [Qe, rd],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    ar,
    Ke,
    Je,
    Ve,
    ai,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt,
    sn,
    Is,
    Ro,
    Do,
    oI,
    nd,
    sd,
    id
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: Gr
}, eM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: $C
    },
    default: {
      bodyMapper: Ie,
      headersMapper: XC
    }
  },
  queryParameters: [Qe, rd],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ar,
    Ke,
    Je,
    Ve,
    ai,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt,
    nd,
    sd,
    id,
    OD
  ],
  isXML: !0,
  serializer: Gr
}, tM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: ZC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: KC
    }
  },
  queryParameters: [Qe, rd],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ar,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt,
    fs,
    ps,
    Es,
    Cs,
    Ai,
    ci,
    li,
    oI,
    nd,
    sd,
    id,
    od,
    zD,
    ad,
    qD
  ],
  isXML: !0,
  serializer: Gr
}, rM = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Kl,
      headersMapper: jC
    },
    default: {
      bodyMapper: Ie,
      headersMapper: eB
    }
  },
  queryParameters: [
    Qe,
    Mn,
    Tn,
    hr,
    aI
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    ai,
    ot,
    at,
    et
  ],
  isXML: !0,
  serializer: Gr
}, nM = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Kl,
      headersMapper: tB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: rB
    }
  },
  queryParameters: [
    Qe,
    Mn,
    Tn,
    hr,
    aI,
    GD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    ai,
    ot,
    at,
    et,
    YD
  ],
  isXML: !0,
  serializer: Gr
}, sM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: nB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: sB
    }
  },
  queryParameters: [nn, Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt,
    sI
  ],
  isXML: !0,
  serializer: Gr
}, iM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: iB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: oB
    }
  },
  queryParameters: [nn, Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    ot,
    at,
    et,
    iI,
    JD
  ],
  isXML: !0,
  serializer: Gr
}, oM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: aB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: AB
    }
  },
  queryParameters: [Qe, VD],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Je,
    Ve,
    ot,
    at,
    et,
    xo
  ],
  isXML: !0,
  serializer: Gr
};
class aM {
  client;
  /**
   * Initialize a new instance of the class AppendBlob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Create Append Blob operation creates a new append blob.
   * @param contentLength The length of the request.
   * @param options The options parameters.
   */
  create(e, r) {
    return this.client.sendOperationRequest({ contentLength: e, options: r }, AM);
  }
  /**
   * The Append Block operation commits a new block of data to the end of an existing append blob. The
   * Append Block operation is permitted only if the blob was created with x-ms-blob-type set to
   * AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  appendBlock(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, body: r, options: n }, cM);
  }
  /**
   * The Append Block operation commits a new block of data to the end of an existing append blob where
   * the contents are read from a source url. The Append Block operation is permitted only if the blob
   * was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version
   * 2015-02-21 version or later.
   * @param sourceUrl Specify a URL to the copy source.
   * @param contentLength The length of the request.
   * @param options The options parameters.
   */
  appendBlockFromUrl(e, r, n) {
    return this.client.sendOperationRequest({ sourceUrl: e, contentLength: r, options: n }, lM);
  }
  /**
   * The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version
   * 2019-12-12 version or later.
   * @param options The options parameters.
   */
  seal(e) {
    return this.client.sendOperationRequest({ options: e }, dM);
  }
}
const ko = ss(
  os,
  /* isXml */
  !0
), AM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: cB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: lB
    }
  },
  queryParameters: [Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ar,
    yr,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    cs,
    ls,
    ds,
    us,
    ms,
    hs,
    Fn,
    vn,
    qt,
    Ln,
    Bs,
    _D
  ],
  isXML: !0,
  serializer: ko
}, cM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: dB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: uB
    }
  },
  requestBody: So,
  queryParameters: [Qe, AI],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    ar,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt,
    sn,
    Is,
    Ro,
    Do,
    cI,
    Ad
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: ko
}, lM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: mB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: hB
    }
  },
  queryParameters: [Qe, AI],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ar,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    qt,
    fs,
    ps,
    Es,
    Cs,
    Ai,
    ci,
    li,
    sn,
    od,
    ad,
    cI,
    Ad,
    lI
  ],
  isXML: !0,
  serializer: ko
}, dM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: gB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: fB
    }
  },
  queryParameters: [Qe, WD],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    Je,
    Ve,
    ot,
    at,
    Ad
  ],
  isXML: !0,
  serializer: ko
};
class uM {
  client;
  /**
   * Initialize a new instance of the class BlockBlob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Upload Block Blob operation updates the content of an existing block blob. Updating an existing
   * block blob overwrites any existing metadata on the blob. Partial updates are not supported with Put
   * Blob; the content of the existing blob is overwritten with the content of the new blob. To perform a
   * partial update of the content of a block blob, use the Put Block List operation.
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  upload(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, body: r, options: n }, mM);
  }
  /**
   * The Put Blob from URL operation creates a new Block Blob where the contents of the blob are read
   * from a given URL.  This API is supported beginning with the 2020-04-08 version. Partial updates are
   * not supported with Put Blob from URL; the content of an existing blob is overwritten with the
   * content of the new blob.  To perform partial updates to a block blobs contents using a source URL,
   * use the Put Block from URL API in conjunction with Put Block List.
   * @param contentLength The length of the request.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  putBlobFromUrl(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, copySource: r, options: n }, hM);
  }
  /**
   * The Stage Block operation creates a new block to be committed as part of a blob
   * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
   *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
   *                for the blockid parameter must be the same size for each block.
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  stageBlock(e, r, n, s) {
    return this.client.sendOperationRequest({ blockId: e, contentLength: r, body: n, options: s }, gM);
  }
  /**
   * The Stage Block operation creates a new block to be committed as part of a blob where the contents
   * are read from a URL.
   * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
   *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
   *                for the blockid parameter must be the same size for each block.
   * @param contentLength The length of the request.
   * @param sourceUrl Specify a URL to the copy source.
   * @param options The options parameters.
   */
  stageBlockFromURL(e, r, n, s) {
    return this.client.sendOperationRequest({ blockId: e, contentLength: r, sourceUrl: n, options: s }, fM);
  }
  /**
   * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the
   * blob. In order to be written as part of a blob, a block must have been successfully written to the
   * server in a prior Put Block operation. You can call Put Block List to update a blob by uploading
   * only those blocks that have changed, then committing the new and existing blocks together. You can
   * do this by specifying whether to commit a block from the committed block list or from the
   * uncommitted block list, or to commit the most recently uploaded version of the block, whichever list
   * it may belong to.
   * @param blocks Blob Blocks.
   * @param options The options parameters.
   */
  commitBlockList(e, r) {
    return this.client.sendOperationRequest({ blocks: e, options: r }, pM);
  }
  /**
   * The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block
   * blob
   * @param listType Specifies whether to return the list of committed blocks, the list of uncommitted
   *                 blocks, or both lists together.
   * @param options The options parameters.
   */
  getBlockList(e, r) {
    return this.client.sendOperationRequest({ listType: e, options: r }, EM);
  }
}
const ys = ss(
  os,
  /* isXml */
  !0
), mM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: pB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: EB
    }
  },
  requestBody: So,
  queryParameters: [Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    ar,
    yr,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    cs,
    ls,
    ds,
    us,
    ms,
    hs,
    Fn,
    vn,
    qt,
    gs,
    Ln,
    Bs,
    sn,
    Is,
    Ro,
    Do,
    dI
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: ys
}, hM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: CB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: BB
    }
  },
  queryParameters: [Qe],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ar,
    yr,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    cs,
    ls,
    ds,
    us,
    ms,
    hs,
    qt,
    gs,
    fs,
    ps,
    Es,
    Cs,
    ZB,
    xo,
    Ln,
    Ai,
    ci,
    KB,
    li,
    sn,
    dI,
    $D
  ],
  isXML: !0,
  serializer: ys
}, gM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: IB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: yB
    }
  },
  requestBody: So,
  queryParameters: [
    Qe,
    uI,
    mI
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    ar,
    Ke,
    kt,
    Mt,
    Tt,
    qt,
    sn,
    Is,
    Ro,
    Do
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: ys
}, fM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: QB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: NB
    }
  },
  queryParameters: [
    Qe,
    uI,
    mI
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    ar,
    Ke,
    kt,
    Mt,
    Tt,
    qt,
    fs,
    ps,
    Es,
    Cs,
    Ai,
    ci,
    li,
    od,
    ad,
    lI
  ],
  isXML: !0,
  serializer: ys
}, pM = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: wB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: bB
    }
  },
  requestBody: XD,
  queryParameters: [Qe, hI],
  urlParameters: [ye],
  headerParameters: [
    as,
    rn,
    Ne,
    we,
    yr,
    Ke,
    Je,
    Ve,
    kt,
    Mt,
    Tt,
    ot,
    at,
    et,
    cs,
    ls,
    ds,
    us,
    ms,
    hs,
    Fn,
    vn,
    qt,
    gs,
    Ln,
    Bs,
    sn,
    Is
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: ys
}, EM = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: eE,
      headersMapper: xB
    },
    default: {
      bodyMapper: Ie,
      headersMapper: RB
    }
  },
  queryParameters: [
    Qe,
    hr,
    hI,
    ZD
  ],
  urlParameters: [ye],
  headerParameters: [
    Ne,
    we,
    Me,
    Ke,
    et
  ],
  isXML: !0,
  serializer: ys
};
let CM = class extends Sx {
  url;
  version;
  /**
   * Initializes a new instance of the StorageClient class.
   * @param url The URL of the service account, container, or blob that is the target of the desired
   *            operation.
   * @param options The parameter options
   */
  constructor(e, r) {
    if (e === void 0)
      throw new Error("'url' cannot be null");
    r || (r = {});
    const n = {
      requestContentType: "application/json; charset=utf-8"
    }, s = "azsdk-js-azure-storage-blob/12.30.0", i = r.userAgentOptions && r.userAgentOptions.userAgentPrefix ? `${r.userAgentOptions.userAgentPrefix} ${s}` : `${s}`, o = {
      ...n,
      ...r,
      userAgentOptions: {
        userAgentPrefix: i
      },
      endpoint: r.endpoint ?? r.baseUri ?? "{url}"
    };
    super(o), this.url = e, this.version = r.version || "2026-02-06", this.service = new KD(this), this.container = new ak(this), this.blob = new bk(this), this.pageBlob = new Zk(this), this.appendBlob = new aM(this), this.blockBlob = new uM(this);
  }
  service;
  container;
  blob;
  pageBlob;
  appendBlob;
  blockBlob;
};
class BM extends CM {
  async sendOperationRequest(e, r) {
    const n = { ...r };
    return (n.path === "/{containerName}" || n.path === "/{containerName}/{blob}") && (n.path = ""), super.sendOperationRequest(e, n);
  }
}
function IM(t) {
  const e = new URL(t);
  let r = e.pathname;
  return r = r || "/", r = QM(r), e.pathname = r, e.toString();
}
function yM(t) {
  let e = "";
  if (t.search("DevelopmentStorageProxyUri=") !== -1) {
    const r = t.split(";");
    for (const n of r)
      n.trim().startsWith("DevelopmentStorageProxyUri=") && (e = n.trim().match("DevelopmentStorageProxyUri=(.*)")[1]);
  }
  return e;
}
function hn(t, e) {
  const r = t.split(";");
  for (const n of r)
    if (n.trim().startsWith(e))
      return n.trim().match(e + "=(.*)")[1];
  return "";
}
function Mo(t) {
  let e = "";
  t.startsWith("UseDevelopmentStorage=true") && (e = yM(t), t = fS);
  let r = hn(t, "BlobEndpoint");
  if (r = r.endsWith("/") ? r.slice(0, -1) : r, t.search("DefaultEndpointsProtocol=") !== -1 && t.search("AccountKey=") !== -1) {
    let n = "", s = "", i = Buffer.from("accountKey", "base64"), o = "";
    if (s = hn(t, "AccountName"), i = Buffer.from(hn(t, "AccountKey"), "base64"), !r) {
      n = hn(t, "DefaultEndpointsProtocol");
      const a = n.toLowerCase();
      if (a !== "https" && a !== "http")
        throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
      if (o = hn(t, "EndpointSuffix"), !o)
        throw new Error("Invalid EndpointSuffix in the provided Connection String");
      r = `${n}://${s}.blob.${o}`;
    }
    if (s) {
      if (i.length === 0)
        throw new Error("Invalid AccountKey in the provided Connection String");
    } else throw new Error("Invalid AccountName in the provided Connection String");
    return {
      kind: "AccountConnString",
      url: r,
      accountName: s,
      accountKey: i,
      proxyUri: e
    };
  } else {
    let n = hn(t, "SharedAccessSignature"), s = hn(t, "AccountName");
    if (s || (s = gI(r)), r) {
      if (!n)
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
    } else throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
    return n.startsWith("?") && (n = n.substring(1)), { kind: "SASConnString", url: r, accountName: s, accountSas: n };
  }
}
function QM(t) {
  return encodeURIComponent(t).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
}
function Ht(t, e) {
  const r = new URL(t);
  let n = r.pathname;
  return n = n ? n.endsWith("/") ? `${n}${e}` : `${n}/${e}` : e, r.pathname = n, r.toString();
}
function Gs(t, e, r) {
  const n = new URL(t), s = encodeURIComponent(e), i = r ? encodeURIComponent(r) : void 0, o = n.search === "" ? "?" : n.search, a = [];
  for (const A of o.slice(1).split("&"))
    if (A) {
      const [c] = A.split("=", 2);
      c !== s && a.push(A);
    }
  return i && a.push(`${s}=${i}`), n.search = a.length ? `?${a.join("&")}` : "", n.toString();
}
function Cg(t, e) {
  return new URL(t).searchParams.get(e) ?? void 0;
}
function NM(t) {
  try {
    const e = new URL(t);
    return e.protocol.endsWith(":") ? e.protocol.slice(0, -1) : e.protocol;
  } catch {
    return;
  }
}
function Bg(t, e) {
  const r = new URL(t);
  let n = r.search;
  return n ? n += "&" + e : n = e, r.search = n, r.toString();
}
function dt(t, e = !0) {
  const r = t.toISOString();
  return e ? r.substring(0, r.length - 1) + "0000Z" : r.substring(0, r.length - 5) + "Z";
}
function wM(t) {
  return Rt ? Buffer.from(t).toString("base64") : btoa(t);
}
function Ig(t, e) {
  t.length > 42 && (t = t.slice(0, 42));
  const i = t + bM(e.toString(), 48 - t.length, "0");
  return wM(i);
}
function bM(t, e, r = " ") {
  return String.prototype.padStart ? t.padStart(e, r) : (r = r || " ", t.length > e ? t : (e = e - t.length, e > r.length && (r += r.repeat(e / r.length)), r.slice(0, e) + t));
}
function xM(t, e) {
  return t.toLocaleLowerCase() === e.toLocaleLowerCase();
}
function gI(t) {
  const e = new URL(t);
  let r;
  try {
    return e.hostname.split(".")[1] === "blob" ? r = e.hostname.split(".")[0] : fI(e) ? r = e.pathname.split("/")[1] : r = "", r;
  } catch {
    throw new Error("Unable to extract accountName with provided information.");
  }
}
function fI(t) {
  const e = t.host;
  return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(e) || !!t.port && IS.includes(t.port);
}
function Qn(t) {
  if (t === void 0)
    return;
  const e = [];
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const n = t[r];
      e.push(`${encodeURIComponent(r)}=${encodeURIComponent(n)}`);
    }
  return e.join("&");
}
function RM(t) {
  if (t === void 0)
    return;
  const e = {
    blobTagSet: []
  };
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const n = t[r];
      e.blobTagSet.push({
        key: r,
        value: n
      });
    }
  return e;
}
function SM(t) {
  if (t === void 0)
    return;
  const e = {};
  for (const r of t.blobTagSet)
    e[r.key] = r.value;
  return e;
}
function yg(t) {
  if (t !== void 0)
    switch (t.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: t.columnSeparator || ",",
              fieldQuote: t.fieldQuote || "",
              recordSeparator: t.recordSeparator,
              escapeChar: t.escapeCharacter || "",
              headersPresent: t.hasHeaders || !1
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: t.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: t.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
}
function Qg(t) {
  if (!t || "policy-id" in t)
    return;
  const e = [];
  for (const r in t) {
    const n = r.split("_"), s = "or-";
    n[0].startsWith(s) && (n[0] = n[0].substring(s.length));
    const i = {
      ruleId: n[1],
      replicationStatus: t[r]
    }, o = e.findIndex((a) => a.policyId === n[0]);
    o > -1 ? e[o].rules.push(i) : e.push({
      policyId: n[0],
      rules: [i]
    });
  }
  return e;
}
function Ys(t) {
  return t ? t.scheme + " " + t.value : void 0;
}
function* Ng(t) {
  let e = [], r = [];
  t.pageRange && (e = t.pageRange), t.clearRange && (r = t.clearRange);
  let n = 0, s = 0;
  for (; n < e.length && s < r.length; )
    e[n].start < r[s].start ? (yield {
      start: e[n].start,
      end: e[n].end,
      isClear: !1
    }, ++n) : (yield {
      start: r[s].start,
      end: r[s].end,
      isClear: !0
    }, ++s);
  for (; n < e.length; ++n)
    yield {
      start: e[n].start,
      end: e[n].end,
      isClear: !1
    };
  for (; s < r.length; ++s)
    yield {
      start: r[s].start,
      end: r[s].end,
      isClear: !0
    };
}
function Ue(t) {
  if ("_response" in t)
    return t;
  throw new TypeError(`Unexpected response object ${t}`);
}
class DM {
  /**
   * Encoded URL string value.
   */
  url;
  accountName;
  /**
   * Request policy pipeline.
   *
   * @internal
   */
  pipeline;
  /**
   * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
   */
  credential;
  /**
   * StorageClient is a reference to protocol layer operations entry, which is
   * generated by AutoRest generator.
   */
  storageClientContext;
  /**
   */
  isHttps;
  /**
   * Creates an instance of StorageClient.
   * @param url - url to resource
   * @param pipeline - request policy pipeline.
   */
  constructor(e, r) {
    this.url = IM(e), this.accountName = gI(e), this.pipeline = r, this.storageClientContext = new BM(this.url, NS(r)), this.isHttps = xM(NM(this.url) || "", "https"), this.credential = Jp(r);
    const n = this.storageClientContext;
    n.requestContentType = void 0;
  }
}
const Te = sp({
  packageName: "@azure/storage-blob",
  packageVersion: qp,
  namespace: "Microsoft.Storage"
});
class Dr {
  /**
   * Creates a {@link BlobSASPermissions} from the specified permissions string. This method will throw an
   * Error if it encounters a character that does not correspond to a valid permission.
   *
   * @param permissions -
   */
  static parse(e) {
    const r = new Dr();
    for (const n of e)
      switch (n) {
        case "r":
          r.read = !0;
          break;
        case "a":
          r.add = !0;
          break;
        case "c":
          r.create = !0;
          break;
        case "w":
          r.write = !0;
          break;
        case "d":
          r.delete = !0;
          break;
        case "x":
          r.deleteVersion = !0;
          break;
        case "t":
          r.tag = !0;
          break;
        case "m":
          r.move = !0;
          break;
        case "e":
          r.execute = !0;
          break;
        case "i":
          r.setImmutabilityPolicy = !0;
          break;
        case "y":
          r.permanentDelete = !0;
          break;
        default:
          throw new RangeError(`Invalid permission: ${n}`);
      }
    return r;
  }
  /**
   * Creates a {@link BlobSASPermissions} from a raw object which contains same keys as it
   * and boolean values for them.
   *
   * @param permissionLike -
   */
  static from(e) {
    const r = new Dr();
    return e.read && (r.read = !0), e.add && (r.add = !0), e.create && (r.create = !0), e.write && (r.write = !0), e.delete && (r.delete = !0), e.deleteVersion && (r.deleteVersion = !0), e.tag && (r.tag = !0), e.move && (r.move = !0), e.execute && (r.execute = !0), e.setImmutabilityPolicy && (r.setImmutabilityPolicy = !0), e.permanentDelete && (r.permanentDelete = !0), r;
  }
  /**
   * Specifies Read access granted.
   */
  read = !1;
  /**
   * Specifies Add access granted.
   */
  add = !1;
  /**
   * Specifies Create access granted.
   */
  create = !1;
  /**
   * Specifies Write access granted.
   */
  write = !1;
  /**
   * Specifies Delete access granted.
   */
  delete = !1;
  /**
   * Specifies Delete version access granted.
   */
  deleteVersion = !1;
  /**
   * Specfies Tag access granted.
   */
  tag = !1;
  /**
   * Specifies Move access granted.
   */
  move = !1;
  /**
   * Specifies Execute access granted.
   */
  execute = !1;
  /**
   * Specifies SetImmutabilityPolicy access granted.
   */
  setImmutabilityPolicy = !1;
  /**
   * Specifies that Permanent Delete is permitted.
   */
  permanentDelete = !1;
  /**
   * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
   * order accepted by the service.
   *
   * @returns A string which represents the BlobSASPermissions
   */
  toString() {
    const e = [];
    return this.read && e.push("r"), this.add && e.push("a"), this.create && e.push("c"), this.write && e.push("w"), this.delete && e.push("d"), this.deleteVersion && e.push("x"), this.tag && e.push("t"), this.move && e.push("m"), this.execute && e.push("e"), this.setImmutabilityPolicy && e.push("i"), this.permanentDelete && e.push("y"), e.join("");
  }
}
class kr {
  /**
   * Creates an {@link ContainerSASPermissions} from the specified permissions string. This method will throw an
   * Error if it encounters a character that does not correspond to a valid permission.
   *
   * @param permissions -
   */
  static parse(e) {
    const r = new kr();
    for (const n of e)
      switch (n) {
        case "r":
          r.read = !0;
          break;
        case "a":
          r.add = !0;
          break;
        case "c":
          r.create = !0;
          break;
        case "w":
          r.write = !0;
          break;
        case "d":
          r.delete = !0;
          break;
        case "l":
          r.list = !0;
          break;
        case "t":
          r.tag = !0;
          break;
        case "x":
          r.deleteVersion = !0;
          break;
        case "m":
          r.move = !0;
          break;
        case "e":
          r.execute = !0;
          break;
        case "i":
          r.setImmutabilityPolicy = !0;
          break;
        case "y":
          r.permanentDelete = !0;
          break;
        case "f":
          r.filterByTags = !0;
          break;
        default:
          throw new RangeError(`Invalid permission ${n}`);
      }
    return r;
  }
  /**
   * Creates a {@link ContainerSASPermissions} from a raw object which contains same keys as it
   * and boolean values for them.
   *
   * @param permissionLike -
   */
  static from(e) {
    const r = new kr();
    return e.read && (r.read = !0), e.add && (r.add = !0), e.create && (r.create = !0), e.write && (r.write = !0), e.delete && (r.delete = !0), e.list && (r.list = !0), e.deleteVersion && (r.deleteVersion = !0), e.tag && (r.tag = !0), e.move && (r.move = !0), e.execute && (r.execute = !0), e.setImmutabilityPolicy && (r.setImmutabilityPolicy = !0), e.permanentDelete && (r.permanentDelete = !0), e.filterByTags && (r.filterByTags = !0), r;
  }
  /**
   * Specifies Read access granted.
   */
  read = !1;
  /**
   * Specifies Add access granted.
   */
  add = !1;
  /**
   * Specifies Create access granted.
   */
  create = !1;
  /**
   * Specifies Write access granted.
   */
  write = !1;
  /**
   * Specifies Delete access granted.
   */
  delete = !1;
  /**
   * Specifies Delete version access granted.
   */
  deleteVersion = !1;
  /**
   * Specifies List access granted.
   */
  list = !1;
  /**
   * Specfies Tag access granted.
   */
  tag = !1;
  /**
   * Specifies Move access granted.
   */
  move = !1;
  /**
   * Specifies Execute access granted.
   */
  execute = !1;
  /**
   * Specifies SetImmutabilityPolicy access granted.
   */
  setImmutabilityPolicy = !1;
  /**
   * Specifies that Permanent Delete is permitted.
   */
  permanentDelete = !1;
  /**
   * Specifies that Filter Blobs by Tags is permitted.
   */
  filterByTags = !1;
  /**
   * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
   * order accepted by the service.
   *
   * The order of the characters should be as specified here to ensure correctness.
   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
   *
   */
  toString() {
    const e = [];
    return this.read && e.push("r"), this.add && e.push("a"), this.create && e.push("c"), this.write && e.push("w"), this.delete && e.push("d"), this.deleteVersion && e.push("x"), this.list && e.push("l"), this.tag && e.push("t"), this.move && e.push("m"), this.execute && e.push("e"), this.setImmutabilityPolicy && e.push("i"), this.permanentDelete && e.push("y"), this.filterByTags && e.push("f"), e.join("");
  }
}
function an(t) {
  return t.end ? `${t.start}-${t.end}` : t.start;
}
var wg;
(function(t) {
  t.Https = "https", t.HttpsAndHttp = "https,http";
})(wg || (wg = {}));
class Un {
  /**
   * The storage API version.
   */
  version;
  /**
   * Optional. The allowed HTTP protocol(s).
   */
  protocol;
  /**
   * Optional. The start time for this SAS token.
   */
  startsOn;
  /**
   * Optional only when identifier is provided. The expiry time for this SAS token.
   */
  expiresOn;
  /**
   * Optional only when identifier is provided.
   * Please refer to {@link AccountSASPermissions}, {@link BlobSASPermissions}, or {@link ContainerSASPermissions} for
   * more details.
   */
  permissions;
  /**
   * Optional. The storage services being accessed (only for Account SAS). Please refer to {@link AccountSASServices}
   * for more details.
   */
  services;
  /**
   * Optional. The storage resource types being accessed (only for Account SAS). Please refer to
   * {@link AccountSASResourceTypes} for more details.
   */
  resourceTypes;
  /**
   * Optional. The signed identifier (only for {@link BlobSASSignatureValues}).
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/establishing-a-stored-access-policy
   */
  identifier;
  /**
   * Optional. Beginning in version 2025-07-05, this value specifies the Entra ID of the user would is authorized to
   * use the resulting SAS URL.  The resulting SAS URL must be used in conjunction with an Entra ID token that has been
   * issued to the user specified in this value.
   */
  delegatedUserObjectId;
  /**
   * Optional. Encryption scope to use when sending requests authorized with this SAS URI.
   */
  encryptionScope;
  /**
   * Optional. Specifies which resources are accessible via the SAS (only for {@link BlobSASSignatureValues}).
   * @see https://learn.microsoft.com/rest/api/storageservices/create-service-sas#specifying-the-signed-resource-blob-service-only
   */
  resource;
  /**
   * The signature for the SAS token.
   */
  signature;
  /**
   * Value for cache-control header in Blob/File Service SAS.
   */
  cacheControl;
  /**
   * Value for content-disposition header in Blob/File Service SAS.
   */
  contentDisposition;
  /**
   * Value for content-encoding header in Blob/File Service SAS.
   */
  contentEncoding;
  /**
   * Value for content-length header in Blob/File Service SAS.
   */
  contentLanguage;
  /**
   * Value for content-type header in Blob/File Service SAS.
   */
  contentType;
  /**
   * Inner value of getter ipRange.
   */
  ipRangeInner;
  /**
   * The Azure Active Directory object ID in GUID format.
   * Property of user delegation key.
   */
  signedOid;
  /**
   * The Azure Active Directory tenant ID in GUID format.
   * Property of user delegation key.
   */
  signedTenantId;
  /**
   * The date-time the key is active.
   * Property of user delegation key.
   */
  signedStartsOn;
  /**
   * The date-time the key expires.
   * Property of user delegation key.
   */
  signedExpiresOn;
  /**
   * Abbreviation of the Azure Storage service that accepts the user delegation key.
   * Property of user delegation key.
   */
  signedService;
  /**
   * The service version that created the user delegation key.
   * Property of user delegation key.
   */
  signedVersion;
  /**
   * Authorized AAD Object ID in GUID format. The AAD Object ID of a user authorized by the owner of the User Delegation Key
   * to perform the action granted by the SAS. The Azure Storage service will ensure that the owner of the user delegation key
   * has the required permissions before granting access but no additional permission check for the user specified in
   * this value will be performed. This is only used for User Delegation SAS.
   */
  preauthorizedAgentObjectId;
  /**
   * A GUID value that will be logged in the storage diagnostic logs and can be used to correlate SAS generation with storage resource access.
   * This is only used for User Delegation SAS.
   */
  correlationId;
  /**
   * Optional. IP range allowed for this SAS.
   *
   * @readonly
   */
  get ipRange() {
    if (this.ipRangeInner)
      return {
        end: this.ipRangeInner.end,
        start: this.ipRangeInner.start
      };
  }
  constructor(e, r, n, s, i, o, a, A, c, l, d, u, m, h, f, p, y, w, R, D, L) {
    this.version = e, this.signature = r, n !== void 0 && typeof n != "string" ? (this.permissions = n.permissions, this.services = n.services, this.resourceTypes = n.resourceTypes, this.protocol = n.protocol, this.startsOn = n.startsOn, this.expiresOn = n.expiresOn, this.ipRangeInner = n.ipRange, this.identifier = n.identifier, this.delegatedUserObjectId = n.delegatedUserObjectId, this.encryptionScope = n.encryptionScope, this.resource = n.resource, this.cacheControl = n.cacheControl, this.contentDisposition = n.contentDisposition, this.contentEncoding = n.contentEncoding, this.contentLanguage = n.contentLanguage, this.contentType = n.contentType, n.userDelegationKey && (this.signedOid = n.userDelegationKey.signedObjectId, this.signedTenantId = n.userDelegationKey.signedTenantId, this.signedStartsOn = n.userDelegationKey.signedStartsOn, this.signedExpiresOn = n.userDelegationKey.signedExpiresOn, this.signedService = n.userDelegationKey.signedService, this.signedVersion = n.userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = n.preauthorizedAgentObjectId, this.correlationId = n.correlationId)) : (this.services = s, this.resourceTypes = i, this.expiresOn = A, this.permissions = n, this.protocol = o, this.startsOn = a, this.ipRangeInner = c, this.delegatedUserObjectId = L, this.encryptionScope = D, this.identifier = l, this.resource = d, this.cacheControl = u, this.contentDisposition = m, this.contentEncoding = h, this.contentLanguage = f, this.contentType = p, y && (this.signedOid = y.signedObjectId, this.signedTenantId = y.signedTenantId, this.signedStartsOn = y.signedStartsOn, this.signedExpiresOn = y.signedExpiresOn, this.signedService = y.signedService, this.signedVersion = y.signedVersion, this.preauthorizedAgentObjectId = w, this.correlationId = R));
  }
  /**
   * Encodes all SAS query parameters into a string that can be appended to a URL.
   *
   */
  toString() {
    const e = [
      "sv",
      "ss",
      "srt",
      "spr",
      "st",
      "se",
      "sip",
      "si",
      "ses",
      "skoid",
      // Signed object ID
      "sktid",
      // Signed tenant ID
      "skt",
      // Signed key start time
      "ske",
      // Signed key expiry time
      "sks",
      // Signed key service
      "skv",
      // Signed key version
      "sr",
      "sp",
      "sig",
      "rscc",
      "rscd",
      "rsce",
      "rscl",
      "rsct",
      "saoid",
      "scid",
      "sduoid"
      // Signed key user delegation object ID
    ], r = [];
    for (const n of e)
      switch (n) {
        case "sv":
          this.tryAppendQueryParameter(r, n, this.version);
          break;
        case "ss":
          this.tryAppendQueryParameter(r, n, this.services);
          break;
        case "srt":
          this.tryAppendQueryParameter(r, n, this.resourceTypes);
          break;
        case "spr":
          this.tryAppendQueryParameter(r, n, this.protocol);
          break;
        case "st":
          this.tryAppendQueryParameter(r, n, this.startsOn ? dt(this.startsOn, !1) : void 0);
          break;
        case "se":
          this.tryAppendQueryParameter(r, n, this.expiresOn ? dt(this.expiresOn, !1) : void 0);
          break;
        case "sip":
          this.tryAppendQueryParameter(r, n, this.ipRange ? an(this.ipRange) : void 0);
          break;
        case "si":
          this.tryAppendQueryParameter(r, n, this.identifier);
          break;
        case "ses":
          this.tryAppendQueryParameter(r, n, this.encryptionScope);
          break;
        case "skoid":
          this.tryAppendQueryParameter(r, n, this.signedOid);
          break;
        case "sktid":
          this.tryAppendQueryParameter(r, n, this.signedTenantId);
          break;
        case "skt":
          this.tryAppendQueryParameter(r, n, this.signedStartsOn ? dt(this.signedStartsOn, !1) : void 0);
          break;
        case "ske":
          this.tryAppendQueryParameter(r, n, this.signedExpiresOn ? dt(this.signedExpiresOn, !1) : void 0);
          break;
        case "sks":
          this.tryAppendQueryParameter(r, n, this.signedService);
          break;
        case "skv":
          this.tryAppendQueryParameter(r, n, this.signedVersion);
          break;
        case "sr":
          this.tryAppendQueryParameter(r, n, this.resource);
          break;
        case "sp":
          this.tryAppendQueryParameter(r, n, this.permissions);
          break;
        case "sig":
          this.tryAppendQueryParameter(r, n, this.signature);
          break;
        case "rscc":
          this.tryAppendQueryParameter(r, n, this.cacheControl);
          break;
        case "rscd":
          this.tryAppendQueryParameter(r, n, this.contentDisposition);
          break;
        case "rsce":
          this.tryAppendQueryParameter(r, n, this.contentEncoding);
          break;
        case "rscl":
          this.tryAppendQueryParameter(r, n, this.contentLanguage);
          break;
        case "rsct":
          this.tryAppendQueryParameter(r, n, this.contentType);
          break;
        case "saoid":
          this.tryAppendQueryParameter(r, n, this.preauthorizedAgentObjectId);
          break;
        case "scid":
          this.tryAppendQueryParameter(r, n, this.correlationId);
          break;
        case "sduoid":
          this.tryAppendQueryParameter(r, n, this.delegatedUserObjectId);
          break;
      }
    return r.join("&");
  }
  /**
   * A private helper method used to filter and append query key/value pairs into an array.
   *
   * @param queries -
   * @param key -
   * @param value -
   */
  tryAppendQueryParameter(e, r, n) {
    n && (r = encodeURIComponent(r), n = encodeURIComponent(n), r.length > 0 && n.length > 0 && e.push(`${r}=${n}`));
  }
}
function bg(t, e, r) {
  return nl(t, e, r).sasQueryParameters;
}
function nl(t, e, r) {
  const n = t.version ? t.version : Gp, s = e instanceof sr ? e : void 0;
  let i;
  if (s === void 0 && r !== void 0 && (i = new lS(r, e)), s === void 0 && i === void 0)
    throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
  if (n >= "2020-12-06")
    return s !== void 0 ? TM(t, s) : n >= "2025-07-05" ? UM(t, i) : LM(t, i);
  if (n >= "2018-11-09")
    return s !== void 0 ? MM(t, s) : n >= "2020-02-10" ? vM(t, i) : FM(t, i);
  if (n >= "2015-04-05") {
    if (s !== void 0)
      return kM(t, s);
    throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
  }
  throw new RangeError("'version' must be >= '2015-04-05'.");
}
function kM(t, e) {
  if (t = Hn(t), !t.identifier && !(t.permissions && t.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  let r = "c";
  t.blobName && (r = "b");
  let n;
  t.permissions && (t.blobName ? n = Dr.parse(t.permissions.toString()).toString() : n = kr.parse(t.permissions.toString()).toString());
  const s = [
    n || "",
    t.startsOn ? dt(t.startsOn, !1) : "",
    t.expiresOn ? dt(t.expiresOn, !1) : "",
    Pn(e.accountName, t.containerName, t.blobName),
    t.identifier,
    t.ipRange ? an(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    t.cacheControl ? t.cacheControl : "",
    t.contentDisposition ? t.contentDisposition : "",
    t.contentEncoding ? t.contentEncoding : "",
    t.contentLanguage ? t.contentLanguage : "",
    t.contentType ? t.contentType : ""
  ].join(`
`), i = e.computeHMACSHA256(s);
  return {
    sasQueryParameters: new Un(t.version, i, n, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType),
    stringToSign: s
  };
}
function MM(t, e) {
  if (t = Hn(t), !t.identifier && !(t.permissions && t.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Dr.parse(t.permissions.toString()).toString() : s = kr.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? dt(t.startsOn, !1) : "",
    t.expiresOn ? dt(t.expiresOn, !1) : "",
    Pn(e.accountName, t.containerName, t.blobName),
    t.identifier,
    t.ipRange ? an(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.cacheControl ? t.cacheControl : "",
    t.contentDisposition ? t.contentDisposition : "",
    t.contentEncoding ? t.contentEncoding : "",
    t.contentLanguage ? t.contentLanguage : "",
    t.contentType ? t.contentType : ""
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new Un(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType),
    stringToSign: i
  };
}
function TM(t, e) {
  if (t = Hn(t), !t.identifier && !(t.permissions && t.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Dr.parse(t.permissions.toString()).toString() : s = kr.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? dt(t.startsOn, !1) : "",
    t.expiresOn ? dt(t.expiresOn, !1) : "",
    Pn(e.accountName, t.containerName, t.blobName),
    t.identifier,
    t.ipRange ? an(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.encryptionScope,
    t.cacheControl ? t.cacheControl : "",
    t.contentDisposition ? t.contentDisposition : "",
    t.contentEncoding ? t.contentEncoding : "",
    t.contentLanguage ? t.contentLanguage : "",
    t.contentType ? t.contentType : ""
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new Un(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, void 0, void 0, void 0, t.encryptionScope),
    stringToSign: i
  };
}
function FM(t, e) {
  if (t = Hn(t), !t.permissions || !t.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Dr.parse(t.permissions.toString()).toString() : s = kr.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? dt(t.startsOn, !1) : "",
    t.expiresOn ? dt(t.expiresOn, !1) : "",
    Pn(e.accountName, t.containerName, t.blobName),
    e.userDelegationKey.signedObjectId,
    e.userDelegationKey.signedTenantId,
    e.userDelegationKey.signedStartsOn ? dt(e.userDelegationKey.signedStartsOn, !1) : "",
    e.userDelegationKey.signedExpiresOn ? dt(e.userDelegationKey.signedExpiresOn, !1) : "",
    e.userDelegationKey.signedService,
    e.userDelegationKey.signedVersion,
    t.ipRange ? an(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.cacheControl,
    t.contentDisposition,
    t.contentEncoding,
    t.contentLanguage,
    t.contentType
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new Un(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, e.userDelegationKey),
    stringToSign: i
  };
}
function vM(t, e) {
  if (t = Hn(t), !t.permissions || !t.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Dr.parse(t.permissions.toString()).toString() : s = kr.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? dt(t.startsOn, !1) : "",
    t.expiresOn ? dt(t.expiresOn, !1) : "",
    Pn(e.accountName, t.containerName, t.blobName),
    e.userDelegationKey.signedObjectId,
    e.userDelegationKey.signedTenantId,
    e.userDelegationKey.signedStartsOn ? dt(e.userDelegationKey.signedStartsOn, !1) : "",
    e.userDelegationKey.signedExpiresOn ? dt(e.userDelegationKey.signedExpiresOn, !1) : "",
    e.userDelegationKey.signedService,
    e.userDelegationKey.signedVersion,
    t.preauthorizedAgentObjectId,
    void 0,
    // agentObjectId
    t.correlationId,
    t.ipRange ? an(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.cacheControl,
    t.contentDisposition,
    t.contentEncoding,
    t.contentLanguage,
    t.contentType
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new Un(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, e.userDelegationKey, t.preauthorizedAgentObjectId, t.correlationId),
    stringToSign: i
  };
}
function LM(t, e) {
  if (t = Hn(t), !t.permissions || !t.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Dr.parse(t.permissions.toString()).toString() : s = kr.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? dt(t.startsOn, !1) : "",
    t.expiresOn ? dt(t.expiresOn, !1) : "",
    Pn(e.accountName, t.containerName, t.blobName),
    e.userDelegationKey.signedObjectId,
    e.userDelegationKey.signedTenantId,
    e.userDelegationKey.signedStartsOn ? dt(e.userDelegationKey.signedStartsOn, !1) : "",
    e.userDelegationKey.signedExpiresOn ? dt(e.userDelegationKey.signedExpiresOn, !1) : "",
    e.userDelegationKey.signedService,
    e.userDelegationKey.signedVersion,
    t.preauthorizedAgentObjectId,
    void 0,
    // agentObjectId
    t.correlationId,
    t.ipRange ? an(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.encryptionScope,
    t.cacheControl,
    t.contentDisposition,
    t.contentEncoding,
    t.contentLanguage,
    t.contentType
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new Un(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, e.userDelegationKey, t.preauthorizedAgentObjectId, t.correlationId, t.encryptionScope),
    stringToSign: i
  };
}
function UM(t, e) {
  if (t = Hn(t), !t.permissions || !t.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Dr.parse(t.permissions.toString()).toString() : s = kr.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? dt(t.startsOn, !1) : "",
    t.expiresOn ? dt(t.expiresOn, !1) : "",
    Pn(e.accountName, t.containerName, t.blobName),
    e.userDelegationKey.signedObjectId,
    e.userDelegationKey.signedTenantId,
    e.userDelegationKey.signedStartsOn ? dt(e.userDelegationKey.signedStartsOn, !1) : "",
    e.userDelegationKey.signedExpiresOn ? dt(e.userDelegationKey.signedExpiresOn, !1) : "",
    e.userDelegationKey.signedService,
    e.userDelegationKey.signedVersion,
    t.preauthorizedAgentObjectId,
    void 0,
    // agentObjectId
    t.correlationId,
    void 0,
    // SignedKeyDelegatedUserTenantId, will be added in a future release.
    t.delegatedUserObjectId,
    t.ipRange ? an(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.encryptionScope,
    t.cacheControl,
    t.contentDisposition,
    t.contentEncoding,
    t.contentLanguage,
    t.contentType
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new Un(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, e.userDelegationKey, t.preauthorizedAgentObjectId, t.correlationId, t.encryptionScope, t.delegatedUserObjectId),
    stringToSign: i
  };
}
function Pn(t, e, r) {
  const n = [`/blob/${t}/${e}`];
  return r && n.push(`/${r}`), n.join("");
}
function Hn(t) {
  const e = t.version ? t.version : Gp;
  if (t.snapshotTime && e < "2018-11-09")
    throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
  if (t.blobName === void 0 && t.snapshotTime)
    throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
  if (t.versionId && e < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
  if (t.blobName === void 0 && t.versionId)
    throw RangeError("Must provide 'blobName' when providing 'versionId'.");
  if (t.permissions && t.permissions.setImmutabilityPolicy && e < "2020-08-04")
    throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
  if (t.permissions && t.permissions.deleteVersion && e < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
  if (t.permissions && t.permissions.permanentDelete && e < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
  if (t.permissions && t.permissions.tag && e < "2019-12-12")
    throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
  if (e < "2020-02-10" && t.permissions && (t.permissions.move || t.permissions.execute))
    throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
  if (e < "2021-04-10" && t.permissions && t.permissions.filterByTags)
    throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
  if (e < "2020-02-10" && (t.preauthorizedAgentObjectId || t.correlationId))
    throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
  if (t.encryptionScope && e < "2020-12-06")
    throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
  return t.version = e, t;
}
class PM {
  _leaseId;
  _url;
  _containerOrBlobOperation;
  _isContainer;
  /**
   * Gets the lease Id.
   *
   * @readonly
   */
  get leaseId() {
    return this._leaseId;
  }
  /**
   * Gets the url.
   *
   * @readonly
   */
  get url() {
    return this._url;
  }
  /**
   * Creates an instance of BlobLeaseClient.
   * @param client - The client to make the lease operation requests.
   * @param leaseId - Initial proposed lease id.
   */
  constructor(e, r) {
    const n = e.storageClientContext;
    this._url = e.url, e.name === void 0 ? (this._isContainer = !0, this._containerOrBlobOperation = n.container) : (this._isContainer = !1, this._containerOrBlobOperation = n.blob), r || (r = $c()), this._leaseId = r;
  }
  /**
   * Establishes and manages a lock on a container for delete operations, or on a blob
   * for write and delete operations.
   * The lock duration can be 15 to 60 seconds, or can be infinite.
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
   *
   * @param duration - Must be between 15 to 60 seconds, or infinite (-1)
   * @param options - option to configure lease management operations.
   * @returns Response data for acquire lease operation.
   */
  async acquireLease(e, r = {}) {
    if (this._isContainer && (r.conditions?.ifMatch && r.conditions?.ifMatch !== wr || r.conditions?.ifNoneMatch && r.conditions?.ifNoneMatch !== wr || r.conditions?.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return Te.withSpan("BlobLeaseClient-acquireLease", r, async (n) => Ue(await this._containerOrBlobOperation.acquireLease({
      abortSignal: r.abortSignal,
      duration: e,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      proposedLeaseId: this._leaseId,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * To change the ID of the lease.
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
   *
   * @param proposedLeaseId - the proposed new lease Id.
   * @param options - option to configure lease management operations.
   * @returns Response data for change lease operation.
   */
  async changeLease(e, r = {}) {
    if (this._isContainer && (r.conditions?.ifMatch && r.conditions?.ifMatch !== wr || r.conditions?.ifNoneMatch && r.conditions?.ifNoneMatch !== wr || r.conditions?.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return Te.withSpan("BlobLeaseClient-changeLease", r, async (n) => {
      const s = Ue(await this._containerOrBlobOperation.changeLease(this._leaseId, e, {
        abortSignal: r.abortSignal,
        modifiedAccessConditions: {
          ...r.conditions,
          ifTags: r.conditions?.tagConditions
        },
        tracingOptions: n.tracingOptions
      }));
      return this._leaseId = e, s;
    });
  }
  /**
   * To free the lease if it is no longer needed so that another client may
   * immediately acquire a lease against the container or the blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
   *
   * @param options - option to configure lease management operations.
   * @returns Response data for release lease operation.
   */
  async releaseLease(e = {}) {
    if (this._isContainer && (e.conditions?.ifMatch && e.conditions?.ifMatch !== wr || e.conditions?.ifNoneMatch && e.conditions?.ifNoneMatch !== wr || e.conditions?.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return Te.withSpan("BlobLeaseClient-releaseLease", e, async (r) => Ue(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
      abortSignal: e.abortSignal,
      modifiedAccessConditions: {
        ...e.conditions,
        ifTags: e.conditions?.tagConditions
      },
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * To renew the lease.
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
   *
   * @param options - Optional option to configure lease management operations.
   * @returns Response data for renew lease operation.
   */
  async renewLease(e = {}) {
    if (this._isContainer && (e.conditions?.ifMatch && e.conditions?.ifMatch !== wr || e.conditions?.ifNoneMatch && e.conditions?.ifNoneMatch !== wr || e.conditions?.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return Te.withSpan("BlobLeaseClient-renewLease", e, async (r) => this._containerOrBlobOperation.renewLease(this._leaseId, {
      abortSignal: e.abortSignal,
      modifiedAccessConditions: {
        ...e.conditions,
        ifTags: e.conditions?.tagConditions
      },
      tracingOptions: r.tracingOptions
    }));
  }
  /**
   * To end the lease but ensure that another client cannot acquire a new lease
   * until the current lease period has expired.
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
   *
   * @param breakPeriod - Break period
   * @param options - Optional options to configure lease management operations.
   * @returns Response data for break lease operation.
   */
  async breakLease(e, r = {}) {
    if (this._isContainer && (r.conditions?.ifMatch && r.conditions?.ifMatch !== wr || r.conditions?.ifNoneMatch && r.conditions?.ifNoneMatch !== wr || r.conditions?.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return Te.withSpan("BlobLeaseClient-breakLease", r, async (n) => {
      const s = {
        abortSignal: r.abortSignal,
        breakPeriod: e,
        modifiedAccessConditions: {
          ...r.conditions,
          ifTags: r.conditions?.tagConditions
        },
        tracingOptions: n.tracingOptions
      };
      return Ue(await this._containerOrBlobOperation.breakLease(s));
    });
  }
}
class HM extends gl {
  start;
  offset;
  end;
  getter;
  source;
  retries = 0;
  maxRetryRequests;
  onProgress;
  options;
  /**
   * Creates an instance of RetriableReadableStream.
   *
   * @param source - The current ReadableStream returned from getter
   * @param getter - A method calling downloading request returning
   *                                      a new ReadableStream from specified offset
   * @param offset - Offset position in original data source to read
   * @param count - How much data in original data source to read
   * @param options -
   */
  constructor(e, r, n, s, i = {}) {
    super({ highWaterMark: i.highWaterMark }), this.getter = r, this.source = e, this.start = n, this.offset = n, this.end = n + s - 1, this.maxRetryRequests = i.maxRetryRequests && i.maxRetryRequests >= 0 ? i.maxRetryRequests : 0, this.onProgress = i.onProgress, this.options = i, this.setSourceEventHandlers();
  }
  _read() {
    this.source.resume();
  }
  setSourceEventHandlers() {
    this.source.on("data", this.sourceDataHandler), this.source.on("end", this.sourceErrorOrEndHandler), this.source.on("error", this.sourceErrorOrEndHandler), this.source.on("aborted", this.sourceAbortedHandler);
  }
  removeSourceEventHandlers() {
    this.source.removeListener("data", this.sourceDataHandler), this.source.removeListener("end", this.sourceErrorOrEndHandler), this.source.removeListener("error", this.sourceErrorOrEndHandler), this.source.removeListener("aborted", this.sourceAbortedHandler);
  }
  sourceDataHandler = (e) => {
    if (this.options.doInjectErrorOnce) {
      this.options.doInjectErrorOnce = void 0, this.source.pause(), this.sourceErrorOrEndHandler(), this.source.destroy();
      return;
    }
    this.offset += e.length, this.onProgress && this.onProgress({ loadedBytes: this.offset - this.start }), this.push(e) || this.source.pause();
  };
  sourceAbortedHandler = () => {
    const e = new ii("The operation was aborted.");
    this.destroy(e);
  };
  sourceErrorOrEndHandler = (e) => {
    if (e && e.name === "AbortError") {
      this.destroy(e);
      return;
    }
    this.removeSourceEventHandlers(), this.offset - 1 === this.end ? this.push(null) : this.offset <= this.end ? this.retries < this.maxRetryRequests ? (this.retries += 1, this.getter(this.offset).then((r) => {
      this.source = r, this.setSourceEventHandlers();
    }).catch((r) => {
      this.destroy(r);
    })) : this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`)) : this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
  };
  _destroy(e, r) {
    this.removeSourceEventHandlers(), this.source.destroy(), r(e === null ? void 0 : e);
  }
}
class OM {
  /**
   * Indicates that the service supports
   * requests for partial file content.
   *
   * @readonly
   */
  get acceptRanges() {
    return this.originalResponse.acceptRanges;
  }
  /**
   * Returns if it was previously specified
   * for the file.
   *
   * @readonly
   */
  get cacheControl() {
    return this.originalResponse.cacheControl;
  }
  /**
   * Returns the value that was specified
   * for the 'x-ms-content-disposition' header and specifies how to process the
   * response.
   *
   * @readonly
   */
  get contentDisposition() {
    return this.originalResponse.contentDisposition;
  }
  /**
   * Returns the value that was specified
   * for the Content-Encoding request header.
   *
   * @readonly
   */
  get contentEncoding() {
    return this.originalResponse.contentEncoding;
  }
  /**
   * Returns the value that was specified
   * for the Content-Language request header.
   *
   * @readonly
   */
  get contentLanguage() {
    return this.originalResponse.contentLanguage;
  }
  /**
   * The current sequence number for a
   * page blob. This header is not returned for block blobs or append blobs.
   *
   * @readonly
   */
  get blobSequenceNumber() {
    return this.originalResponse.blobSequenceNumber;
  }
  /**
   * The blob's type. Possible values include:
   * 'BlockBlob', 'PageBlob', 'AppendBlob'.
   *
   * @readonly
   */
  get blobType() {
    return this.originalResponse.blobType;
  }
  /**
   * The number of bytes present in the
   * response body.
   *
   * @readonly
   */
  get contentLength() {
    return this.originalResponse.contentLength;
  }
  /**
   * If the file has an MD5 hash and the
   * request is to read the full file, this response header is returned so that
   * the client can check for message content integrity. If the request is to
   * read a specified range and the 'x-ms-range-get-content-md5' is set to
   * true, then the request returns an MD5 hash for the range, as long as the
   * range size is less than or equal to 4 MB. If neither of these sets of
   * conditions is true, then no value is returned for the 'Content-MD5'
   * header.
   *
   * @readonly
   */
  get contentMD5() {
    return this.originalResponse.contentMD5;
  }
  /**
   * Indicates the range of bytes returned if
   * the client requested a subset of the file by setting the Range request
   * header.
   *
   * @readonly
   */
  get contentRange() {
    return this.originalResponse.contentRange;
  }
  /**
   * The content type specified for the file.
   * The default content type is 'application/octet-stream'
   *
   * @readonly
   */
  get contentType() {
    return this.originalResponse.contentType;
  }
  /**
   * Conclusion time of the last attempted
   * Copy File operation where this file was the destination file. This value
   * can specify the time of a completed, aborted, or failed copy attempt.
   *
   * @readonly
   */
  get copyCompletedOn() {
    return this.originalResponse.copyCompletedOn;
  }
  /**
   * String identifier for the last attempted Copy
   * File operation where this file was the destination file.
   *
   * @readonly
   */
  get copyId() {
    return this.originalResponse.copyId;
  }
  /**
   * Contains the number of bytes copied and
   * the total bytes in the source in the last attempted Copy File operation
   * where this file was the destination file. Can show between 0 and
   * Content-Length bytes copied.
   *
   * @readonly
   */
  get copyProgress() {
    return this.originalResponse.copyProgress;
  }
  /**
   * URL up to 2KB in length that specifies the
   * source file used in the last attempted Copy File operation where this file
   * was the destination file.
   *
   * @readonly
   */
  get copySource() {
    return this.originalResponse.copySource;
  }
  /**
   * State of the copy operation
   * identified by 'x-ms-copy-id'. Possible values include: 'pending',
   * 'success', 'aborted', 'failed'
   *
   * @readonly
   */
  get copyStatus() {
    return this.originalResponse.copyStatus;
  }
  /**
   * Only appears when
   * x-ms-copy-status is failed or pending. Describes cause of fatal or
   * non-fatal copy operation failure.
   *
   * @readonly
   */
  get copyStatusDescription() {
    return this.originalResponse.copyStatusDescription;
  }
  /**
   * When a blob is leased,
   * specifies whether the lease is of infinite or fixed duration. Possible
   * values include: 'infinite', 'fixed'.
   *
   * @readonly
   */
  get leaseDuration() {
    return this.originalResponse.leaseDuration;
  }
  /**
   * Lease state of the blob. Possible
   * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
   *
   * @readonly
   */
  get leaseState() {
    return this.originalResponse.leaseState;
  }
  /**
   * The current lease status of the
   * blob. Possible values include: 'locked', 'unlocked'.
   *
   * @readonly
   */
  get leaseStatus() {
    return this.originalResponse.leaseStatus;
  }
  /**
   * A UTC date/time value generated by the service that
   * indicates the time at which the response was initiated.
   *
   * @readonly
   */
  get date() {
    return this.originalResponse.date;
  }
  /**
   * The number of committed blocks
   * present in the blob. This header is returned only for append blobs.
   *
   * @readonly
   */
  get blobCommittedBlockCount() {
    return this.originalResponse.blobCommittedBlockCount;
  }
  /**
   * The ETag contains a value that you can use to
   * perform operations conditionally, in quotes.
   *
   * @readonly
   */
  get etag() {
    return this.originalResponse.etag;
  }
  /**
   * The number of tags associated with the blob
   *
   * @readonly
   */
  get tagCount() {
    return this.originalResponse.tagCount;
  }
  /**
   * The error code.
   *
   * @readonly
   */
  get errorCode() {
    return this.originalResponse.errorCode;
  }
  /**
   * The value of this header is set to
   * true if the file data and application metadata are completely encrypted
   * using the specified algorithm. Otherwise, the value is set to false (when
   * the file is unencrypted, or if only parts of the file/application metadata
   * are encrypted).
   *
   * @readonly
   */
  get isServerEncrypted() {
    return this.originalResponse.isServerEncrypted;
  }
  /**
   * If the blob has a MD5 hash, and if
   * request contains range header (Range or x-ms-range), this response header
   * is returned with the value of the whole blob's MD5 value. This value may
   * or may not be equal to the value returned in Content-MD5 header, with the
   * latter calculated from the requested range.
   *
   * @readonly
   */
  get blobContentMD5() {
    return this.originalResponse.blobContentMD5;
  }
  /**
   * Returns the date and time the file was last
   * modified. Any operation that modifies the file or its properties updates
   * the last modified time.
   *
   * @readonly
   */
  get lastModified() {
    return this.originalResponse.lastModified;
  }
  /**
   * Returns the UTC date and time generated by the service that indicates the time at which the blob was
   * last read or written to.
   *
   * @readonly
   */
  get lastAccessed() {
    return this.originalResponse.lastAccessed;
  }
  /**
   * Returns the date and time the blob was created.
   *
   * @readonly
   */
  get createdOn() {
    return this.originalResponse.createdOn;
  }
  /**
   * A name-value pair
   * to associate with a file storage object.
   *
   * @readonly
   */
  get metadata() {
    return this.originalResponse.metadata;
  }
  /**
   * This header uniquely identifies the request
   * that was made and can be used for troubleshooting the request.
   *
   * @readonly
   */
  get requestId() {
    return this.originalResponse.requestId;
  }
  /**
   * If a client request id header is sent in the request, this header will be present in the
   * response with the same value.
   *
   * @readonly
   */
  get clientRequestId() {
    return this.originalResponse.clientRequestId;
  }
  /**
   * Indicates the version of the Blob service used
   * to execute the request.
   *
   * @readonly
   */
  get version() {
    return this.originalResponse.version;
  }
  /**
   * Indicates the versionId of the downloaded blob version.
   *
   * @readonly
   */
  get versionId() {
    return this.originalResponse.versionId;
  }
  /**
   * Indicates whether version of this blob is a current version.
   *
   * @readonly
   */
  get isCurrentVersion() {
    return this.originalResponse.isCurrentVersion;
  }
  /**
   * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
   * when the blob was encrypted with a customer-provided key.
   *
   * @readonly
   */
  get encryptionKeySha256() {
    return this.originalResponse.encryptionKeySha256;
  }
  /**
   * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
   * true, then the request returns a crc64 for the range, as long as the range size is less than
   * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
   * specified in the same request, it will fail with 400(Bad Request)
   */
  get contentCrc64() {
    return this.originalResponse.contentCrc64;
  }
  /**
   * Object Replication Policy Id of the destination blob.
   *
   * @readonly
   */
  get objectReplicationDestinationPolicyId() {
    return this.originalResponse.objectReplicationDestinationPolicyId;
  }
  /**
   * Parsed Object Replication Policy Id, Rule Id(s) and status of the source blob.
   *
   * @readonly
   */
  get objectReplicationSourceProperties() {
    return this.originalResponse.objectReplicationSourceProperties;
  }
  /**
   * If this blob has been sealed.
   *
   * @readonly
   */
  get isSealed() {
    return this.originalResponse.isSealed;
  }
  /**
   * UTC date/time value generated by the service that indicates the time at which the blob immutability policy will expire.
   *
   * @readonly
   */
  get immutabilityPolicyExpiresOn() {
    return this.originalResponse.immutabilityPolicyExpiresOn;
  }
  /**
   * Indicates immutability policy mode.
   *
   * @readonly
   */
  get immutabilityPolicyMode() {
    return this.originalResponse.immutabilityPolicyMode;
  }
  /**
   * Indicates if a legal hold is present on the blob.
   *
   * @readonly
   */
  get legalHold() {
    return this.originalResponse.legalHold;
  }
  /**
   * The response body as a browser Blob.
   * Always undefined in node.js.
   *
   * @readonly
   */
  get contentAsBlob() {
    return this.originalResponse.blobBody;
  }
  /**
   * The response body as a node.js Readable stream.
   * Always undefined in the browser.
   *
   * It will automatically retry when internal read stream unexpected ends.
   *
   * @readonly
   */
  get readableStreamBody() {
    return Rt ? this.blobDownloadStream : void 0;
  }
  /**
   * The HTTP response.
   */
  get _response() {
    return this.originalResponse._response;
  }
  originalResponse;
  blobDownloadStream;
  /**
   * Creates an instance of BlobDownloadResponse.
   *
   * @param originalResponse -
   * @param getter -
   * @param offset -
   * @param count -
   * @param options -
   */
  constructor(e, r, n, s, i = {}) {
    this.originalResponse = e, this.blobDownloadStream = new HM(this.originalResponse.readableStreamBody, r, n, s, i);
  }
}
const xg = 16, Rg = new Uint8Array([79, 98, 106, 1]), zM = "avro.codec", qM = "avro.schema";
class $e {
  /**
   * Reads a fixed number of bytes from the stream.
   *
   * @param stream -
   * @param length -
   * @param options -
   */
  static async readFixedBytes(e, r, n = {}) {
    const s = await e.read(r, { abortSignal: n.abortSignal });
    if (s.length !== r)
      throw new Error("Hit stream end.");
    return s;
  }
  /**
   * Reads a single byte from the stream.
   *
   * @param stream -
   * @param options -
   */
  static async readByte(e, r = {}) {
    return (await $e.readFixedBytes(e, 1, r))[0];
  }
  // int and long are stored in variable-length zig-zag coding.
  // variable-length: https://lucene.apache.org/core/3_5_0/fileformats.html#VInt
  // zig-zag: https://developers.google.com/protocol-buffers/docs/encoding?csw=1#types
  static async readZigZagLong(e, r = {}) {
    let n = 0, s = 0, i, o, a;
    do
      i = await $e.readByte(e, r), o = i & 128, n |= (i & 127) << s, s += 7;
    while (o && s < 28);
    if (o) {
      n = n, a = 268435456;
      do
        i = await $e.readByte(e, r), n += (i & 127) * a, a *= 128;
      while (i & 128);
      const A = (n % 2 ? -(n + 1) : n) / 2;
      if (A < Number.MIN_SAFE_INTEGER || A > Number.MAX_SAFE_INTEGER)
        throw new Error("Integer overflow.");
      return A;
    }
    return n >> 1 ^ -(n & 1);
  }
  static async readLong(e, r = {}) {
    return $e.readZigZagLong(e, r);
  }
  static async readInt(e, r = {}) {
    return $e.readZigZagLong(e, r);
  }
  static async readNull() {
    return null;
  }
  static async readBoolean(e, r = {}) {
    const n = await $e.readByte(e, r);
    if (n === 1)
      return !0;
    if (n === 0)
      return !1;
    throw new Error("Byte was not a boolean.");
  }
  static async readFloat(e, r = {}) {
    const n = await $e.readFixedBytes(e, 4, r);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getFloat32(0, !0);
  }
  static async readDouble(e, r = {}) {
    const n = await $e.readFixedBytes(e, 8, r);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getFloat64(0, !0);
  }
  static async readBytes(e, r = {}) {
    const n = await $e.readLong(e, r);
    if (n < 0)
      throw new Error("Bytes size was negative.");
    return e.read(n, { abortSignal: r.abortSignal });
  }
  static async readString(e, r = {}) {
    const n = await $e.readBytes(e, r);
    return new TextDecoder().decode(n);
  }
  static async readMapPair(e, r, n = {}) {
    const s = await $e.readString(e, n), i = await r(e, n);
    return { key: s, value: i };
  }
  static async readMap(e, r, n = {}) {
    const s = (a, A = {}) => $e.readMapPair(a, r, A), i = await $e.readArray(e, s, n), o = {};
    for (const a of i)
      o[a.key] = a.value;
    return o;
  }
  static async readArray(e, r, n = {}) {
    const s = [];
    for (let i = await $e.readLong(e, n); i !== 0; i = await $e.readLong(e, n))
      for (i < 0 && (await $e.readLong(e, n), i = -i); i--; ) {
        const o = await r(e, n);
        s.push(o);
      }
    return s;
  }
}
var pn;
(function(t) {
  t.RECORD = "record", t.ENUM = "enum", t.ARRAY = "array", t.MAP = "map", t.UNION = "union", t.FIXED = "fixed";
})(pn || (pn = {}));
var St;
(function(t) {
  t.NULL = "null", t.BOOLEAN = "boolean", t.INT = "int", t.LONG = "long", t.FLOAT = "float", t.DOUBLE = "double", t.BYTES = "bytes", t.STRING = "string";
})(St || (St = {}));
class Xt {
  /**
   * Determines the AvroType from the Avro Schema.
   */
  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
  static fromSchema(e) {
    return typeof e == "string" ? Xt.fromStringSchema(e) : Array.isArray(e) ? Xt.fromArraySchema(e) : Xt.fromObjectSchema(e);
  }
  static fromStringSchema(e) {
    switch (e) {
      case St.NULL:
      case St.BOOLEAN:
      case St.INT:
      case St.LONG:
      case St.FLOAT:
      case St.DOUBLE:
      case St.BYTES:
      case St.STRING:
        return new GM(e);
      default:
        throw new Error(`Unexpected Avro type ${e}`);
    }
  }
  static fromArraySchema(e) {
    return new JM(e.map(Xt.fromSchema));
  }
  static fromObjectSchema(e) {
    const r = e.type;
    try {
      return Xt.fromStringSchema(r);
    } catch {
    }
    switch (r) {
      case pn.RECORD:
        if (e.aliases)
          throw new Error(`aliases currently is not supported, schema: ${e}`);
        if (!e.name)
          throw new Error(`Required attribute 'name' doesn't exist on schema: ${e}`);
        const n = {};
        if (!e.fields)
          throw new Error(`Required attribute 'fields' doesn't exist on schema: ${e}`);
        for (const s of e.fields)
          n[s.name] = Xt.fromSchema(s.type);
        return new _M(n, e.name);
      case pn.ENUM:
        if (e.aliases)
          throw new Error(`aliases currently is not supported, schema: ${e}`);
        if (!e.symbols)
          throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${e}`);
        return new YM(e.symbols);
      case pn.MAP:
        if (!e.values)
          throw new Error(`Required attribute 'values' doesn't exist on schema: ${e}`);
        return new VM(Xt.fromSchema(e.values));
      case pn.ARRAY:
      // Unused today
      case pn.FIXED:
      // Unused today
      default:
        throw new Error(`Unexpected Avro type ${r} in ${e}`);
    }
  }
}
class GM extends Xt {
  _primitive;
  constructor(e) {
    super(), this._primitive = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
  read(e, r = {}) {
    switch (this._primitive) {
      case St.NULL:
        return $e.readNull();
      case St.BOOLEAN:
        return $e.readBoolean(e, r);
      case St.INT:
        return $e.readInt(e, r);
      case St.LONG:
        return $e.readLong(e, r);
      case St.FLOAT:
        return $e.readFloat(e, r);
      case St.DOUBLE:
        return $e.readDouble(e, r);
      case St.BYTES:
        return $e.readBytes(e, r);
      case St.STRING:
        return $e.readString(e, r);
      default:
        throw new Error("Unknown Avro Primitive");
    }
  }
}
class YM extends Xt {
  _symbols;
  constructor(e) {
    super(), this._symbols = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
  async read(e, r = {}) {
    const n = await $e.readInt(e, r);
    return this._symbols[n];
  }
}
class JM extends Xt {
  _types;
  constructor(e) {
    super(), this._types = e;
  }
  async read(e, r = {}) {
    const n = await $e.readInt(e, r);
    return this._types[n].read(e, r);
  }
}
class VM extends Xt {
  _itemType;
  constructor(e) {
    super(), this._itemType = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
  read(e, r = {}) {
    const n = (s, i) => this._itemType.read(s, i);
    return $e.readMap(e, n, r);
  }
}
class _M extends Xt {
  _name;
  _fields;
  constructor(e, r) {
    super(), this._fields = e, this._name = r;
  }
  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
  async read(e, r = {}) {
    const n = {};
    n.$schema = this._name;
    for (const s in this._fields)
      Object.prototype.hasOwnProperty.call(this._fields, s) && (n[s] = await this._fields[s].read(e, r));
    return n;
  }
}
function Sg(t, e) {
  if (t === e)
    return !0;
  if (t == null || e == null || t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; ++r)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
class WM {
  _dataStream;
  _headerStream;
  _syncMarker;
  _metadata;
  _itemType;
  _itemsRemainingInBlock;
  // Remembers where we started if partial data stream was provided.
  _initialBlockOffset;
  /// The byte offset within the Avro file (both header and data)
  /// of the start of the current block.
  _blockOffset;
  get blockOffset() {
    return this._blockOffset;
  }
  _objectIndex;
  get objectIndex() {
    return this._objectIndex;
  }
  _initialized;
  constructor(e, r, n, s) {
    this._dataStream = e, this._headerStream = r || e, this._initialized = !1, this._blockOffset = n || 0, this._objectIndex = s || 0, this._initialBlockOffset = n || 0;
  }
  async initialize(e = {}) {
    const r = await $e.readFixedBytes(this._headerStream, Rg.length, {
      abortSignal: e.abortSignal
    });
    if (!Sg(r, Rg))
      throw new Error("Stream is not an Avro file.");
    this._metadata = await $e.readMap(this._headerStream, $e.readString, {
      abortSignal: e.abortSignal
    });
    const n = this._metadata[zM];
    if (!(n == null || n === "null"))
      throw new Error("Codecs are not supported");
    this._syncMarker = await $e.readFixedBytes(this._headerStream, xg, {
      abortSignal: e.abortSignal
    });
    const s = JSON.parse(this._metadata[qM]);
    if (this._itemType = Xt.fromSchema(s), this._blockOffset === 0 && (this._blockOffset = this._initialBlockOffset + this._dataStream.position), this._itemsRemainingInBlock = await $e.readLong(this._dataStream, {
      abortSignal: e.abortSignal
    }), await $e.readLong(this._dataStream, { abortSignal: e.abortSignal }), this._initialized = !0, this._objectIndex && this._objectIndex > 0)
      for (let i = 0; i < this._objectIndex; i++)
        await this._itemType.read(this._dataStream, { abortSignal: e.abortSignal }), this._itemsRemainingInBlock--;
  }
  hasNext() {
    return !this._initialized || this._itemsRemainingInBlock > 0;
  }
  async *parseObjects(e = {}) {
    for (this._initialized || await this.initialize(e); this.hasNext(); ) {
      const r = await this._itemType.read(this._dataStream, {
        abortSignal: e.abortSignal
      });
      if (this._itemsRemainingInBlock--, this._objectIndex++, this._itemsRemainingInBlock === 0) {
        const n = await $e.readFixedBytes(this._dataStream, xg, {
          abortSignal: e.abortSignal
        });
        if (this._blockOffset = this._initialBlockOffset + this._dataStream.position, this._objectIndex = 0, !Sg(this._syncMarker, n))
          throw new Error("Stream is not a valid Avro file.");
        try {
          this._itemsRemainingInBlock = await $e.readLong(this._dataStream, {
            abortSignal: e.abortSignal
          });
        } catch {
          this._itemsRemainingInBlock = 0;
        }
        this._itemsRemainingInBlock > 0 && await $e.readLong(this._dataStream, { abortSignal: e.abortSignal });
      }
      yield r;
    }
  }
}
class $M {
}
const Dg = new ii("Reading from the avro stream was aborted.");
class XM extends $M {
  _position;
  _readable;
  toUint8Array(e) {
    return typeof e == "string" ? By.from(e) : e;
  }
  constructor(e) {
    super(), this._readable = e, this._position = 0;
  }
  get position() {
    return this._position;
  }
  async read(e, r = {}) {
    if (r.abortSignal?.aborted)
      throw Dg;
    if (e < 0)
      throw new Error(`size parameter should be positive: ${e}`);
    if (e === 0)
      return new Uint8Array();
    if (!this._readable.readable)
      throw new Error("Stream no longer readable.");
    const n = this._readable.read(e);
    return n ? (this._position += n.length, this.toUint8Array(n)) : new Promise((s, i) => {
      const o = () => {
        this._readable.removeListener("readable", a), this._readable.removeListener("error", A), this._readable.removeListener("end", A), this._readable.removeListener("close", A), r.abortSignal && r.abortSignal.removeEventListener("abort", c);
      }, a = () => {
        const l = this._readable.read(e);
        l && (this._position += l.length, o(), s(this.toUint8Array(l)));
      }, A = () => {
        o(), i();
      }, c = () => {
        o(), i(Dg);
      };
      this._readable.on("readable", a), this._readable.once("error", A), this._readable.once("end", A), this._readable.once("close", A), r.abortSignal && r.abortSignal.addEventListener("abort", c);
    });
  }
}
class ZM extends gl {
  source;
  avroReader;
  avroIter;
  avroPaused = !0;
  onProgress;
  onError;
  /**
   * Creates an instance of BlobQuickQueryStream.
   *
   * @param source - The current ReadableStream returned from getter
   * @param options -
   */
  constructor(e, r = {}) {
    super(), this.source = e, this.onProgress = r.onProgress, this.onError = r.onError, this.avroReader = new WM(new XM(this.source)), this.avroIter = this.avroReader.parseObjects({ abortSignal: r.abortSignal });
  }
  _read() {
    this.avroPaused && this.readInternal().catch((e) => {
      this.emit("error", e);
    });
  }
  async readInternal() {
    this.avroPaused = !1;
    let e;
    do {
      if (e = await this.avroIter.next(), e.done)
        break;
      const r = e.value, n = r.$schema;
      if (typeof n != "string")
        throw Error("Missing schema in avro record.");
      switch (n) {
        case "com.microsoft.azure.storage.queryBlobContents.resultData":
          {
            const s = r.data;
            if (!(s instanceof Uint8Array))
              throw Error("Invalid data in avro result record.");
            this.push(Buffer.from(s)) || (this.avroPaused = !0);
          }
          break;
        case "com.microsoft.azure.storage.queryBlobContents.progress":
          {
            const s = r.bytesScanned;
            if (typeof s != "number")
              throw Error("Invalid bytesScanned in avro progress record.");
            this.onProgress && this.onProgress({ loadedBytes: s });
          }
          break;
        case "com.microsoft.azure.storage.queryBlobContents.end":
          if (this.onProgress) {
            const s = r.totalBytes;
            if (typeof s != "number")
              throw Error("Invalid totalBytes in avro end record.");
            this.onProgress({ loadedBytes: s });
          }
          this.push(null);
          break;
        case "com.microsoft.azure.storage.queryBlobContents.error":
          if (this.onError) {
            const s = r.fatal;
            if (typeof s != "boolean")
              throw Error("Invalid fatal in avro error record.");
            const i = r.name;
            if (typeof i != "string")
              throw Error("Invalid name in avro error record.");
            const o = r.description;
            if (typeof o != "string")
              throw Error("Invalid description in avro error record.");
            const a = r.position;
            if (typeof a != "number")
              throw Error("Invalid position in avro error record.");
            this.onError({
              position: a,
              name: i,
              isFatal: s,
              description: o
            });
          }
          break;
        default:
          throw Error(`Unknown schema ${n} in avro progress record.`);
      }
    } while (!e.done && !this.avroPaused);
  }
}
class KM {
  /**
   * Indicates that the service supports
   * requests for partial file content.
   *
   * @readonly
   */
  get acceptRanges() {
    return this.originalResponse.acceptRanges;
  }
  /**
   * Returns if it was previously specified
   * for the file.
   *
   * @readonly
   */
  get cacheControl() {
    return this.originalResponse.cacheControl;
  }
  /**
   * Returns the value that was specified
   * for the 'x-ms-content-disposition' header and specifies how to process the
   * response.
   *
   * @readonly
   */
  get contentDisposition() {
    return this.originalResponse.contentDisposition;
  }
  /**
   * Returns the value that was specified
   * for the Content-Encoding request header.
   *
   * @readonly
   */
  get contentEncoding() {
    return this.originalResponse.contentEncoding;
  }
  /**
   * Returns the value that was specified
   * for the Content-Language request header.
   *
   * @readonly
   */
  get contentLanguage() {
    return this.originalResponse.contentLanguage;
  }
  /**
   * The current sequence number for a
   * page blob. This header is not returned for block blobs or append blobs.
   *
   * @readonly
   */
  get blobSequenceNumber() {
    return this.originalResponse.blobSequenceNumber;
  }
  /**
   * The blob's type. Possible values include:
   * 'BlockBlob', 'PageBlob', 'AppendBlob'.
   *
   * @readonly
   */
  get blobType() {
    return this.originalResponse.blobType;
  }
  /**
   * The number of bytes present in the
   * response body.
   *
   * @readonly
   */
  get contentLength() {
    return this.originalResponse.contentLength;
  }
  /**
   * If the file has an MD5 hash and the
   * request is to read the full file, this response header is returned so that
   * the client can check for message content integrity. If the request is to
   * read a specified range and the 'x-ms-range-get-content-md5' is set to
   * true, then the request returns an MD5 hash for the range, as long as the
   * range size is less than or equal to 4 MB. If neither of these sets of
   * conditions is true, then no value is returned for the 'Content-MD5'
   * header.
   *
   * @readonly
   */
  get contentMD5() {
    return this.originalResponse.contentMD5;
  }
  /**
   * Indicates the range of bytes returned if
   * the client requested a subset of the file by setting the Range request
   * header.
   *
   * @readonly
   */
  get contentRange() {
    return this.originalResponse.contentRange;
  }
  /**
   * The content type specified for the file.
   * The default content type is 'application/octet-stream'
   *
   * @readonly
   */
  get contentType() {
    return this.originalResponse.contentType;
  }
  /**
   * Conclusion time of the last attempted
   * Copy File operation where this file was the destination file. This value
   * can specify the time of a completed, aborted, or failed copy attempt.
   *
   * @readonly
   */
  get copyCompletedOn() {
  }
  /**
   * String identifier for the last attempted Copy
   * File operation where this file was the destination file.
   *
   * @readonly
   */
  get copyId() {
    return this.originalResponse.copyId;
  }
  /**
   * Contains the number of bytes copied and
   * the total bytes in the source in the last attempted Copy File operation
   * where this file was the destination file. Can show between 0 and
   * Content-Length bytes copied.
   *
   * @readonly
   */
  get copyProgress() {
    return this.originalResponse.copyProgress;
  }
  /**
   * URL up to 2KB in length that specifies the
   * source file used in the last attempted Copy File operation where this file
   * was the destination file.
   *
   * @readonly
   */
  get copySource() {
    return this.originalResponse.copySource;
  }
  /**
   * State of the copy operation
   * identified by 'x-ms-copy-id'. Possible values include: 'pending',
   * 'success', 'aborted', 'failed'
   *
   * @readonly
   */
  get copyStatus() {
    return this.originalResponse.copyStatus;
  }
  /**
   * Only appears when
   * x-ms-copy-status is failed or pending. Describes cause of fatal or
   * non-fatal copy operation failure.
   *
   * @readonly
   */
  get copyStatusDescription() {
    return this.originalResponse.copyStatusDescription;
  }
  /**
   * When a blob is leased,
   * specifies whether the lease is of infinite or fixed duration. Possible
   * values include: 'infinite', 'fixed'.
   *
   * @readonly
   */
  get leaseDuration() {
    return this.originalResponse.leaseDuration;
  }
  /**
   * Lease state of the blob. Possible
   * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
   *
   * @readonly
   */
  get leaseState() {
    return this.originalResponse.leaseState;
  }
  /**
   * The current lease status of the
   * blob. Possible values include: 'locked', 'unlocked'.
   *
   * @readonly
   */
  get leaseStatus() {
    return this.originalResponse.leaseStatus;
  }
  /**
   * A UTC date/time value generated by the service that
   * indicates the time at which the response was initiated.
   *
   * @readonly
   */
  get date() {
    return this.originalResponse.date;
  }
  /**
   * The number of committed blocks
   * present in the blob. This header is returned only for append blobs.
   *
   * @readonly
   */
  get blobCommittedBlockCount() {
    return this.originalResponse.blobCommittedBlockCount;
  }
  /**
   * The ETag contains a value that you can use to
   * perform operations conditionally, in quotes.
   *
   * @readonly
   */
  get etag() {
    return this.originalResponse.etag;
  }
  /**
   * The error code.
   *
   * @readonly
   */
  get errorCode() {
    return this.originalResponse.errorCode;
  }
  /**
   * The value of this header is set to
   * true if the file data and application metadata are completely encrypted
   * using the specified algorithm. Otherwise, the value is set to false (when
   * the file is unencrypted, or if only parts of the file/application metadata
   * are encrypted).
   *
   * @readonly
   */
  get isServerEncrypted() {
    return this.originalResponse.isServerEncrypted;
  }
  /**
   * If the blob has a MD5 hash, and if
   * request contains range header (Range or x-ms-range), this response header
   * is returned with the value of the whole blob's MD5 value. This value may
   * or may not be equal to the value returned in Content-MD5 header, with the
   * latter calculated from the requested range.
   *
   * @readonly
   */
  get blobContentMD5() {
    return this.originalResponse.blobContentMD5;
  }
  /**
   * Returns the date and time the file was last
   * modified. Any operation that modifies the file or its properties updates
   * the last modified time.
   *
   * @readonly
   */
  get lastModified() {
    return this.originalResponse.lastModified;
  }
  /**
   * A name-value pair
   * to associate with a file storage object.
   *
   * @readonly
   */
  get metadata() {
    return this.originalResponse.metadata;
  }
  /**
   * This header uniquely identifies the request
   * that was made and can be used for troubleshooting the request.
   *
   * @readonly
   */
  get requestId() {
    return this.originalResponse.requestId;
  }
  /**
   * If a client request id header is sent in the request, this header will be present in the
   * response with the same value.
   *
   * @readonly
   */
  get clientRequestId() {
    return this.originalResponse.clientRequestId;
  }
  /**
   * Indicates the version of the File service used
   * to execute the request.
   *
   * @readonly
   */
  get version() {
    return this.originalResponse.version;
  }
  /**
   * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
   * when the blob was encrypted with a customer-provided key.
   *
   * @readonly
   */
  get encryptionKeySha256() {
    return this.originalResponse.encryptionKeySha256;
  }
  /**
   * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
   * true, then the request returns a crc64 for the range, as long as the range size is less than
   * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
   * specified in the same request, it will fail with 400(Bad Request)
   */
  get contentCrc64() {
    return this.originalResponse.contentCrc64;
  }
  /**
   * The response body as a browser Blob.
   * Always undefined in node.js.
   *
   * @readonly
   */
  get blobBody() {
  }
  /**
   * The response body as a node.js Readable stream.
   * Always undefined in the browser.
   *
   * It will parse avor data returned by blob query.
   *
   * @readonly
   */
  get readableStreamBody() {
    return Rt ? this.blobDownloadStream : void 0;
  }
  /**
   * The HTTP response.
   */
  get _response() {
    return this.originalResponse._response;
  }
  originalResponse;
  blobDownloadStream;
  /**
   * Creates an instance of BlobQueryResponse.
   *
   * @param originalResponse -
   * @param options -
   */
  constructor(e, r = {}) {
    this.originalResponse = e, this.blobDownloadStream = new ZM(this.originalResponse.readableStreamBody, r);
  }
}
var kg;
(function(t) {
  t.Hot = "Hot", t.Cool = "Cool", t.Cold = "Cold", t.Archive = "Archive";
})(kg || (kg = {}));
var Mg;
(function(t) {
  t.P4 = "P4", t.P6 = "P6", t.P10 = "P10", t.P15 = "P15", t.P20 = "P20", t.P30 = "P30", t.P40 = "P40", t.P50 = "P50", t.P60 = "P60", t.P70 = "P70", t.P80 = "P80";
})(Mg || (Mg = {}));
function Nn(t) {
  if (t !== void 0)
    return t;
}
function Dt(t, e) {
  if (t && !e)
    throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
  t && !t.encryptionAlgorithm && (t.encryptionAlgorithm = gS);
}
var Tg;
(function(t) {
  t.StorageOAuthScopes = "https://storage.azure.com/.default", t.DiskComputeOAuthScopes = "https://disk.compute.azure.com/.default";
})(Tg || (Tg = {}));
function vc(t) {
  const e = (t._response.parsedBody.pageRange || []).map((n) => ({
    offset: n.start,
    count: n.end - n.start
  })), r = (t._response.parsedBody.clearRange || []).map((n) => ({
    offset: n.start,
    count: n.end - n.start
  }));
  return {
    ...t,
    pageRange: e,
    clearRange: r,
    _response: {
      ...t._response,
      parsedBody: {
        pageRange: e,
        clearRange: r
      }
    }
  };
}
class cd extends Error {
  constructor(e) {
    super(e), this.name = "PollerStoppedError", Object.setPrototypeOf(this, cd.prototype);
  }
}
class ld extends Error {
  constructor(e) {
    super(e), this.name = "PollerCancelledError", Object.setPrototypeOf(this, ld.prototype);
  }
}
class jM {
  /**
   * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.
   *
   * When writing an implementation of a Poller, this implementation needs to deal with the initialization
   * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's
   * operation has already been defined, at least its basic properties. The code below shows how to approach
   * the definition of the constructor of a new custom poller.
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor({
   *     // Anything you might need outside of the basics
   *   }) {
   *     let state: MyOperationState = {
   *       privateProperty: private,
   *       publicProperty: public,
   *     };
   *
   *     const operation = {
   *       state,
   *       update,
   *       cancel,
   *       toString
   *     }
   *
   *     // Sending the operation to the parent's constructor.
   *     super(operation);
   *
   *     // You can assign more local properties here.
   *   }
   * }
   * ```
   *
   * Inside of this constructor, a new promise is created. This will be used to
   * tell the user when the poller finishes (see `pollUntilDone()`). The promise's
   * resolve and reject methods are also used internally to control when to resolve
   * or reject anyone waiting for the poller to finish.
   *
   * The constructor of a custom implementation of a poller is where any serialized version of
   * a previous poller's operation should be deserialized into the operation sent to the
   * base constructor. For example:
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor(
   *     baseOperation: string | undefined
   *   ) {
   *     let state: MyOperationState = {};
   *     if (baseOperation) {
   *       state = {
   *         ...JSON.parse(baseOperation).state,
   *         ...state
   *       };
   *     }
   *     const operation = {
   *       state,
   *       // ...
   *     }
   *     super(operation);
   *   }
   * }
   * ```
   *
   * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.
   */
  constructor(e) {
    this.resolveOnUnsuccessful = !1, this.stopped = !0, this.pollProgressCallbacks = [], this.operation = e, this.promise = new Promise((r, n) => {
      this.resolve = r, this.reject = n;
    }), this.promise.catch(() => {
    });
  }
  /**
   * Starts a loop that will break only if the poller is done
   * or if the poller is stopped.
   */
  async startPolling(e = {}) {
    for (this.stopped && (this.stopped = !1); !this.isStopped() && !this.isDone(); )
      await this.poll(e), await this.delay();
  }
  /**
   * pollOnce does one polling, by calling to the update method of the underlying
   * poll operation to make any relevant change effective.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  async pollOnce(e = {}) {
    this.isDone() || (this.operation = await this.operation.update({
      abortSignal: e.abortSignal,
      fireProgress: this.fireProgress.bind(this)
    })), this.processUpdatedState();
  }
  /**
   * fireProgress calls the functions passed in via onProgress the method of the poller.
   *
   * It loops over all of the callbacks received from onProgress, and executes them, sending them
   * the current operation state.
   *
   * @param state - The current operation state.
   */
  fireProgress(e) {
    for (const r of this.pollProgressCallbacks)
      r(e);
  }
  /**
   * Invokes the underlying operation's cancel method.
   */
  async cancelOnce(e = {}) {
    this.operation = await this.operation.cancel(e);
  }
  /**
   * Returns a promise that will resolve once a single polling request finishes.
   * It does this by calling the update method of the Poller's operation.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  poll(e = {}) {
    if (!this.pollOncePromise) {
      this.pollOncePromise = this.pollOnce(e);
      const r = () => {
        this.pollOncePromise = void 0;
      };
      this.pollOncePromise.then(r, r).catch(this.reject);
    }
    return this.pollOncePromise;
  }
  processUpdatedState() {
    if (this.operation.state.error && (this.stopped = !0, !this.resolveOnUnsuccessful))
      throw this.reject(this.operation.state.error), this.operation.state.error;
    if (this.operation.state.isCancelled && (this.stopped = !0, !this.resolveOnUnsuccessful)) {
      const e = new ld("Operation was canceled");
      throw this.reject(e), e;
    }
    this.isDone() && this.resolve && this.resolve(this.getResult());
  }
  /**
   * Returns a promise that will resolve once the underlying operation is completed.
   */
  async pollUntilDone(e = {}) {
    return this.stopped && this.startPolling(e).catch(this.reject), this.processUpdatedState(), this.promise;
  }
  /**
   * Invokes the provided callback after each polling is completed,
   * sending the current state of the poller's operation.
   *
   * It returns a method that can be used to stop receiving updates on the given callback function.
   */
  onProgress(e) {
    return this.pollProgressCallbacks.push(e), () => {
      this.pollProgressCallbacks = this.pollProgressCallbacks.filter((r) => r !== e);
    };
  }
  /**
   * Returns true if the poller has finished polling.
   */
  isDone() {
    const e = this.operation.state;
    return !!(e.isCompleted || e.isCancelled || e.error);
  }
  /**
   * Stops the poller from continuing to poll.
   */
  stopPolling() {
    this.stopped || (this.stopped = !0, this.reject && this.reject(new cd("This poller is already stopped")));
  }
  /**
   * Returns true if the poller is stopped.
   */
  isStopped() {
    return this.stopped;
  }
  /**
   * Attempts to cancel the underlying operation.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * If it's called again before it finishes, it will throw an error.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  cancelOperation(e = {}) {
    if (!this.cancelPromise)
      this.cancelPromise = this.cancelOnce(e);
    else if (e.abortSignal)
      throw new Error("A cancel request is currently pending");
    return this.cancelPromise;
  }
  /**
   * Returns the state of the operation.
   *
   * Even though TState will be the same type inside any of the methods of any extension of the Poller class,
   * implementations of the pollers can customize what's shared with the public by writing their own
   * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller
   * and a public type representing a safe to share subset of the properties of the internal state.
   * Their definition of getOperationState can then return their public type.
   *
   * Example:
   *
   * ```ts
   * // Let's say we have our poller's operation state defined as:
   * interface MyOperationState extends PollOperationState<ResultType> {
   *   privateProperty?: string;
   *   publicProperty?: string;
   * }
   *
   * // To allow us to have a true separation of public and private state, we have to define another interface:
   * interface PublicState extends PollOperationState<ResultType> {
   *   publicProperty?: string;
   * }
   *
   * // Then, we define our Poller as follows:
   * export class MyPoller extends Poller<MyOperationState, ResultType> {
   *   // ... More content is needed here ...
   *
   *   public getOperationState(): PublicState {
   *     const state: PublicState = this.operation.state;
   *     return {
   *       // Properties from PollOperationState<TResult>
   *       isStarted: state.isStarted,
   *       isCompleted: state.isCompleted,
   *       isCancelled: state.isCancelled,
   *       error: state.error,
   *       result: state.result,
   *
   *       // The only other property needed by PublicState.
   *       publicProperty: state.publicProperty
   *     }
   *   }
   * }
   * ```
   *
   * You can see this in the tests of this repository, go to the file:
   * `../test/utils/testPoller.ts`
   * and look for the getOperationState implementation.
   */
  getOperationState() {
    return this.operation.state;
  }
  /**
   * Returns the result value of the operation,
   * regardless of the state of the poller.
   * It can return undefined or an incomplete form of the final TResult value
   * depending on the implementation.
   */
  getResult() {
    return this.operation.state.result;
  }
  /**
   * Returns a serialized version of the poller's operation
   * by invoking the operation's toString method.
   */
  toString() {
    return this.operation.toString();
  }
}
class eT extends jM {
  intervalInMs;
  constructor(e) {
    const { blobClient: r, copySource: n, intervalInMs: s = 15e3, onProgress: i, resumeFrom: o, startCopyFromURLOptions: a } = e;
    let A;
    o && (A = JSON.parse(o).state);
    const c = Fs({
      ...A,
      blobClient: r,
      copySource: n,
      startCopyFromURLOptions: a
    });
    super(c), typeof i == "function" && this.onProgress(i), this.intervalInMs = s;
  }
  delay() {
    return ep(this.intervalInMs);
  }
}
const tT = async function(e = {}) {
  const r = this.state, { copyId: n } = r;
  return r.isCompleted ? Fs(r) : n ? (await r.blobClient.abortCopyFromURL(n, {
    abortSignal: e.abortSignal
  }), r.isCancelled = !0, Fs(r)) : (r.isCancelled = !0, Fs(r));
}, rT = async function(e = {}) {
  const r = this.state, { blobClient: n, copySource: s, startCopyFromURLOptions: i } = r;
  if (r.isStarted) {
    if (!r.isCompleted)
      try {
        const o = await r.blobClient.getProperties({ abortSignal: e.abortSignal }), { copyStatus: a, copyProgress: A } = o, c = r.copyProgress;
        A && (r.copyProgress = A), a === "pending" && A !== c && typeof e.fireProgress == "function" ? e.fireProgress(r) : a === "success" ? (r.result = o, r.isCompleted = !0) : a === "failed" && (r.error = new Error(`Blob copy failed with reason: "${o.copyStatusDescription || "unknown"}"`), r.isCompleted = !0);
      } catch (o) {
        r.error = o, r.isCompleted = !0;
      }
  } else {
    r.isStarted = !0;
    const o = await n.startCopyFromURL(s, i);
    r.copyId = o.copyId, o.copyStatus === "success" && (r.result = o, r.isCompleted = !0);
  }
  return Fs(r);
}, nT = function() {
  return JSON.stringify({ state: this.state }, (e, r) => {
    if (e !== "blobClient")
      return r;
  });
};
function Fs(t) {
  return {
    state: { ...t },
    cancel: tT,
    toString: nT,
    update: rT
  };
}
function nr(t) {
  if (t.offset < 0)
    throw new RangeError("Range.offset cannot be smaller than 0.");
  if (t.count && t.count <= 0)
    throw new RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
  return t.count ? `bytes=${t.offset}-${t.offset + t.count - 1}` : `bytes=${t.offset}-`;
}
var vs;
(function(t) {
  t[t.Good = 0] = "Good", t[t.Error = 1] = "Error";
})(vs || (vs = {}));
class pI {
  /**
   * Concurrency. Must be lager than 0.
   */
  concurrency;
  /**
   * Number of active operations under execution.
   */
  actives = 0;
  /**
   * Number of completed operations under execution.
   */
  completed = 0;
  /**
   * Offset of next operation to be executed.
   */
  offset = 0;
  /**
   * Operation array to be executed.
   */
  operations = [];
  /**
   * States of Batch. When an error happens, state will turn into error.
   * Batch will stop execute left operations.
   */
  state = vs.Good;
  /**
   * A private emitter used to pass events inside this class.
   */
  emitter;
  /**
   * Creates an instance of Batch.
   * @param concurrency -
   */
  constructor(e = 5) {
    if (e < 1)
      throw new RangeError("concurrency must be larger than 0");
    this.concurrency = e, this.emitter = new Wg();
  }
  /**
   * Add a operation into queue.
   *
   * @param operation -
   */
  addOperation(e) {
    this.operations.push(async () => {
      try {
        this.actives++, await e(), this.actives--, this.completed++, this.parallelExecute();
      } catch (r) {
        this.emitter.emit("error", r);
      }
    });
  }
  /**
   * Start execute operations in the queue.
   *
   */
  async do() {
    return this.operations.length === 0 ? Promise.resolve() : (this.parallelExecute(), new Promise((e, r) => {
      this.emitter.on("finish", e), this.emitter.on("error", (n) => {
        this.state = vs.Error, r(n);
      });
    }));
  }
  /**
   * Get next operation to be executed. Return null when reaching ends.
   *
   */
  nextOperation() {
    return this.offset < this.operations.length ? this.operations[this.offset++] : null;
  }
  /**
   * Start execute operations. One one the most important difference between
   * this method with do() is that do() wraps as an sync method.
   *
   */
  parallelExecute() {
    if (this.state !== vs.Error) {
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      for (; this.actives < this.concurrency; ) {
        const e = this.nextOperation();
        if (e)
          e();
        else
          return;
      }
    }
  }
}
async function sT(t, e, r, n, s) {
  let i = 0;
  const o = n - r;
  return new Promise((a, A) => {
    const c = setTimeout(() => A(new Error("The operation cannot be completed in timeout.")), mS);
    t.on("readable", () => {
      if (i >= o) {
        clearTimeout(c), a();
        return;
      }
      let l = t.read();
      if (!l)
        return;
      typeof l == "string" && (l = Buffer.from(l, s));
      const d = i + l.length > o ? o - i : l.length;
      e.fill(l.slice(0, d), r + i, r + i + d), i += d;
    }), t.on("end", () => {
      clearTimeout(c), i < o && A(new Error(`Stream drains before getting enough data needed. Data read: ${i}, data need: ${o}`)), a();
    }), t.on("error", (l) => {
      clearTimeout(c), A(l);
    });
  });
}
async function iT(t, e) {
  return new Promise((r, n) => {
    const s = El.createWriteStream(e);
    t.on("error", (i) => {
      n(i);
    }), s.on("error", (i) => {
      n(i);
    }), s.on("close", r), t.pipe(s);
  });
}
const oT = _t.promisify(El.stat), aT = El.createReadStream;
class wn extends DM {
  /**
   * blobContext provided by protocol layer.
   */
  blobContext;
  _name;
  _containerName;
  _versionId;
  _snapshot;
  /**
   * The name of the blob.
   */
  get name() {
    return this._name;
  }
  /**
   * The name of the storage container the blob is associated with.
   */
  get containerName() {
    return this._containerName;
  }
  constructor(e, r, n, s) {
    s = s || {};
    let i, o;
    if (wo(r))
      o = e, i = r;
    else if (Rt && r instanceof sr || r instanceof Vt || kn(r))
      o = e, s = n, i = Pt(r, s);
    else if (!r && typeof r != "string")
      o = e, n && typeof n != "string" && (s = n), i = Pt(new Vt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const a = r, A = n, c = Mo(e);
      if (c.kind === "AccountConnString")
        if (Rt) {
          const l = new sr(c.accountName, c.accountKey);
          o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)), s.proxyOptions || (s.proxyOptions = Bo(c.proxyUri)), i = Pt(l, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (c.kind === "SASConnString")
        o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)) + "?" + c.accountSas, i = Pt(new Vt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), { blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl(), this.blobContext = this.storageClientContext.blob, this._snapshot = Cg(this.url, Cn.Parameters.SNAPSHOT), this._versionId = Cg(this.url, Cn.Parameters.VERSIONID);
  }
  /**
   * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a Client to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp
   */
  withSnapshot(e) {
    return new wn(Gs(this.url, Cn.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a new BlobClient object pointing to a version of this blob.
   * Provide "" will remove the versionId and return a Client to the base blob.
   *
   * @param versionId - The versionId.
   * @returns A new BlobClient object pointing to the version of this blob.
   */
  withVersion(e) {
    return new wn(Gs(this.url, Cn.Parameters.VERSIONID, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a AppendBlobClient object.
   *
   */
  getAppendBlobClient() {
    return new dd(this.url, this.pipeline);
  }
  /**
   * Creates a BlockBlobClient object.
   *
   */
  getBlockBlobClient() {
    return new To(this.url, this.pipeline);
  }
  /**
   * Creates a PageBlobClient object.
   *
   */
  getPageBlobClient() {
    return new ud(this.url, this.pipeline);
  }
  /**
   * Reads or downloads a blob from the system, including its metadata and properties.
   * You can also call Get Blob to read a snapshot.
   *
   * * In Node.js, data returns in a Readable stream readableStreamBody
   * * In browsers, data returns in a promise blobBody
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/get-blob
   *
   * @param offset - From which position of the blob to download, greater than or equal to 0
   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
   * @param options - Optional options to Blob Download operation.
   *
   *
   * Example usage (Node.js):
   *
   * ```ts snippet:ReadmeSampleDownloadBlob_Node
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   * const blobClient = containerClient.getBlobClient(blobName);
   *
   * // Get blob content from position 0 to the end
   * // In Node.js, get downloaded data by accessing downloadBlockBlobResponse.readableStreamBody
   * const downloadBlockBlobResponse = await blobClient.download();
   * if (downloadBlockBlobResponse.readableStreamBody) {
   *   const downloaded = await streamToString(downloadBlockBlobResponse.readableStreamBody);
   *   console.log(`Downloaded blob content: ${downloaded}`);
   * }
   *
   * async function streamToString(stream: NodeJS.ReadableStream): Promise<string> {
   *   const result = await new Promise<Buffer<ArrayBuffer>>((resolve, reject) => {
   *     const chunks: Buffer[] = [];
   *     stream.on("data", (data) => {
   *       chunks.push(Buffer.isBuffer(data) ? data : Buffer.from(data));
   *     });
   *     stream.on("end", () => {
   *       resolve(Buffer.concat(chunks));
   *     });
   *     stream.on("error", reject);
   *   });
   *   return result.toString();
   * }
   * ```
   *
   * Example usage (browser):
   *
   * ```ts snippet:ReadmeSampleDownloadBlob_Browser
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   * const blobClient = containerClient.getBlobClient(blobName);
   *
   * // Get blob content from position 0 to the end
   * // In browsers, get downloaded data by accessing downloadBlockBlobResponse.blobBody
   * const downloadBlockBlobResponse = await blobClient.download();
   * const blobBody = await downloadBlockBlobResponse.blobBody;
   * if (blobBody) {
   *   const downloaded = await blobBody.text();
   *   console.log(`Downloaded blob content: ${downloaded}`);
   * }
   * ```
   */
  async download(e = 0, r, n = {}) {
    return n.conditions = n.conditions || {}, n.conditions = n.conditions || {}, Dt(n.customerProvidedKey, this.isHttps), Te.withSpan("BlobClient-download", n, async (s) => {
      const i = Ue(await this.blobContext.download({
        abortSignal: n.abortSignal,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: {
          ...n.conditions,
          ifTags: n.conditions?.tagConditions
        },
        requestOptions: {
          onDownloadProgress: Rt ? void 0 : n.onProgress
          // for Node.js, progress is reported by RetriableReadableStream
        },
        range: e === 0 && !r ? void 0 : nr({ offset: e, count: r }),
        rangeGetContentMD5: n.rangeGetContentMD5,
        rangeGetContentCRC64: n.rangeGetContentCrc64,
        snapshot: n.snapshot,
        cpkInfo: n.customerProvidedKey,
        tracingOptions: s.tracingOptions
      })), o = {
        ...i,
        _response: i._response,
        // _response is made non-enumerable
        objectReplicationDestinationPolicyId: i.objectReplicationPolicyId,
        objectReplicationSourceProperties: Qg(i.objectReplicationRules)
      };
      if (!Rt)
        return o;
      if ((n.maxRetryRequests === void 0 || n.maxRetryRequests < 0) && (n.maxRetryRequests = uS), i.contentLength === void 0)
        throw new RangeError("File download response doesn't contain valid content length header");
      if (!i.etag)
        throw new RangeError("File download response doesn't contain valid etag header");
      return new OM(o, async (a) => {
        const A = {
          leaseAccessConditions: n.conditions,
          modifiedAccessConditions: {
            ifMatch: n.conditions.ifMatch || i.etag,
            ifModifiedSince: n.conditions.ifModifiedSince,
            ifNoneMatch: n.conditions.ifNoneMatch,
            ifUnmodifiedSince: n.conditions.ifUnmodifiedSince,
            ifTags: n.conditions?.tagConditions
          },
          range: nr({
            count: e + i.contentLength - a,
            offset: a
          }),
          rangeGetContentMD5: n.rangeGetContentMD5,
          rangeGetContentCRC64: n.rangeGetContentCrc64,
          snapshot: n.snapshot,
          cpkInfo: n.customerProvidedKey
        };
        return (await this.blobContext.download({
          abortSignal: n.abortSignal,
          ...A
        })).readableStreamBody;
      }, e, i.contentLength, {
        maxRetryRequests: n.maxRetryRequests,
        onProgress: n.onProgress
      });
    });
  }
  /**
   * Returns true if the Azure blob resource represented by this client exists; false otherwise.
   *
   * NOTE: use this function with care since an existing blob might be deleted by other clients or
   * applications. Vice versa new blobs might be added by other clients or applications after this
   * function completes.
   *
   * @param options - options to Exists operation.
   */
  async exists(e = {}) {
    return Te.withSpan("BlobClient-exists", e, async (r) => {
      try {
        return Dt(e.customerProvidedKey, this.isHttps), await this.getProperties({
          abortSignal: e.abortSignal,
          customerProvidedKey: e.customerProvidedKey,
          conditions: e.conditions,
          tracingOptions: r.tracingOptions
        }), !0;
      } catch (n) {
        if (n.statusCode === 404)
          return !1;
        if (n.statusCode === 409 && (n.details.errorCode === CS || n.details.errorCode === BS))
          return !0;
        throw n;
      }
    });
  }
  /**
   * Returns all user-defined metadata, standard HTTP properties, and system properties
   * for the blob. It does not return the content of the blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-properties
   *
   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
   * they originally contained uppercase characters. This differs from the metadata keys returned by
   * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which
   * will retain their original casing.
   *
   * @param options - Optional options to Get Properties operation.
   */
  async getProperties(e = {}) {
    return e.conditions = e.conditions || {}, Dt(e.customerProvidedKey, this.isHttps), Te.withSpan("BlobClient-getProperties", e, async (r) => {
      const n = Ue(await this.blobContext.getProperties({
        abortSignal: e.abortSignal,
        leaseAccessConditions: e.conditions,
        modifiedAccessConditions: {
          ...e.conditions,
          ifTags: e.conditions?.tagConditions
        },
        cpkInfo: e.customerProvidedKey,
        tracingOptions: r.tracingOptions
      }));
      return {
        ...n,
        _response: n._response,
        // _response is made non-enumerable
        objectReplicationDestinationPolicyId: n.objectReplicationPolicyId,
        objectReplicationSourceProperties: Qg(n.objectReplicationRules)
      };
    });
  }
  /**
   * Marks the specified blob or snapshot for deletion. The blob is later deleted
   * during garbage collection. Note that in order to delete a blob, you must delete
   * all of its snapshots. You can delete both at the same time with the Delete
   * Blob operation.
   * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
   *
   * @param options - Optional options to Blob Delete operation.
   */
  async delete(e = {}) {
    return e.conditions = e.conditions || {}, Te.withSpan("BlobClient-delete", e, async (r) => Ue(await this.blobContext.delete({
      abortSignal: e.abortSignal,
      deleteSnapshots: e.deleteSnapshots,
      leaseAccessConditions: e.conditions,
      modifiedAccessConditions: {
        ...e.conditions,
        ifTags: e.conditions?.tagConditions
      },
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted
   * during garbage collection. Note that in order to delete a blob, you must delete
   * all of its snapshots. You can delete both at the same time with the Delete
   * Blob operation.
   * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
   *
   * @param options - Optional options to Blob Delete operation.
   */
  async deleteIfExists(e = {}) {
    return Te.withSpan("BlobClient-deleteIfExists", e, async (r) => {
      try {
        const n = Ue(await this.delete(r));
        return {
          succeeded: !0,
          ...n,
          _response: n._response
          // _response is made non-enumerable
        };
      } catch (n) {
        if (n.details?.errorCode === "BlobNotFound")
          return {
            succeeded: !1,
            ...n.response?.parsedHeaders,
            _response: n.response
          };
        throw n;
      }
    });
  }
  /**
   * Restores the contents and metadata of soft deleted blob and any associated
   * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29
   * or later.
   * @see https://learn.microsoft.com/rest/api/storageservices/undelete-blob
   *
   * @param options - Optional options to Blob Undelete operation.
   */
  async undelete(e = {}) {
    return Te.withSpan("BlobClient-undelete", e, async (r) => Ue(await this.blobContext.undelete({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Sets system properties on the blob.
   *
   * If no value provided, or no value provided for the specified blob HTTP headers,
   * these blob HTTP headers without a value will be cleared.
   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
   *
   * @param blobHTTPHeaders - If no value provided, or no value provided for
   *                                                   the specified blob HTTP headers, these blob HTTP
   *                                                   headers without a value will be cleared.
   *                                                   A common header to set is `blobContentType`
   *                                                   enabling the browser to provide functionality
   *                                                   based on file type.
   * @param options - Optional options to Blob Set HTTP Headers operation.
   */
  async setHTTPHeaders(e, r = {}) {
    return r.conditions = r.conditions || {}, Dt(r.customerProvidedKey, this.isHttps), Te.withSpan("BlobClient-setHTTPHeaders", r, async (n) => Ue(await this.blobContext.setHttpHeaders({
      abortSignal: r.abortSignal,
      blobHttpHeaders: e,
      leaseAccessConditions: r.conditions,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      // cpkInfo: options.customerProvidedKey, // CPK is not included in Swagger, should change this back when this issue is fixed in Swagger.
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Sets user-defined metadata for the specified blob as one or more name-value pairs.
   *
   * If no option provided, or no metadata defined in the parameter, the blob
   * metadata will be removed.
   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-metadata
   *
   * @param metadata - Replace existing metadata with this value.
   *                               If no value provided the existing metadata will be removed.
   * @param options - Optional options to Set Metadata operation.
   */
  async setMetadata(e, r = {}) {
    return r.conditions = r.conditions || {}, Dt(r.customerProvidedKey, this.isHttps), Te.withSpan("BlobClient-setMetadata", r, async (n) => Ue(await this.blobContext.setMetadata({
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      metadata: e,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      cpkInfo: r.customerProvidedKey,
      encryptionScope: r.encryptionScope,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Sets tags on the underlying blob.
   * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.
   * Valid tag key and value characters include lower and upper case letters, digits (0-9),
   * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').
   *
   * @param tags -
   * @param options -
   */
  async setTags(e, r = {}) {
    return Te.withSpan("BlobClient-setTags", r, async (n) => Ue(await this.blobContext.setTags({
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      blobModifiedAccessConditions: r.conditions,
      tracingOptions: n.tracingOptions,
      tags: RM(e)
    })));
  }
  /**
   * Gets the tags associated with the underlying blob.
   *
   * @param options -
   */
  async getTags(e = {}) {
    return Te.withSpan("BlobClient-getTags", e, async (r) => {
      const n = Ue(await this.blobContext.getTags({
        abortSignal: e.abortSignal,
        leaseAccessConditions: e.conditions,
        modifiedAccessConditions: {
          ...e.conditions,
          ifTags: e.conditions?.tagConditions
        },
        blobModifiedAccessConditions: e.conditions,
        tracingOptions: r.tracingOptions
      }));
      return {
        ...n,
        _response: n._response,
        // _response is made non-enumerable
        tags: SM({ blobTagSet: n.blobTagSet }) || {}
      };
    });
  }
  /**
   * Get a {@link BlobLeaseClient} that manages leases on the blob.
   *
   * @param proposeLeaseId - Initial proposed lease Id.
   * @returns A new BlobLeaseClient object for managing leases on the blob.
   */
  getBlobLeaseClient(e) {
    return new PM(this, e);
  }
  /**
   * Creates a read-only snapshot of a blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/snapshot-blob
   *
   * @param options - Optional options to the Blob Create Snapshot operation.
   */
  async createSnapshot(e = {}) {
    return e.conditions = e.conditions || {}, Dt(e.customerProvidedKey, this.isHttps), Te.withSpan("BlobClient-createSnapshot", e, async (r) => Ue(await this.blobContext.createSnapshot({
      abortSignal: e.abortSignal,
      leaseAccessConditions: e.conditions,
      metadata: e.metadata,
      modifiedAccessConditions: {
        ...e.conditions,
        ifTags: e.conditions?.tagConditions
      },
      cpkInfo: e.customerProvidedKey,
      encryptionScope: e.encryptionScope,
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Asynchronously copies a blob to a destination within the storage account.
   * This method returns a long running operation poller that allows you to wait
   * indefinitely until the copy is completed.
   * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.
   * Note that the onProgress callback will not be invoked if the operation completes in the first
   * request, and attempting to cancel a completed copy will result in an error being thrown.
   *
   * In version 2012-02-12 and later, the source for a Copy Blob operation can be
   * a committed blob in any Azure storage account.
   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
   * an Azure file in any Azure storage account.
   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
   * operation to copy from another storage account.
   * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob
   *
   * ```ts snippet:ClientsBeginCopyFromURL
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   * const blobClient = containerClient.getBlobClient(blobName);
   *
   * // Example using automatic polling
   * const automaticCopyPoller = await blobClient.beginCopyFromURL("url");
   * const automaticResult = await automaticCopyPoller.pollUntilDone();
   *
   * // Example using manual polling
   * const manualCopyPoller = await blobClient.beginCopyFromURL("url");
   * while (!manualCopyPoller.isDone()) {
   *   await manualCopyPoller.poll();
   * }
   * const manualResult = manualCopyPoller.getResult();
   *
   * // Example using progress updates
   * const progressUpdatesCopyPoller = await blobClient.beginCopyFromURL("url", {
   *   onProgress(state) {
   *     console.log(`Progress: ${state.copyProgress}`);
   *   },
   * });
   * const progressUpdatesResult = await progressUpdatesCopyPoller.pollUntilDone();
   *
   * // Example using a changing polling interval (default 15 seconds)
   * const pollingIntervalCopyPoller = await blobClient.beginCopyFromURL("url", {
   *   intervalInMs: 1000, // poll blob every 1 second for copy progress
   * });
   * const pollingIntervalResult = await pollingIntervalCopyPoller.pollUntilDone();
   *
   * // Example using copy cancellation:
   * const cancelCopyPoller = await blobClient.beginCopyFromURL("url");
   * // cancel operation after starting it.
   * try {
   *   await cancelCopyPoller.cancelOperation();
   *   // calls to get the result now throw PollerCancelledError
   *   cancelCopyPoller.getResult();
   * } catch (err: any) {
   *   if (err.name === "PollerCancelledError") {
   *     console.log("The copy was cancelled.");
   *   }
   * }
   * ```
   *
   * @param copySource - url to the source Azure Blob/File.
   * @param options - Optional options to the Blob Start Copy From URL operation.
   */
  async beginCopyFromURL(e, r = {}) {
    const n = {
      abortCopyFromURL: (...i) => this.abortCopyFromURL(...i),
      getProperties: (...i) => this.getProperties(...i),
      startCopyFromURL: (...i) => this.startCopyFromURL(...i)
    }, s = new eT({
      blobClient: n,
      copySource: e,
      intervalInMs: r.intervalInMs,
      onProgress: r.onProgress,
      resumeFrom: r.resumeFrom,
      startCopyFromURLOptions: r
    });
    return await s.poll(), s;
  }
  /**
   * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero
   * length and full metadata. Version 2012-02-12 and newer.
   * @see https://learn.microsoft.com/rest/api/storageservices/abort-copy-blob
   *
   * @param copyId - Id of the Copy From URL operation.
   * @param options - Optional options to the Blob Abort Copy From URL operation.
   */
  async abortCopyFromURL(e, r = {}) {
    return Te.withSpan("BlobClient-abortCopyFromURL", r, async (n) => Ue(await this.blobContext.abortCopyFromURL(e, {
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not
   * return a response until the copy is complete.
   * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob-from-url
   *
   * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication
   * @param options -
   */
  async syncCopyFromURL(e, r = {}) {
    return r.conditions = r.conditions || {}, r.sourceConditions = r.sourceConditions || {}, Te.withSpan("BlobClient-syncCopyFromURL", r, async (n) => Ue(await this.blobContext.copyFromURL(e, {
      abortSignal: r.abortSignal,
      metadata: r.metadata,
      leaseAccessConditions: r.conditions,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      sourceModifiedAccessConditions: {
        sourceIfMatch: r.sourceConditions?.ifMatch,
        sourceIfModifiedSince: r.sourceConditions?.ifModifiedSince,
        sourceIfNoneMatch: r.sourceConditions?.ifNoneMatch,
        sourceIfUnmodifiedSince: r.sourceConditions?.ifUnmodifiedSince
      },
      sourceContentMD5: r.sourceContentMD5,
      copySourceAuthorization: Ys(r.sourceAuthorization),
      tier: Nn(r.tier),
      blobTagsString: Qn(r.tags),
      immutabilityPolicyExpiry: r.immutabilityPolicy?.expiriesOn,
      immutabilityPolicyMode: r.immutabilityPolicy?.policyMode,
      legalHold: r.legalHold,
      encryptionScope: r.encryptionScope,
      copySourceTags: r.copySourceTags,
      fileRequestIntent: r.sourceShareTokenIntent,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Sets the tier on a blob. The operation is allowed on a page blob in a premium
   * storage account and on a block blob in a blob storage account (locally redundant
   * storage only). A premium page blob's tier determines the allowed size, IOPS,
   * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive
   * storage type. This operation does not update the blob's ETag.
   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-tier
   *
   * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.
   * @param options - Optional options to the Blob Set Tier operation.
   */
  async setAccessTier(e, r = {}) {
    return Te.withSpan("BlobClient-setAccessTier", r, async (n) => Ue(await this.blobContext.setTier(Nn(e), {
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      rehydratePriority: r.rehydratePriority,
      tracingOptions: n.tracingOptions
    })));
  }
  async downloadToBuffer(e, r, n, s = {}) {
    let i, o = 0, a = 0, A = s;
    e instanceof Buffer ? (i = e, o = r || 0, a = typeof n == "number" ? n : 0) : (o = typeof e == "number" ? e : 0, a = typeof r == "number" ? r : 0, A = n || {});
    let c = A.blockSize ?? 0;
    if (c < 0)
      throw new RangeError("blockSize option must be >= 0");
    if (c === 0 && (c = jc), o < 0)
      throw new RangeError("offset option must be >= 0");
    if (a && a <= 0)
      throw new RangeError("count option must be greater than 0");
    return A.conditions || (A.conditions = {}), Te.withSpan("BlobClient-downloadToBuffer", A, async (l) => {
      if (!a) {
        const m = await this.getProperties({
          ...A,
          tracingOptions: l.tracingOptions
        });
        if (a = m.contentLength - o, a < 0)
          throw new RangeError(`offset ${o} shouldn't be larger than blob size ${m.contentLength}`);
      }
      if (!i)
        try {
          i = Buffer.alloc(a);
        } catch (m) {
          throw new Error(`Unable to allocate the buffer of size: ${a}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ${m.message}`);
        }
      if (i.length < a)
        throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${a}`);
      let d = 0;
      const u = new pI(A.concurrency);
      for (let m = o; m < o + a; m = m + c)
        u.addOperation(async () => {
          let h = o + a;
          m + c < h && (h = m + c);
          const p = (await this.download(m, h - m, {
            abortSignal: A.abortSignal,
            conditions: A.conditions,
            maxRetryRequests: A.maxRetryRequestsPerBlock,
            customerProvidedKey: A.customerProvidedKey,
            tracingOptions: l.tracingOptions
          })).readableStreamBody;
          await sT(p, i, m - o, h - o), d += h - m, A.onProgress && A.onProgress({ loadedBytes: d });
        });
      return await u.do(), i;
    });
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Downloads an Azure Blob to a local file.
   * Fails if the the given file path already exits.
   * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
   *
   * @param filePath -
   * @param offset - From which position of the block blob to download.
   * @param count - How much data to be downloaded. Will download to the end when passing undefined.
   * @param options - Options to Blob download options.
   * @returns The response data for blob download operation,
   *                                                 but with readableStreamBody set to undefined since its
   *                                                 content is already read and written into a local file
   *                                                 at the specified path.
   */
  async downloadToFile(e, r = 0, n, s = {}) {
    return Te.withSpan("BlobClient-downloadToFile", s, async (i) => {
      const o = await this.download(r, n, {
        ...s,
        tracingOptions: i.tracingOptions
      });
      return o.readableStreamBody && await iT(o.readableStreamBody, e), o.blobDownloadStream = void 0, o;
    });
  }
  getBlobAndContainerNamesFromUrl() {
    let e, r;
    try {
      const n = new URL(this.url);
      if (n.host.split(".")[1] === "blob") {
        const s = n.pathname.match("/([^/]*)(/(.*))?");
        e = s[1], r = s[3];
      } else if (fI(n)) {
        const s = n.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
        e = s[2], r = s[4];
      } else {
        const s = n.pathname.match("/([^/]*)(/(.*))?");
        e = s[1], r = s[3];
      }
      if (e = decodeURIComponent(e), r = decodeURIComponent(r), r = r.replace(/\\/g, "/"), !e)
        throw new Error("Provided containerName is invalid.");
      return { blobName: r, containerName: e };
    } catch {
      throw new Error("Unable to extract blobName and containerName with provided information.");
    }
  }
  /**
   * Asynchronously copies a blob to a destination within the storage account.
   * In version 2012-02-12 and later, the source for a Copy Blob operation can be
   * a committed blob in any Azure storage account.
   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
   * an Azure file in any Azure storage account.
   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
   * operation to copy from another storage account.
   * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob
   *
   * @param copySource - url to the source Azure Blob/File.
   * @param options - Optional options to the Blob Start Copy From URL operation.
   */
  async startCopyFromURL(e, r = {}) {
    return Te.withSpan("BlobClient-startCopyFromURL", r, async (n) => (r.conditions = r.conditions || {}, r.sourceConditions = r.sourceConditions || {}, Ue(await this.blobContext.startCopyFromURL(e, {
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      metadata: r.metadata,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      sourceModifiedAccessConditions: {
        sourceIfMatch: r.sourceConditions.ifMatch,
        sourceIfModifiedSince: r.sourceConditions.ifModifiedSince,
        sourceIfNoneMatch: r.sourceConditions.ifNoneMatch,
        sourceIfUnmodifiedSince: r.sourceConditions.ifUnmodifiedSince,
        sourceIfTags: r.sourceConditions.tagConditions
      },
      immutabilityPolicyExpiry: r.immutabilityPolicy?.expiriesOn,
      immutabilityPolicyMode: r.immutabilityPolicy?.policyMode,
      legalHold: r.legalHold,
      rehydratePriority: r.rehydratePriority,
      tier: Nn(r.tier),
      blobTagsString: Qn(r.tags),
      sealBlob: r.sealBlob,
      tracingOptions: n.tracingOptions
    }))));
  }
  /**
   * Only available for BlobClient constructed with a shared key credential.
   *
   * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties
   * and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateSasUrl(e) {
    return new Promise((r) => {
      if (!(this.credential instanceof sr))
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      const n = bg({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...e
      }, this.credential).toString();
      r(Bg(this.url, n));
    });
  }
  /**
   * Only available for BlobClient constructed with a shared key credential.
   *
   * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
   * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/
  generateSasStringToSign(e) {
    if (!(this.credential instanceof sr))
      throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
    return nl({
      containerName: this._containerName,
      blobName: this._name,
      snapshotTime: this._snapshot,
      versionId: this._versionId,
      ...e
    }, this.credential).stringToSign;
  }
  /**
   *
   * Generates a Blob Service Shared Access Signature (SAS) URI based on
   * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateUserDelegationSasUrl(e, r) {
    return new Promise((n) => {
      const s = bg({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...e
      }, r, this.accountName).toString();
      n(Bg(this.url, s));
    });
  }
  /**
   * Only available for BlobClient constructed with a shared key credential.
   *
   * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
   * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateUserDelegationSasStringToSign(e, r) {
    return nl({
      containerName: this._containerName,
      blobName: this._name,
      snapshotTime: this._snapshot,
      versionId: this._versionId,
      ...e
    }, r, this.accountName).stringToSign;
  }
  /**
   * Delete the immutablility policy on the blob.
   *
   * @param options - Optional options to delete immutability policy on the blob.
   */
  async deleteImmutabilityPolicy(e = {}) {
    return Te.withSpan("BlobClient-deleteImmutabilityPolicy", e, async (r) => Ue(await this.blobContext.deleteImmutabilityPolicy({
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Set immutability policy on the blob.
   *
   * @param options - Optional options to set immutability policy on the blob.
   */
  async setImmutabilityPolicy(e, r = {}) {
    return Te.withSpan("BlobClient-setImmutabilityPolicy", r, async (n) => Ue(await this.blobContext.setImmutabilityPolicy({
      immutabilityPolicyExpiry: e.expiriesOn,
      immutabilityPolicyMode: e.policyMode,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Set legal hold on the blob.
   *
   * @param options - Optional options to set legal hold on the blob.
   */
  async setLegalHold(e, r = {}) {
    return Te.withSpan("BlobClient-setLegalHold", r, async (n) => Ue(await this.blobContext.setLegalHold(e, {
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * The Get Account Information operation returns the sku name and account kind
   * for the specified account.
   * The Get Account Information operation is available on service versions beginning
   * with version 2018-03-28.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
   *
   * @param options - Options to the Service Get Account Info operation.
   * @returns Response data for the Service Get Account Info operation.
   */
  async getAccountInfo(e = {}) {
    return Te.withSpan("BlobClient-getAccountInfo", e, async (r) => Ue(await this.blobContext.getAccountInfo({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
}
class dd extends wn {
  /**
   * appendBlobsContext provided by protocol layer.
   */
  appendBlobContext;
  constructor(e, r, n, s) {
    let i, o;
    if (s = s || {}, wo(r))
      o = e, i = r;
    else if (Rt && r instanceof sr || r instanceof Vt || kn(r))
      o = e, s = n, i = Pt(r, s);
    else if (!r && typeof r != "string")
      o = e, i = Pt(new Vt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const a = r, A = n, c = Mo(e);
      if (c.kind === "AccountConnString")
        if (Rt) {
          const l = new sr(c.accountName, c.accountKey);
          o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)), s.proxyOptions || (s.proxyOptions = Bo(c.proxyUri)), i = Pt(l, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (c.kind === "SASConnString")
        o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)) + "?" + c.accountSas, i = Pt(new Vt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), this.appendBlobContext = this.storageClientContext.appendBlob;
  }
  /**
   * Creates a new AppendBlobClient object identical to the source but with the
   * specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a Client to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.
   */
  withSnapshot(e) {
    return new dd(Gs(this.url, Cn.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param options - Options to the Append Block Create operation.
   *
   *
   * Example usage:
   *
   * ```ts snippet:ClientsCreateAppendBlob
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   *
   * const appendBlobClient = containerClient.getAppendBlobClient(blobName);
   * await appendBlobClient.create();
   * ```
   */
  async create(e = {}) {
    return e.conditions = e.conditions || {}, Dt(e.customerProvidedKey, this.isHttps), Te.withSpan("AppendBlobClient-create", e, async (r) => Ue(await this.appendBlobContext.create(0, {
      abortSignal: e.abortSignal,
      blobHttpHeaders: e.blobHTTPHeaders,
      leaseAccessConditions: e.conditions,
      metadata: e.metadata,
      modifiedAccessConditions: {
        ...e.conditions,
        ifTags: e.conditions?.tagConditions
      },
      cpkInfo: e.customerProvidedKey,
      encryptionScope: e.encryptionScope,
      immutabilityPolicyExpiry: e.immutabilityPolicy?.expiriesOn,
      immutabilityPolicyMode: e.immutabilityPolicy?.policyMode,
      legalHold: e.legalHold,
      blobTagsString: Qn(e.tags),
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
   * If the blob with the same name already exists, the content of the existing blob will remain unchanged.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param options -
   */
  async createIfNotExists(e = {}) {
    const r = { ifNoneMatch: Yp };
    return Te.withSpan("AppendBlobClient-createIfNotExists", e, async (n) => {
      try {
        const s = Ue(await this.create({
          ...n,
          conditions: r
        }));
        return {
          succeeded: !0,
          ...s,
          _response: s._response
          // _response is made non-enumerable
        };
      } catch (s) {
        if (s.details?.errorCode === "BlobAlreadyExists")
          return {
            succeeded: !1,
            ...s.response?.parsedHeaders,
            _response: s.response
          };
        throw s;
      }
    });
  }
  /**
   * Seals the append blob, making it read only.
   *
   * @param options -
   */
  async seal(e = {}) {
    return e.conditions = e.conditions || {}, Te.withSpan("AppendBlobClient-seal", e, async (r) => Ue(await this.appendBlobContext.seal({
      abortSignal: e.abortSignal,
      appendPositionAccessConditions: e.conditions,
      leaseAccessConditions: e.conditions,
      modifiedAccessConditions: {
        ...e.conditions,
        ifTags: e.conditions?.tagConditions
      },
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Commits a new block of data to the end of the existing append blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/append-block
   *
   * @param body - Data to be appended.
   * @param contentLength - Length of the body in bytes.
   * @param options - Options to the Append Block operation.
   *
   *
   * Example usage:
   *
   * ```ts snippet:ClientsAppendBlock
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   *
   * const content = "Hello World!";
   *
   * // Create a new append blob and append data to the blob.
   * const newAppendBlobClient = containerClient.getAppendBlobClient(blobName);
   * await newAppendBlobClient.create();
   * await newAppendBlobClient.appendBlock(content, content.length);
   *
   * // Append data to an existing append blob.
   * const existingAppendBlobClient = containerClient.getAppendBlobClient(blobName);
   * await existingAppendBlobClient.appendBlock(content, content.length);
   * ```
   */
  async appendBlock(e, r, n = {}) {
    return n.conditions = n.conditions || {}, Dt(n.customerProvidedKey, this.isHttps), Te.withSpan("AppendBlobClient-appendBlock", n, async (s) => Ue(await this.appendBlobContext.appendBlock(r, e, {
      abortSignal: n.abortSignal,
      appendPositionAccessConditions: n.conditions,
      leaseAccessConditions: n.conditions,
      modifiedAccessConditions: {
        ...n.conditions,
        ifTags: n.conditions?.tagConditions
      },
      requestOptions: {
        onUploadProgress: n.onProgress
      },
      transactionalContentMD5: n.transactionalContentMD5,
      transactionalContentCrc64: n.transactionalContentCrc64,
      cpkInfo: n.customerProvidedKey,
      encryptionScope: n.encryptionScope,
      tracingOptions: s.tracingOptions
    })));
  }
  /**
   * The Append Block operation commits a new block of data to the end of an existing append blob
   * where the contents are read from a source url.
   * @see https://learn.microsoft.com/rest/api/storageservices/append-block-from-url
   *
   * @param sourceURL -
   *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can
   *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob
   *                 must either be public or must be authenticated via a shared access signature. If the source blob is
   *                 public, no authentication is required to perform the operation.
   * @param sourceOffset - Offset in source to be appended
   * @param count - Number of bytes to be appended as a block
   * @param options -
   */
  async appendBlockFromURL(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, s.sourceConditions = s.sourceConditions || {}, Dt(s.customerProvidedKey, this.isHttps), Te.withSpan("AppendBlobClient-appendBlockFromURL", s, async (i) => Ue(await this.appendBlobContext.appendBlockFromUrl(e, 0, {
      abortSignal: s.abortSignal,
      sourceRange: nr({ offset: r, count: n }),
      sourceContentMD5: s.sourceContentMD5,
      sourceContentCrc64: s.sourceContentCrc64,
      leaseAccessConditions: s.conditions,
      appendPositionAccessConditions: s.conditions,
      modifiedAccessConditions: {
        ...s.conditions,
        ifTags: s.conditions?.tagConditions
      },
      sourceModifiedAccessConditions: {
        sourceIfMatch: s.sourceConditions?.ifMatch,
        sourceIfModifiedSince: s.sourceConditions?.ifModifiedSince,
        sourceIfNoneMatch: s.sourceConditions?.ifNoneMatch,
        sourceIfUnmodifiedSince: s.sourceConditions?.ifUnmodifiedSince
      },
      copySourceAuthorization: Ys(s.sourceAuthorization),
      cpkInfo: s.customerProvidedKey,
      encryptionScope: s.encryptionScope,
      fileRequestIntent: s.sourceShareTokenIntent,
      tracingOptions: i.tracingOptions
    })));
  }
}
class To extends wn {
  /**
   * blobContext provided by protocol layer.
   *
   * Note. Ideally BlobClient should set BlobClient.blobContext to protected. However, API
   * extractor has issue blocking that. Here we redecelare _blobContext in BlockBlobClient.
   */
  _blobContext;
  /**
   * blockBlobContext provided by protocol layer.
   */
  blockBlobContext;
  constructor(e, r, n, s) {
    let i, o;
    if (s = s || {}, wo(r))
      o = e, i = r;
    else if (Rt && r instanceof sr || r instanceof Vt || kn(r))
      o = e, s = n, i = Pt(r, s);
    else if (!r && typeof r != "string")
      o = e, n && typeof n != "string" && (s = n), i = Pt(new Vt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const a = r, A = n, c = Mo(e);
      if (c.kind === "AccountConnString")
        if (Rt) {
          const l = new sr(c.accountName, c.accountKey);
          o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)), s.proxyOptions || (s.proxyOptions = Bo(c.proxyUri)), i = Pt(l, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (c.kind === "SASConnString")
        o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)) + "?" + c.accountSas, i = Pt(new Vt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), this.blockBlobContext = this.storageClientContext.blockBlob, this._blobContext = this.storageClientContext.blob;
  }
  /**
   * Creates a new BlockBlobClient object identical to the source but with the
   * specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a URL to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.
   */
  withSnapshot(e) {
    return new To(Gs(this.url, Cn.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Quick query for a JSON or CSV formatted blob.
   *
   * Example usage (Node.js):
   *
   * ```ts snippet:ClientsQuery
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
   *
   * // Query and convert a blob to a string
   * const queryBlockBlobResponse = await blockBlobClient.query("select from BlobStorage");
   * if (queryBlockBlobResponse.readableStreamBody) {
   *   const downloadedBuffer = await streamToBuffer(queryBlockBlobResponse.readableStreamBody);
   *   const downloaded = downloadedBuffer.toString();
   *   console.log(`Query blob content: ${downloaded}`);
   * }
   *
   * async function streamToBuffer(readableStream: NodeJS.ReadableStream): Promise<Buffer> {
   *   return new Promise((resolve, reject) => {
   *     const chunks: Buffer[] = [];
   *     readableStream.on("data", (data) => {
   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
   *     });
   *     readableStream.on("end", () => {
   *       resolve(Buffer.concat(chunks));
   *     });
   *     readableStream.on("error", reject);
   *   });
   * }
   * ```
   *
   * @param query -
   * @param options -
   */
  async query(e, r = {}) {
    if (Dt(r.customerProvidedKey, this.isHttps), !Rt)
      throw new Error("This operation currently is only supported in Node.js.");
    return Te.withSpan("BlockBlobClient-query", r, async (n) => {
      const s = Ue(await this._blobContext.query({
        abortSignal: r.abortSignal,
        queryRequest: {
          queryType: "SQL",
          expression: e,
          inputSerialization: yg(r.inputTextConfiguration),
          outputSerialization: yg(r.outputTextConfiguration)
        },
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: {
          ...r.conditions,
          ifTags: r.conditions?.tagConditions
        },
        cpkInfo: r.customerProvidedKey,
        tracingOptions: n.tracingOptions
      }));
      return new KM(s, {
        abortSignal: r.abortSignal,
        onProgress: r.onProgress,
        onError: r.onError
      });
    });
  }
  /**
   * Creates a new block blob, or updates the content of an existing block blob.
   * Updating an existing block blob overwrites any existing metadata on the blob.
   * Partial updates are not supported; the content of the existing blob is
   * overwritten with the new content. To perform a partial update of a block blob's,
   * use {@link stageBlock} and {@link commitBlockList}.
   *
   * This is a non-parallel uploading method, please use {@link uploadFile},
   * {@link uploadStream} or {@link uploadBrowserData} for better performance
   * with concurrency uploading.
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
   *                               which returns a new Readable stream whose offset is from data source beginning.
   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
   *                               string including non non-Base64/Hex-encoded characters.
   * @param options - Options to the Block Blob Upload operation.
   * @returns Response data for the Block Blob Upload operation.
   *
   * Example usage:
   *
   * ```ts snippet:ClientsUpload
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
   *
   * const content = "Hello world!";
   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
   * ```
   */
  async upload(e, r, n = {}) {
    return n.conditions = n.conditions || {}, Dt(n.customerProvidedKey, this.isHttps), Te.withSpan("BlockBlobClient-upload", n, async (s) => Ue(await this.blockBlobContext.upload(r, e, {
      abortSignal: n.abortSignal,
      blobHttpHeaders: n.blobHTTPHeaders,
      leaseAccessConditions: n.conditions,
      metadata: n.metadata,
      modifiedAccessConditions: {
        ...n.conditions,
        ifTags: n.conditions?.tagConditions
      },
      requestOptions: {
        onUploadProgress: n.onProgress
      },
      cpkInfo: n.customerProvidedKey,
      encryptionScope: n.encryptionScope,
      immutabilityPolicyExpiry: n.immutabilityPolicy?.expiriesOn,
      immutabilityPolicyMode: n.immutabilityPolicy?.policyMode,
      legalHold: n.legalHold,
      tier: Nn(n.tier),
      blobTagsString: Qn(n.tags),
      tracingOptions: s.tracingOptions
    })));
  }
  /**
   * Creates a new Block Blob where the contents of the blob are read from a given URL.
   * This API is supported beginning with the 2020-04-08 version. Partial updates
   * are not supported with Put Blob from URL; the content of an existing blob is overwritten with
   * the content of the new blob.  To perform partial updates to a block blobs contents using a
   * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.
   *
   * @param sourceURL - Specifies the URL of the blob. The value
   *                           may be a URL of up to 2 KB in length that specifies a blob.
   *                           The value should be URL-encoded as it would appear
   *                           in a request URI. The source blob must either be public
   *                           or must be authenticated via a shared access signature.
   *                           If the source blob is public, no authentication is required
   *                           to perform the operation. Here are some examples of source object URLs:
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
   * @param options - Optional parameters.
   */
  async syncUploadFromURL(e, r = {}) {
    return r.conditions = r.conditions || {}, Dt(r.customerProvidedKey, this.isHttps), Te.withSpan("BlockBlobClient-syncUploadFromURL", r, async (n) => Ue(await this.blockBlobContext.putBlobFromUrl(0, e, {
      ...r,
      blobHttpHeaders: r.blobHTTPHeaders,
      leaseAccessConditions: r.conditions,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      sourceModifiedAccessConditions: {
        sourceIfMatch: r.sourceConditions?.ifMatch,
        sourceIfModifiedSince: r.sourceConditions?.ifModifiedSince,
        sourceIfNoneMatch: r.sourceConditions?.ifNoneMatch,
        sourceIfUnmodifiedSince: r.sourceConditions?.ifUnmodifiedSince,
        sourceIfTags: r.sourceConditions?.tagConditions
      },
      cpkInfo: r.customerProvidedKey,
      copySourceAuthorization: Ys(r.sourceAuthorization),
      tier: Nn(r.tier),
      blobTagsString: Qn(r.tags),
      copySourceTags: r.copySourceTags,
      fileRequestIntent: r.sourceShareTokenIntent,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Uploads the specified block to the block blob's "staging area" to be later
   * committed by a call to commitBlockList.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-block
   *
   * @param blockId - A 64-byte value that is base64-encoded
   * @param body - Data to upload to the staging area.
   * @param contentLength - Number of bytes to upload.
   * @param options - Options to the Block Blob Stage Block operation.
   * @returns Response data for the Block Blob Stage Block operation.
   */
  async stageBlock(e, r, n, s = {}) {
    return Dt(s.customerProvidedKey, this.isHttps), Te.withSpan("BlockBlobClient-stageBlock", s, async (i) => Ue(await this.blockBlobContext.stageBlock(e, n, r, {
      abortSignal: s.abortSignal,
      leaseAccessConditions: s.conditions,
      requestOptions: {
        onUploadProgress: s.onProgress
      },
      transactionalContentMD5: s.transactionalContentMD5,
      transactionalContentCrc64: s.transactionalContentCrc64,
      cpkInfo: s.customerProvidedKey,
      encryptionScope: s.encryptionScope,
      tracingOptions: i.tracingOptions
    })));
  }
  /**
   * The Stage Block From URL operation creates a new block to be committed as part
   * of a blob where the contents are read from a URL.
   * This API is available starting in version 2018-03-28.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-block-from-url
   *
   * @param blockId - A 64-byte value that is base64-encoded
   * @param sourceURL - Specifies the URL of the blob. The value
   *                           may be a URL of up to 2 KB in length that specifies a blob.
   *                           The value should be URL-encoded as it would appear
   *                           in a request URI. The source blob must either be public
   *                           or must be authenticated via a shared access signature.
   *                           If the source blob is public, no authentication is required
   *                           to perform the operation. Here are some examples of source object URLs:
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
   * @param offset - From which position of the blob to download, greater than or equal to 0
   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
   * @param options - Options to the Block Blob Stage Block From URL operation.
   * @returns Response data for the Block Blob Stage Block From URL operation.
   */
  async stageBlockFromURL(e, r, n = 0, s, i = {}) {
    return Dt(i.customerProvidedKey, this.isHttps), Te.withSpan("BlockBlobClient-stageBlockFromURL", i, async (o) => Ue(await this.blockBlobContext.stageBlockFromURL(e, 0, r, {
      abortSignal: i.abortSignal,
      leaseAccessConditions: i.conditions,
      sourceContentMD5: i.sourceContentMD5,
      sourceContentCrc64: i.sourceContentCrc64,
      sourceRange: n === 0 && !s ? void 0 : nr({ offset: n, count: s }),
      cpkInfo: i.customerProvidedKey,
      encryptionScope: i.encryptionScope,
      copySourceAuthorization: Ys(i.sourceAuthorization),
      fileRequestIntent: i.sourceShareTokenIntent,
      tracingOptions: o.tracingOptions
    })));
  }
  /**
   * Writes a blob by specifying the list of block IDs that make up the blob.
   * In order to be written as part of a blob, a block must have been successfully written
   * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to
   * update a blob by uploading only those blocks that have changed, then committing the new and existing
   * blocks together. Any blocks not specified in the block list and permanently deleted.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-block-list
   *
   * @param blocks -  Array of 64-byte value that is base64-encoded
   * @param options - Options to the Block Blob Commit Block List operation.
   * @returns Response data for the Block Blob Commit Block List operation.
   */
  async commitBlockList(e, r = {}) {
    return r.conditions = r.conditions || {}, Dt(r.customerProvidedKey, this.isHttps), Te.withSpan("BlockBlobClient-commitBlockList", r, async (n) => Ue(await this.blockBlobContext.commitBlockList({ latest: e }, {
      abortSignal: r.abortSignal,
      blobHttpHeaders: r.blobHTTPHeaders,
      leaseAccessConditions: r.conditions,
      metadata: r.metadata,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      cpkInfo: r.customerProvidedKey,
      encryptionScope: r.encryptionScope,
      immutabilityPolicyExpiry: r.immutabilityPolicy?.expiriesOn,
      immutabilityPolicyMode: r.immutabilityPolicy?.policyMode,
      legalHold: r.legalHold,
      tier: Nn(r.tier),
      blobTagsString: Qn(r.tags),
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Returns the list of blocks that have been uploaded as part of a block blob
   * using the specified block list filter.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-block-list
   *
   * @param listType - Specifies whether to return the list of committed blocks,
   *                                        the list of uncommitted blocks, or both lists together.
   * @param options - Options to the Block Blob Get Block List operation.
   * @returns Response data for the Block Blob Get Block List operation.
   */
  async getBlockList(e, r = {}) {
    return Te.withSpan("BlockBlobClient-getBlockList", r, async (n) => {
      const s = Ue(await this.blockBlobContext.getBlockList(e, {
        abortSignal: r.abortSignal,
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: {
          ...r.conditions,
          ifTags: r.conditions?.tagConditions
        },
        tracingOptions: n.tracingOptions
      }));
      return s.committedBlocks || (s.committedBlocks = []), s.uncommittedBlocks || (s.uncommittedBlocks = []), s;
    });
  }
  // High level functions
  /**
   * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.
   *
   * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
   * to commit the block list.
   *
   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
   * `blobContentType`, enabling the browser to provide
   * functionality based on file type.
   *
   * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView
   * @param options -
   */
  async uploadData(e, r = {}) {
    return Te.withSpan("BlockBlobClient-uploadData", r, async (n) => {
      if (Rt) {
        let s;
        return e instanceof Buffer ? s = e : e instanceof ArrayBuffer ? s = Buffer.from(e) : (e = e, s = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), this.uploadSeekableInternal((i, o) => s.slice(i, i + o), s.byteLength, n);
      } else {
        const s = new Blob([e]);
        return this.uploadSeekableInternal((i, o) => s.slice(i, i + o), s.size, n);
      }
    });
  }
  /**
   * ONLY AVAILABLE IN BROWSERS.
   *
   * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.
   *
   * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call
   * {@link commitBlockList} to commit the block list.
   *
   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
   * `blobContentType`, enabling the browser to provide
   * functionality based on file type.
   *
   * @deprecated Use {@link uploadData} instead.
   *
   * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView
   * @param options - Options to upload browser data.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadBrowserData(e, r = {}) {
    return Te.withSpan("BlockBlobClient-uploadBrowserData", r, async (n) => {
      const s = new Blob([e]);
      return this.uploadSeekableInternal((i, o) => s.slice(i, i + o), s.size, n);
    });
  }
  /**
   *
   * Uploads data to block blob. Requires a bodyFactory as the data source,
   * which need to return a {@link HttpRequestBody} object with the offset and size provided.
   *
   * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
   * to commit the block list.
   *
   * @param bodyFactory -
   * @param size - size of the data to upload.
   * @param options - Options to Upload to Block Blob operation.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadSeekableInternal(e, r, n = {}) {
    let s = n.blockSize ?? 0;
    if (s < 0 || s > Fc)
      throw new RangeError(`blockSize option must be >= 0 and <= ${Fc}`);
    const i = n.maxSingleShotSize ?? Tc;
    if (i < 0 || i > Tc)
      throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${Tc}`);
    if (s === 0) {
      if (r > Fc * xi)
        throw new RangeError(`${r} is too larger to upload to a block blob.`);
      r > i && (s = Math.ceil(r / xi), s < jc && (s = jc));
    }
    return n.blobHTTPHeaders || (n.blobHTTPHeaders = {}), n.conditions || (n.conditions = {}), Te.withSpan("BlockBlobClient-uploadSeekableInternal", n, async (o) => {
      if (r <= i)
        return Ue(await this.upload(e(0, r), r, o));
      const a = Math.floor((r - 1) / s) + 1;
      if (a > xi)
        throw new RangeError(`The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= ${xi}`);
      const A = [], c = $c();
      let l = 0;
      const d = new pI(n.concurrency);
      for (let u = 0; u < a; u++)
        d.addOperation(async () => {
          const m = Ig(c, u), h = s * u, p = (u === a - 1 ? r : h + s) - h;
          A.push(m), await this.stageBlock(m, e(h, p), p, {
            abortSignal: n.abortSignal,
            conditions: n.conditions,
            encryptionScope: n.encryptionScope,
            tracingOptions: o.tracingOptions
          }), l += p, n.onProgress && n.onProgress({
            loadedBytes: l
          });
        });
      return await d.do(), this.commitBlockList(A, o);
    });
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Uploads a local file in blocks to a block blob.
   *
   * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
   * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList
   * to commit the block list.
   *
   * @param filePath - Full path of local file
   * @param options - Options to Upload to Block Blob operation.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadFile(e, r = {}) {
    return Te.withSpan("BlockBlobClient-uploadFile", r, async (n) => {
      const s = (await oT(e)).size;
      return this.uploadSeekableInternal((i, o) => () => aT(e, {
        autoClose: !0,
        end: o ? i + o - 1 : 1 / 0,
        start: i
      }), s, {
        ...r,
        tracingOptions: n.tracingOptions
      });
    });
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Uploads a Node.js Readable stream into block blob.
   *
   * PERFORMANCE IMPROVEMENT TIPS:
   * * Input stream highWaterMark is better to set a same value with bufferSize
   *    parameter, which will avoid Buffer.concat() operations.
   *
   * @param stream - Node.js Readable stream
   * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB
   * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,
   *                                 positive correlation with max uploading concurrency. Default value is 5
   * @param options - Options to Upload Stream to Block Blob operation.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadStream(e, r = dS, n = 5, s = {}) {
    return s.blobHTTPHeaders || (s.blobHTTPHeaders = {}), s.conditions || (s.conditions = {}), Te.withSpan("BlockBlobClient-uploadStream", s, async (i) => {
      let o = 0;
      const a = $c();
      let A = 0;
      const c = [];
      return await new HR(
        e,
        r,
        n,
        async (d, u) => {
          const m = Ig(a, o);
          c.push(m), o++, await this.stageBlock(m, d, u, {
            customerProvidedKey: s.customerProvidedKey,
            conditions: s.conditions,
            encryptionScope: s.encryptionScope,
            tracingOptions: i.tracingOptions
          }), A += u, s.onProgress && s.onProgress({ loadedBytes: A });
        },
        // concurrency should set a smaller value than maxConcurrency, which is helpful to
        // reduce the possibility when a outgoing handler waits for stream data, in
        // this situation, outgoing handlers are blocked.
        // Outgoing queue shouldn't be empty.
        Math.ceil(n / 4 * 3)
      ).do(), Ue(await this.commitBlockList(c, {
        ...s,
        tracingOptions: i.tracingOptions
      }));
    });
  }
}
class ud extends wn {
  /**
   * pageBlobsContext provided by protocol layer.
   */
  pageBlobContext;
  constructor(e, r, n, s) {
    let i, o;
    if (s = s || {}, wo(r))
      o = e, i = r;
    else if (Rt && r instanceof sr || r instanceof Vt || kn(r))
      o = e, s = n, i = Pt(r, s);
    else if (!r && typeof r != "string")
      o = e, i = Pt(new Vt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const a = r, A = n, c = Mo(e);
      if (c.kind === "AccountConnString")
        if (Rt) {
          const l = new sr(c.accountName, c.accountKey);
          o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)), s.proxyOptions || (s.proxyOptions = Bo(c.proxyUri)), i = Pt(l, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (c.kind === "SASConnString")
        o = Ht(Ht(c.url, encodeURIComponent(a)), encodeURIComponent(A)) + "?" + c.accountSas, i = Pt(new Vt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), this.pageBlobContext = this.storageClientContext.pageBlob;
  }
  /**
   * Creates a new PageBlobClient object identical to the source but with the
   * specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a Client to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.
   */
  withSnapshot(e) {
    return new ud(Gs(this.url, Cn.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a page blob of the specified length. Call uploadPages to upload data
   * data to a page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param size - size of the page blob.
   * @param options - Options to the Page Blob Create operation.
   * @returns Response data for the Page Blob Create operation.
   */
  async create(e, r = {}) {
    return r.conditions = r.conditions || {}, Dt(r.customerProvidedKey, this.isHttps), Te.withSpan("PageBlobClient-create", r, async (n) => Ue(await this.pageBlobContext.create(0, e, {
      abortSignal: r.abortSignal,
      blobHttpHeaders: r.blobHTTPHeaders,
      blobSequenceNumber: r.blobSequenceNumber,
      leaseAccessConditions: r.conditions,
      metadata: r.metadata,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      cpkInfo: r.customerProvidedKey,
      encryptionScope: r.encryptionScope,
      immutabilityPolicyExpiry: r.immutabilityPolicy?.expiriesOn,
      immutabilityPolicyMode: r.immutabilityPolicy?.policyMode,
      legalHold: r.legalHold,
      tier: Nn(r.tier),
      blobTagsString: Qn(r.tags),
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Creates a page blob of the specified length. Call uploadPages to upload data
   * data to a page blob. If the blob with the same name already exists, the content
   * of the existing blob will remain unchanged.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param size - size of the page blob.
   * @param options -
   */
  async createIfNotExists(e, r = {}) {
    return Te.withSpan("PageBlobClient-createIfNotExists", r, async (n) => {
      try {
        const s = { ifNoneMatch: Yp }, i = Ue(await this.create(e, {
          ...r,
          conditions: s,
          tracingOptions: n.tracingOptions
        }));
        return {
          succeeded: !0,
          ...i,
          _response: i._response
          // _response is made non-enumerable
        };
      } catch (s) {
        if (s.details?.errorCode === "BlobAlreadyExists")
          return {
            succeeded: !1,
            ...s.response?.parsedHeaders,
            _response: s.response
          };
        throw s;
      }
    });
  }
  /**
   * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-page
   *
   * @param body - Data to upload
   * @param offset - Offset of destination page blob
   * @param count - Content length of the body, also number of bytes to be uploaded
   * @param options - Options to the Page Blob Upload Pages operation.
   * @returns Response data for the Page Blob Upload Pages operation.
   */
  async uploadPages(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, Dt(s.customerProvidedKey, this.isHttps), Te.withSpan("PageBlobClient-uploadPages", s, async (i) => Ue(await this.pageBlobContext.uploadPages(n, e, {
      abortSignal: s.abortSignal,
      leaseAccessConditions: s.conditions,
      modifiedAccessConditions: {
        ...s.conditions,
        ifTags: s.conditions?.tagConditions
      },
      requestOptions: {
        onUploadProgress: s.onProgress
      },
      range: nr({ offset: r, count: n }),
      sequenceNumberAccessConditions: s.conditions,
      transactionalContentMD5: s.transactionalContentMD5,
      transactionalContentCrc64: s.transactionalContentCrc64,
      cpkInfo: s.customerProvidedKey,
      encryptionScope: s.encryptionScope,
      tracingOptions: i.tracingOptions
    })));
  }
  /**
   * The Upload Pages operation writes a range of pages to a page blob where the
   * contents are read from a URL.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-page-from-url
   *
   * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication
   * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob
   * @param destOffset - Offset of destination page blob
   * @param count - Number of bytes to be uploaded from source page blob
   * @param options -
   */
  async uploadPagesFromURL(e, r, n, s, i = {}) {
    return i.conditions = i.conditions || {}, i.sourceConditions = i.sourceConditions || {}, Dt(i.customerProvidedKey, this.isHttps), Te.withSpan("PageBlobClient-uploadPagesFromURL", i, async (o) => Ue(await this.pageBlobContext.uploadPagesFromURL(e, nr({ offset: r, count: s }), 0, nr({ offset: n, count: s }), {
      abortSignal: i.abortSignal,
      sourceContentMD5: i.sourceContentMD5,
      sourceContentCrc64: i.sourceContentCrc64,
      leaseAccessConditions: i.conditions,
      sequenceNumberAccessConditions: i.conditions,
      modifiedAccessConditions: {
        ...i.conditions,
        ifTags: i.conditions?.tagConditions
      },
      sourceModifiedAccessConditions: {
        sourceIfMatch: i.sourceConditions?.ifMatch,
        sourceIfModifiedSince: i.sourceConditions?.ifModifiedSince,
        sourceIfNoneMatch: i.sourceConditions?.ifNoneMatch,
        sourceIfUnmodifiedSince: i.sourceConditions?.ifUnmodifiedSince
      },
      cpkInfo: i.customerProvidedKey,
      encryptionScope: i.encryptionScope,
      copySourceAuthorization: Ys(i.sourceAuthorization),
      fileRequestIntent: i.sourceShareTokenIntent,
      tracingOptions: o.tracingOptions
    })));
  }
  /**
   * Frees the specified pages from the page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-page
   *
   * @param offset - Starting byte position of the pages to clear.
   * @param count - Number of bytes to clear.
   * @param options - Options to the Page Blob Clear Pages operation.
   * @returns Response data for the Page Blob Clear Pages operation.
   */
  async clearPages(e = 0, r, n = {}) {
    return n.conditions = n.conditions || {}, Te.withSpan("PageBlobClient-clearPages", n, async (s) => Ue(await this.pageBlobContext.clearPages(0, {
      abortSignal: n.abortSignal,
      leaseAccessConditions: n.conditions,
      modifiedAccessConditions: {
        ...n.conditions,
        ifTags: n.conditions?.tagConditions
      },
      range: nr({ offset: e, count: r }),
      sequenceNumberAccessConditions: n.conditions,
      cpkInfo: n.customerProvidedKey,
      encryptionScope: n.encryptionScope,
      tracingOptions: s.tracingOptions
    })));
  }
  /**
   * Returns the list of valid page ranges for a page blob or snapshot of a page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param options - Options to the Page Blob Get Ranges operation.
   * @returns Response data for the Page Blob Get Ranges operation.
   */
  async getPageRanges(e = 0, r, n = {}) {
    return n.conditions = n.conditions || {}, Te.withSpan("PageBlobClient-getPageRanges", n, async (s) => {
      const i = Ue(await this.pageBlobContext.getPageRanges({
        abortSignal: n.abortSignal,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: {
          ...n.conditions,
          ifTags: n.conditions?.tagConditions
        },
        range: nr({ offset: e, count: r }),
        tracingOptions: s.tracingOptions
      }));
      return vc(i);
    });
  }
  /**
   * getPageRangesSegment returns a single segment of page ranges starting from the
   * specified Marker. Use an empty Marker to start enumeration from the beginning.
   * After getting a segment, process it, and then call getPageRangesSegment again
   * (passing the the previously-returned Marker) to get the next segment.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
   * @param options - Options to PageBlob Get Page Ranges Segment operation.
   */
  async listPageRangesSegment(e = 0, r, n, s = {}) {
    return Te.withSpan("PageBlobClient-getPageRangesSegment", s, async (i) => Ue(await this.pageBlobContext.getPageRanges({
      abortSignal: s.abortSignal,
      leaseAccessConditions: s.conditions,
      modifiedAccessConditions: {
        ...s.conditions,
        ifTags: s.conditions?.tagConditions
      },
      range: nr({ offset: e, count: r }),
      marker: n,
      maxPageSize: s.maxPageSize,
      tracingOptions: i.tracingOptions
    })));
  }
  /**
   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param marker - A string value that identifies the portion of
   *                          the get of page ranges to be returned with the next getting operation. The
   *                          operation returns the ContinuationToken value within the response body if the
   *                          getting operation did not return all page ranges remaining within the current page.
   *                          The ContinuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of get
   *                          items. The marker value is opaque to the client.
   * @param options - Options to List Page Ranges operation.
   */
  async *listPageRangeItemSegments(e = 0, r, n, s = {}) {
    let i;
    if (n || n === void 0)
      do
        i = await this.listPageRangesSegment(e, r, n, s), n = i.continuationToken, yield await i;
      while (n);
  }
  /**
   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param options - Options to List Page Ranges operation.
   */
  async *listPageRangeItems(e = 0, r, n = {}) {
    let s;
    for await (const i of this.listPageRangeItemSegments(e, r, s, n))
      yield* Ng(i);
  }
  /**
   * Returns an async iterable iterator to list of page ranges for a page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.
   *
   * ```ts snippet:ClientsListPageBlobs
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   * const pageBlobClient = containerClient.getPageBlobClient(blobName);
   *
   * // Example using `for await` syntax
   * let i = 1;
   * for await (const pageRange of pageBlobClient.listPageRanges()) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   *
   * // Example using `iter.next()` syntax
   * i = 1;
   * const iter = pageBlobClient.listPageRanges();
   * let { value, done } = await iter.next();
   * while (!done) {
   *   console.log(`Page range ${i++}: ${value.start} - ${value.end}`);
   *   ({ value, done } = await iter.next());
   * }
   *
   * // Example using `byPage()` syntax
   * i = 1;
   * for await (const page of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {
   *   for (const pageRange of page.pageRange || []) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   *
   * // Example using paging with a marker
   * i = 1;
   * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   * // Prints 2 page ranges
   * if (response.pageRange) {
   *   for (const pageRange of response.pageRange) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   * // Gets next marker
   * let marker = response.continuationToken;
   * // Passing next marker as continuationToken
   * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   * // Prints 10 page ranges
   * if (response.pageRange) {
   *   for (const pageRange of response.pageRange) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   * ```
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param options - Options to the Page Blob Get Ranges operation.
   * @returns An asyncIterableIterator that supports paging.
   */
  listPageRanges(e = 0, r, n = {}) {
    n.conditions = n.conditions || {};
    const s = this.listPageRangeItems(e, r, n);
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return s.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (i = {}) => this.listPageRangeItemSegments(e, r, i.continuationToken, {
        maxPageSize: i.maxPageSize,
        ...n
      })
    };
  }
  /**
   * Gets the collection of page ranges that differ between a specified snapshot and this page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page blob
   * @param count - Number of bytes to get ranges diff.
   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   * @returns Response data for the Page Blob Get Page Range Diff operation.
   */
  async getPageRangesDiff(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, Te.withSpan("PageBlobClient-getPageRangesDiff", s, async (i) => {
      const o = Ue(await this.pageBlobContext.getPageRangesDiff({
        abortSignal: s.abortSignal,
        leaseAccessConditions: s.conditions,
        modifiedAccessConditions: {
          ...s.conditions,
          ifTags: s.conditions?.tagConditions
        },
        prevsnapshot: n,
        range: nr({ offset: e, count: r }),
        tracingOptions: i.tracingOptions
      }));
      return vc(o);
    });
  }
  /**
   * getPageRangesDiffSegment returns a single segment of page ranges starting from the
   * specified Marker for difference between previous snapshot and the target page blob.
   * Use an empty Marker to start enumeration from the beginning.
   * After getting a segment, process it, and then call getPageRangesDiffSegment again
   * (passing the the previously-returned Marker) to get the next segment.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
   * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   */
  async listPageRangesDiffSegment(e, r, n, s, i = {}) {
    return Te.withSpan("PageBlobClient-getPageRangesDiffSegment", i, async (o) => Ue(await this.pageBlobContext.getPageRangesDiff({
      abortSignal: i?.abortSignal,
      leaseAccessConditions: i?.conditions,
      modifiedAccessConditions: {
        ...i?.conditions,
        ifTags: i?.conditions?.tagConditions
      },
      prevsnapshot: n,
      range: nr({
        offset: e,
        count: r
      }),
      marker: s,
      maxPageSize: i?.maxPageSize,
      tracingOptions: o.tracingOptions
    })));
  }
  /**
   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}
   *
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
   * @param marker - A string value that identifies the portion of
   *                          the get of page ranges to be returned with the next getting operation. The
   *                          operation returns the ContinuationToken value within the response body if the
   *                          getting operation did not return all page ranges remaining within the current page.
   *                          The ContinuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of get
   *                          items. The marker value is opaque to the client.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   */
  async *listPageRangeDiffItemSegments(e, r, n, s, i) {
    let o;
    if (s || s === void 0)
      do
        o = await this.listPageRangesDiffSegment(e, r, n, s, i), s = o.continuationToken, yield await o;
      while (s);
  }
  /**
   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   */
  async *listPageRangeDiffItems(e, r, n, s) {
    let i;
    for await (const o of this.listPageRangeDiffItemSegments(e, r, n, i, s))
      yield* Ng(o);
  }
  /**
   * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
   *
   * ```ts snippet:ClientsListPageBlobsDiff
   * import { BlobServiceClient } from "@azure/storage-blob";
   * import { DefaultAzureCredential } from "@azure/identity";
   *
   * const account = "<account>";
   * const blobServiceClient = new BlobServiceClient(
   *   `https://${account}.blob.core.windows.net`,
   *   new DefaultAzureCredential(),
   * );
   *
   * const containerName = "<container name>";
   * const blobName = "<blob name>";
   * const containerClient = blobServiceClient.getContainerClient(containerName);
   * const pageBlobClient = containerClient.getPageBlobClient(blobName);
   *
   * const offset = 0;
   * const count = 1024;
   * const previousSnapshot = "<previous snapshot>";
   * // Example using `for await` syntax
   * let i = 1;
   * for await (const pageRange of pageBlobClient.listPageRangesDiff(offset, count, previousSnapshot)) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   *
   * // Example using `iter.next()` syntax
   * i = 1;
   * const iter = pageBlobClient.listPageRangesDiff(offset, count, previousSnapshot);
   * let { value, done } = await iter.next();
   * while (!done) {
   *   console.log(`Page range ${i++}: ${value.start} - ${value.end}`);
   *   ({ value, done } = await iter.next());
   * }
   *
   * // Example using `byPage()` syntax
   * i = 1;
   * for await (const page of pageBlobClient
   *   .listPageRangesDiff(offset, count, previousSnapshot)
   *   .byPage({ maxPageSize: 20 })) {
   *   for (const pageRange of page.pageRange || []) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   *
   * // Example using paging with a marker
   * i = 1;
   * let iterator = pageBlobClient
   *   .listPageRangesDiff(offset, count, previousSnapshot)
   *   .byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   * // Prints 2 page ranges
   * if (response.pageRange) {
   *   for (const pageRange of response.pageRange) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   * // Gets next marker
   * let marker = response.continuationToken;
   * // Passing next marker as continuationToken
   * iterator = pageBlobClient
   *   .listPageRangesDiff(offset, count, previousSnapshot)
   *   .byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   * // Prints 10 page ranges
   * if (response.pageRange) {
   *   for (const pageRange of response.pageRange) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   * ```
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Ranges operation.
   * @returns An asyncIterableIterator that supports paging.
   */
  listPageRangesDiff(e, r, n, s = {}) {
    s.conditions = s.conditions || {};
    const i = this.listPageRangeDiffItems(e, r, n, {
      ...s
    });
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return i.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (o = {}) => this.listPageRangeDiffItemSegments(e, r, n, o.continuationToken, {
        maxPageSize: o.maxPageSize,
        ...s
      })
    };
  }
  /**
   * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page blob
   * @param count - Number of bytes to get ranges diff.
   * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   * @returns Response data for the Page Blob Get Page Range Diff operation.
   */
  async getPageRangesDiffForManagedDisks(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, Te.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", s, async (i) => {
      const o = Ue(await this.pageBlobContext.getPageRangesDiff({
        abortSignal: s.abortSignal,
        leaseAccessConditions: s.conditions,
        modifiedAccessConditions: {
          ...s.conditions,
          ifTags: s.conditions?.tagConditions
        },
        prevSnapshotUrl: n,
        range: nr({ offset: e, count: r }),
        tracingOptions: i.tracingOptions
      }));
      return vc(o);
    });
  }
  /**
   * Resizes the page blob to the specified size (which must be a multiple of 512).
   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
   *
   * @param size - Target size
   * @param options - Options to the Page Blob Resize operation.
   * @returns Response data for the Page Blob Resize operation.
   */
  async resize(e, r = {}) {
    return r.conditions = r.conditions || {}, Te.withSpan("PageBlobClient-resize", r, async (n) => Ue(await this.pageBlobContext.resize(e, {
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      encryptionScope: r.encryptionScope,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Sets a page blob's sequence number.
   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
   *
   * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.
   * @param sequenceNumber - Required if sequenceNumberAction is max or update
   * @param options - Options to the Page Blob Update Sequence Number operation.
   * @returns Response data for the Page Blob Update Sequence Number operation.
   */
  async updateSequenceNumber(e, r, n = {}) {
    return n.conditions = n.conditions || {}, Te.withSpan("PageBlobClient-updateSequenceNumber", n, async (s) => Ue(await this.pageBlobContext.updateSequenceNumber(e, {
      abortSignal: n.abortSignal,
      blobSequenceNumber: r,
      leaseAccessConditions: n.conditions,
      modifiedAccessConditions: {
        ...n.conditions,
        ifTags: n.conditions?.tagConditions
      },
      tracingOptions: s.tracingOptions
    })));
  }
  /**
   * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.
   * The snapshot is copied such that only the differential changes between the previously
   * copied snapshot are transferred to the destination.
   * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.
   * @see https://learn.microsoft.com/rest/api/storageservices/incremental-copy-blob
   * @see https://learn.microsoft.com/azure/virtual-machines/windows/incremental-snapshots
   *
   * @param copySource - Specifies the name of the source page blob snapshot. For example,
   *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
   * @param options - Options to the Page Blob Copy Incremental operation.
   * @returns Response data for the Page Blob Copy Incremental operation.
   */
  async startCopyIncremental(e, r = {}) {
    return Te.withSpan("PageBlobClient-startCopyIncremental", r, async (n) => Ue(await this.pageBlobContext.copyIncremental(e, {
      abortSignal: r.abortSignal,
      modifiedAccessConditions: {
        ...r.conditions,
        ifTags: r.conditions?.tagConditions
      },
      tracingOptions: n.tracingOptions
    })));
  }
}
class AT extends Error {
  constructor(e) {
    super(e), this.name = "InvalidResponseError";
  }
}
class sl extends Error {
  constructor(e) {
    const r = `Unable to make request: ${e}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
    super(r), this.code = e, this.name = "NetworkError";
  }
}
sl.isNetworkErrorCode = (t) => t ? [
  "ECONNRESET",
  "ENOTFOUND",
  "ETIMEDOUT",
  "ECONNREFUSED",
  "EHOSTUNREACH"
].includes(t) : !1;
class Ti extends Error {
  constructor() {
    super(`Cache storage quota has been hit. Unable to upload any new cache entries. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`), this.name = "UsageError";
  }
}
Ti.isUsageErrorMessage = (t) => t ? t.includes("insufficient usage") : !1;
class Fg extends Error {
  constructor(e) {
    super(e), this.name = "RateLimitError";
  }
}
var cT = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
class lT {
  constructor(e) {
    this.contentLength = e, this.sentBytes = 0, this.displayedComplete = !1, this.startTime = Date.now();
  }
  /**
   * Sets the number of bytes sent
   *
   * @param sentBytes the number of bytes sent
   */
  setSentBytes(e) {
    this.sentBytes = e;
  }
  /**
   * Returns the total number of bytes transferred.
   */
  getTransferredBytes() {
    return this.sentBytes;
  }
  /**
   * Returns true if the upload is complete.
   */
  isDone() {
    return this.getTransferredBytes() === this.contentLength;
  }
  /**
   * Prints the current upload stats. Once the upload completes, this will print one
   * last line and then stop.
   */
  display() {
    if (this.displayedComplete)
      return;
    const e = this.sentBytes, r = (100 * (e / this.contentLength)).toFixed(1), n = Date.now() - this.startTime, s = (e / (1024 * 1024) / (n / 1e3)).toFixed(1);
    xt(`Sent ${e} of ${this.contentLength} (${r}%), ${s} MBs/sec`), this.isDone() && (this.displayedComplete = !0);
  }
  /**
   * Returns a function used to handle TransferProgressEvents.
   */
  onProgress() {
    return (e) => {
      this.setSentBytes(e.loadedBytes);
    };
  }
  /**
   * Starts the timer that displays the stats.
   *
   * @param delayInMs the delay between each write
   */
  startDisplayTimer(e = 1e3) {
    const r = () => {
      this.display(), this.isDone() || (this.timeoutHandle = setTimeout(r, e));
    };
    this.timeoutHandle = setTimeout(r, e);
  }
  /**
   * Stops the timer that displays the stats. As this typically indicates the upload
   * is complete, this will display one last line, unless the last line has already
   * been written.
   */
  stopDisplayTimer() {
    this.timeoutHandle && (clearTimeout(this.timeoutHandle), this.timeoutHandle = void 0), this.display();
  }
}
function dT(t, e, r) {
  return cT(this, void 0, void 0, function* () {
    var n;
    const s = new wn(t), i = s.getBlockBlobClient(), o = new lT((n = r?.archiveSizeBytes) !== null && n !== void 0 ? n : 0), a = {
      blockSize: r?.uploadChunkSize,
      concurrency: r?.uploadConcurrency,
      // maximum number of parallel transfer workers
      maxSingleShotSize: 128 * 1024 * 1024,
      // 128 MiB initial transfer size
      onProgress: o.onProgress()
    };
    try {
      o.startDisplayTimer(), le(`BlobClient: ${s.name}:${s.accountName}:${s.containerName}`);
      const A = yield i.uploadFile(e, a);
      if (A._response.status >= 400)
        throw new AT(`uploadCacheArchiveSDK: upload failed with status code ${A._response.status}`);
      return A;
    } catch (A) {
      throw Hr(`uploadCacheArchiveSDK: internal error uploading cache archive: ${A.message}`), A;
    } finally {
      o.stopDisplayTimer();
    }
  });
}
var Fo = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
function md(t) {
  return t ? t >= 200 && t < 300 : !1;
}
function uT(t) {
  return t ? t >= 500 : !0;
}
function mT(t) {
  return t ? [
    Qt.BadGateway,
    Qt.ServiceUnavailable,
    Qt.GatewayTimeout
  ].includes(t) : !1;
}
function hT(t) {
  return Fo(this, void 0, void 0, function* () {
    return new Promise((e) => setTimeout(e, t));
  });
}
function EI(t, e, r) {
  return Fo(this, arguments, void 0, function* (n, s, i, o = Pl, a = Hl, A = void 0) {
    let c = "", l = 1;
    for (; l <= o; ) {
      let d, u, m = !1;
      try {
        d = yield s();
      } catch (h) {
        A && (d = A(h)), m = !0, c = h.message;
      }
      if (d && (u = i(d), !uT(u)))
        return d;
      if (u && (m = mT(u), c = `Cache service responded with ${u}`), le(`${n} - Attempt ${l} of ${o} failed with error: ${c}`), !m) {
        le(`${n} - Error is not retryable`);
        break;
      }
      yield hT(a), l++;
    }
    throw Error(`${n} failed: ${c}`);
  });
}
function vo(t, e) {
  return Fo(this, arguments, void 0, function* (r, n, s = Pl, i = Hl) {
    return yield EI(
      r,
      n,
      (o) => o.statusCode,
      s,
      i,
      // If the error object contains the statusCode property, extract it and return
      // an TypedResponse<T> so it can be processed by the retry logic.
      (o) => {
        if (o instanceof en)
          return {
            statusCode: o.statusCode,
            result: null,
            headers: {},
            error: o
          };
      }
    );
  });
}
function Lo(t, e) {
  return Fo(this, arguments, void 0, function* (r, n, s = Pl, i = Hl) {
    return yield EI(r, n, (o) => o.message.statusCode, s, i);
  });
}
var lr = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
function gT(t, e) {
  return lr(this, void 0, void 0, function* () {
    yield hl.promisify(Zg.pipeline)(t.message, e);
  });
}
class CI {
  constructor(e) {
    this.contentLength = e, this.segmentIndex = 0, this.segmentSize = 0, this.segmentOffset = 0, this.receivedBytes = 0, this.displayedComplete = !1, this.startTime = Date.now();
  }
  /**
   * Progress to the next segment. Only call this method when the previous segment
   * is complete.
   *
   * @param segmentSize the length of the next segment
   */
  nextSegment(e) {
    this.segmentOffset = this.segmentOffset + this.segmentSize, this.segmentIndex = this.segmentIndex + 1, this.segmentSize = e, this.receivedBytes = 0, le(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
  }
  /**
   * Sets the number of bytes received for the current segment.
   *
   * @param receivedBytes the number of bytes received
   */
  setReceivedBytes(e) {
    this.receivedBytes = e;
  }
  /**
   * Returns the total number of bytes transferred.
   */
  getTransferredBytes() {
    return this.segmentOffset + this.receivedBytes;
  }
  /**
   * Returns true if the download is complete.
   */
  isDone() {
    return this.getTransferredBytes() === this.contentLength;
  }
  /**
   * Prints the current download stats. Once the download completes, this will print one
   * last line and then stop.
   */
  display() {
    if (this.displayedComplete)
      return;
    const e = this.segmentOffset + this.receivedBytes, r = (100 * (e / this.contentLength)).toFixed(1), n = Date.now() - this.startTime, s = (e / (1024 * 1024) / (n / 1e3)).toFixed(1);
    xt(`Received ${e} of ${this.contentLength} (${r}%), ${s} MBs/sec`), this.isDone() && (this.displayedComplete = !0);
  }
  /**
   * Returns a function used to handle TransferProgressEvents.
   */
  onProgress() {
    return (e) => {
      this.setReceivedBytes(e.loadedBytes);
    };
  }
  /**
   * Starts the timer that displays the stats.
   *
   * @param delayInMs the delay between each write
   */
  startDisplayTimer(e = 1e3) {
    const r = () => {
      this.display(), this.isDone() || (this.timeoutHandle = setTimeout(r, e));
    };
    this.timeoutHandle = setTimeout(r, e);
  }
  /**
   * Stops the timer that displays the stats. As this typically indicates the download
   * is complete, this will display one last line, unless the last line has already
   * been written.
   */
  stopDisplayTimer() {
    this.timeoutHandle && (clearTimeout(this.timeoutHandle), this.timeoutHandle = void 0), this.display();
  }
}
function il(t, e) {
  return lr(this, void 0, void 0, function* () {
    const r = tt.createWriteStream(e), n = new Kn("actions/cache"), s = yield Lo("downloadCache", () => lr(this, void 0, void 0, function* () {
      return n.get(t);
    }));
    s.message.socket.setTimeout(bh, () => {
      s.message.destroy(), le(`Aborting download, socket timed out after ${bh} ms`);
    }), yield gT(s, r);
    const i = s.message.headers["content-length"];
    if (i) {
      const o = parseInt(i), a = Dn(e);
      if (a !== o)
        throw new Error(`Incomplete download. Expected file size: ${o}, actual file size: ${a}`);
    } else
      le("Unable to validate download, no Content-Length header");
  });
}
function fT(t, e, r) {
  return lr(this, void 0, void 0, function* () {
    var n;
    const s = yield tt.promises.open(e, "w"), i = new Kn("actions/cache", void 0, {
      socketTimeout: r.timeoutInMs,
      keepAlive: !0
    });
    try {
      const a = (yield Lo("downloadCacheMetadata", () => lr(this, void 0, void 0, function* () {
        return yield i.request("HEAD", t, null, {});
      }))).message.headers["content-length"];
      if (a == null)
        throw new Error("Content-Length not found on blob response");
      const A = parseInt(a);
      if (Number.isNaN(A))
        throw new Error(`Could not interpret Content-Length: ${A}`);
      const c = [], l = 4 * 1024 * 1024;
      for (let w = 0; w < A; w += l) {
        const R = Math.min(l, A - w);
        c.push({
          offset: w,
          promiseGetter: () => lr(this, void 0, void 0, function* () {
            return yield pT(i, t, w, R);
          })
        });
      }
      c.reverse();
      let d = 0, u = 0;
      const m = new CI(A);
      m.startDisplayTimer();
      const h = m.onProgress(), f = [];
      let p;
      const y = () => lr(this, void 0, void 0, function* () {
        const w = yield Promise.race(Object.values(f));
        yield s.write(w.buffer, 0, w.count, w.offset), d--, delete f[w.offset], u += w.count, h({ loadedBytes: u });
      });
      for (; p = c.pop(); )
        f[p.offset] = p.promiseGetter(), d++, d >= ((n = r.downloadConcurrency) !== null && n !== void 0 ? n : 10) && (yield y());
      for (; d > 0; )
        yield y();
    } finally {
      i.dispose(), yield s.close();
    }
  });
}
function pT(t, e, r, n) {
  return lr(this, void 0, void 0, function* () {
    let i = 0;
    for (; ; )
      try {
        const a = yield BI(3e4, ET(t, e, r, n));
        if (typeof a == "string")
          throw new Error("downloadSegmentRetry failed due to timeout");
        return a;
      } catch (o) {
        if (i >= 5)
          throw o;
        i++;
      }
  });
}
function ET(t, e, r, n) {
  return lr(this, void 0, void 0, function* () {
    const s = yield Lo("downloadCachePart", () => lr(this, void 0, void 0, function* () {
      return yield t.get(e, {
        Range: `bytes=${r}-${r + n - 1}`
      });
    }));
    if (!s.readBodyBuffer)
      throw new Error("Expected HttpClientResponse to implement readBodyBuffer");
    return {
      offset: r,
      count: n,
      buffer: yield s.readBodyBuffer()
    };
  });
}
function CT(t, e, r) {
  return lr(this, void 0, void 0, function* () {
    var n;
    const s = new To(t, void 0, {
      retryOptions: {
        // Override the timeout used when downloading each 4 MB chunk
        // The default is 2 min / MB, which is way too slow
        tryTimeoutInMs: r.timeoutInMs
      }
    }), o = (n = (yield s.getProperties()).contentLength) !== null && n !== void 0 ? n : -1;
    if (o < 0)
      le("Unable to determine content length, downloading file with http-client..."), yield il(t, e);
    else {
      const a = Math.min(134217728, Cy.constants.MAX_LENGTH), A = new CI(o), c = tt.openSync(e, "w");
      try {
        A.startDisplayTimer();
        const l = new AbortController(), d = l.signal;
        for (; !A.isDone(); ) {
          const u = A.segmentOffset + A.segmentSize, m = Math.min(a, o - u);
          A.nextSegment(m);
          const h = yield BI(r.segmentTimeoutInMs || 36e5, s.downloadToBuffer(u, m, {
            abortSignal: d,
            concurrency: r.downloadConcurrency,
            onProgress: A.onProgress()
          }));
          if (h === "timeout")
            throw l.abort(), new Error("Aborting cache download as the download time exceeded the timeout.");
          Buffer.isBuffer(h) && tt.writeFileSync(c, h);
        }
      } finally {
        A.stopDisplayTimer(), tt.closeSync(c);
      }
    }
  });
}
const BI = (t, e) => lr(void 0, void 0, void 0, function* () {
  let r;
  const n = new Promise((s) => {
    r = setTimeout(() => s("timeout"), t);
  });
  return Promise.race([e, n]).then((s) => (clearTimeout(r), s));
});
function II(t) {
  const e = {
    useAzureSdk: !1,
    uploadConcurrency: 4,
    uploadChunkSize: 33554432
  };
  return t && (typeof t.useAzureSdk == "boolean" && (e.useAzureSdk = t.useAzureSdk), typeof t.uploadConcurrency == "number" && (e.uploadConcurrency = t.uploadConcurrency), typeof t.uploadChunkSize == "number" && (e.uploadChunkSize = t.uploadChunkSize)), e.uploadConcurrency = isNaN(Number(process.env.CACHE_UPLOAD_CONCURRENCY)) ? e.uploadConcurrency : Math.min(32, Number(process.env.CACHE_UPLOAD_CONCURRENCY)), e.uploadChunkSize = isNaN(Number(process.env.CACHE_UPLOAD_CHUNK_SIZE)) ? e.uploadChunkSize : Math.min(128 * 1024 * 1024, Number(process.env.CACHE_UPLOAD_CHUNK_SIZE) * 1024 * 1024), le(`Use Azure SDK: ${e.useAzureSdk}`), le(`Upload concurrency: ${e.uploadConcurrency}`), le(`Upload chunk size: ${e.uploadChunkSize}`), e;
}
function BT(t) {
  const e = {
    useAzureSdk: !1,
    concurrentBlobDownloads: !0,
    downloadConcurrency: 8,
    timeoutInMs: 3e4,
    segmentTimeoutInMs: 6e5,
    lookupOnly: !1
  };
  t && (typeof t.useAzureSdk == "boolean" && (e.useAzureSdk = t.useAzureSdk), typeof t.concurrentBlobDownloads == "boolean" && (e.concurrentBlobDownloads = t.concurrentBlobDownloads), typeof t.downloadConcurrency == "number" && (e.downloadConcurrency = t.downloadConcurrency), typeof t.timeoutInMs == "number" && (e.timeoutInMs = t.timeoutInMs), typeof t.segmentTimeoutInMs == "number" && (e.segmentTimeoutInMs = t.segmentTimeoutInMs), typeof t.lookupOnly == "boolean" && (e.lookupOnly = t.lookupOnly));
  const r = process.env.SEGMENT_DOWNLOAD_TIMEOUT_MINS;
  return r && !isNaN(Number(r)) && isFinite(Number(r)) && (e.segmentTimeoutInMs = Number(r) * 60 * 1e3), le(`Use Azure SDK: ${e.useAzureSdk}`), le(`Download concurrency: ${e.downloadConcurrency}`), le(`Request timeout (ms): ${e.timeoutInMs}`), le(`Cache segment download timeout mins env var: ${process.env.SEGMENT_DOWNLOAD_TIMEOUT_MINS}`), le(`Segment download timeout (ms): ${e.segmentTimeoutInMs}`), le(`Lookup only: ${e.lookupOnly}`), e;
}
function yI() {
  const e = new URL(process.env.GITHUB_SERVER_URL || "https://github.com").hostname.trimEnd().toUpperCase(), r = e === "GITHUB.COM", n = e.endsWith(".GHE.COM"), s = e.endsWith(".LOCALHOST");
  return !r && !n && !s;
}
function hd() {
  return yI() ? "v1" : process.env.ACTIONS_CACHE_SERVICE_V2 ? "v2" : "v1";
}
function QI() {
  const t = hd();
  switch (t) {
    case "v1":
      return process.env.ACTIONS_CACHE_URL || process.env.ACTIONS_RESULTS_URL || "";
    case "v2":
      return process.env.ACTIONS_RESULTS_URL || "";
    default:
      throw new Error(`Unsupported cache service version: ${t}`);
  }
}
const IT = "6.0.0", yT = {
  version: IT
};
var Lc, vg;
function QT() {
  return vg || (vg = 1, Lc = { version: yT.version }), Lc;
}
var NT = QT();
function NI() {
  return `@actions/cache-${NT.version}`;
}
var Kt = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
function di(t) {
  const e = QI();
  if (!e)
    throw new Error("Cache Service Url not found, unable to restore cache.");
  const r = `${e}_apis/artifactcache/${t}`;
  return le(`Resource Url: ${r}`), r;
}
function wT(t, e) {
  return `${t};api-version=${e}`;
}
function bT() {
  return {
    headers: {
      Accept: wT("application/json", "6.0-preview.1")
    }
  };
}
function gd() {
  const t = process.env.ACTIONS_RUNTIME_TOKEN || "", e = new Cf(t);
  return new Kn(NI(), [e], bT());
}
function xT(t, e, r) {
  return Kt(this, void 0, void 0, function* () {
    const n = gd(), s = po(e, r?.compressionMethod, r?.enableCrossOsArchive), i = `cache?keys=${encodeURIComponent(t.join(","))}&version=${s}`, o = yield vo("getCacheEntry", () => Kt(this, void 0, void 0, function* () {
      return n.getJson(di(i));
    }));
    if (o.statusCode === 204)
      return Sn() && (yield RT(t[0], n, s)), null;
    if (!md(o.statusCode))
      throw new Error(`Cache service responded with ${o.statusCode}`);
    const a = o.result, A = a?.archiveLocation;
    if (!A)
      throw new Error("Cache not found.");
    return Li(A), le("Cache Result:"), le(JSON.stringify(a)), a;
  });
}
function RT(t, e, r) {
  return Kt(this, void 0, void 0, function* () {
    const n = `caches?key=${encodeURIComponent(t)}`, s = yield vo("listCache", () => Kt(this, void 0, void 0, function* () {
      return e.getJson(di(n));
    }));
    if (s.statusCode === 200) {
      const i = s.result, o = i?.totalCount;
      if (o && o > 0) {
        le(`No matching cache found for cache key '${t}', version '${r} and scope ${process.env.GITHUB_REF}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key 
Other caches with similar key:`);
        for (const a of i?.artifactCaches || [])
          le(`Cache Key: ${a?.cacheKey}, Cache Version: ${a?.cacheVersion}, Cache Scope: ${a?.scope}, Cache Created: ${a?.creationTime}`);
      }
    }
  });
}
function wI(t, e, r) {
  return Kt(this, void 0, void 0, function* () {
    const n = new Ey(t), s = BT(r);
    n.hostname.endsWith(".blob.core.windows.net") ? s.useAzureSdk ? yield CT(t, e, s) : s.concurrentBlobDownloads ? yield fT(t, e, s) : yield il(t, e) : yield il(t, e);
  });
}
function ST(t, e, r) {
  return Kt(this, void 0, void 0, function* () {
    const n = gd(), s = po(e, r?.compressionMethod, r?.enableCrossOsArchive), i = {
      key: t,
      version: s,
      cacheSize: r?.cacheSize
    };
    return yield vo("reserveCache", () => Kt(this, void 0, void 0, function* () {
      return n.postJson(di("caches"), i);
    }));
  });
}
function Lg(t, e) {
  return `bytes ${t}-${e}/*`;
}
function DT(t, e, r, n, s) {
  return Kt(this, void 0, void 0, function* () {
    le(`Uploading chunk of size ${s - n + 1} bytes at offset ${n} with content range: ${Lg(n, s)}`);
    const i = {
      "Content-Type": "application/octet-stream",
      "Content-Range": Lg(n, s)
    }, o = yield Lo(`uploadChunk (start: ${n}, end: ${s})`, () => Kt(this, void 0, void 0, function* () {
      return t.sendStream("PATCH", e, r(), i);
    }));
    if (!md(o.message.statusCode))
      throw new Error(`Cache service responded with ${o.message.statusCode} during upload chunk.`);
  });
}
function kT(t, e, r, n) {
  return Kt(this, void 0, void 0, function* () {
    const s = Dn(r), i = di(`caches/${e.toString()}`), o = tt.openSync(r, "r"), a = II(n), A = Rh("uploadConcurrency", a.uploadConcurrency), c = Rh("uploadChunkSize", a.uploadChunkSize), l = [...new Array(A).keys()];
    le("Awaiting all uploads");
    let d = 0;
    try {
      yield Promise.all(l.map(() => Kt(this, void 0, void 0, function* () {
        for (; d < s; ) {
          const u = Math.min(s - d, c), m = d, h = d + u - 1;
          d += c, yield DT(t, i, () => tt.createReadStream(r, {
            fd: o,
            start: m,
            end: h,
            autoClose: !1
          }).on("error", (f) => {
            throw new Error(`Cache upload failed because file read failed with ${f.message}`);
          }), m, h);
        }
      })));
    } finally {
      tt.closeSync(o);
    }
  });
}
function MT(t, e, r) {
  return Kt(this, void 0, void 0, function* () {
    const n = { size: r };
    return yield vo("commitCache", () => Kt(this, void 0, void 0, function* () {
      return t.postJson(di(`caches/${e.toString()}`), n);
    }));
  });
}
function bI(t, e, r, n) {
  return Kt(this, void 0, void 0, function* () {
    if (II(n).useAzureSdk) {
      if (!r)
        throw new Error("Azure Storage SDK can only be used when a signed URL is provided.");
      yield dT(r, e, n);
    } else {
      const i = gd();
      le("Upload cache"), yield kT(i, t, e, n), le("Commiting cache");
      const o = Dn(e);
      xt(`Cache Size: ~${Math.round(o / (1024 * 1024))} MB (${o} B)`);
      const a = yield MT(i, t, o);
      if (!md(a.statusCode))
        throw new Error(`Cache service responded with ${a.statusCode} during commit cache.`);
      xt("Cache saved successfully");
    }
  });
}
function xI(t) {
  let e = typeof t;
  if (e == "object") {
    if (Array.isArray(t))
      return "array";
    if (t === null)
      return "null";
  }
  return e;
}
function TT(t) {
  return t !== null && typeof t == "object" && !Array.isArray(t);
}
let Ur = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), Uo = [];
for (let t = 0; t < Ur.length; t++)
  Uo[Ur[t].charCodeAt(0)] = t;
Uo[45] = Ur.indexOf("+");
Uo[95] = Ur.indexOf("/");
function FT(t) {
  let e = t.length * 3 / 4;
  t[t.length - 2] == "=" ? e -= 2 : t[t.length - 1] == "=" && (e -= 1);
  let r = new Uint8Array(e), n = 0, s = 0, i, o = 0;
  for (let a = 0; a < t.length; a++) {
    if (i = Uo[t.charCodeAt(a)], i === void 0)
      switch (t[a]) {
        case "=":
          s = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string.");
      }
    switch (s) {
      case 0:
        o = i, s = 1;
        break;
      case 1:
        r[n++] = o << 2 | (i & 48) >> 4, o = i, s = 2;
        break;
      case 2:
        r[n++] = (o & 15) << 4 | (i & 60) >> 2, o = i, s = 3;
        break;
      case 3:
        r[n++] = (o & 3) << 6 | i, s = 0;
        break;
    }
  }
  if (s == 1)
    throw Error("invalid base64 string.");
  return r.subarray(0, n);
}
function vT(t) {
  let e = "", r = 0, n, s = 0;
  for (let i = 0; i < t.length; i++)
    switch (n = t[i], r) {
      case 0:
        e += Ur[n >> 2], s = (n & 3) << 4, r = 1;
        break;
      case 1:
        e += Ur[s | n >> 4], s = (n & 15) << 2, r = 2;
        break;
      case 2:
        e += Ur[s | n >> 6], e += Ur[n & 63], r = 0;
        break;
    }
  return r && (e += Ur[s], e += "=", r == 1 && (e += "=")), e;
}
var Nt;
(function(t) {
  t.symbol = /* @__PURE__ */ Symbol.for("protobuf-ts/unknown"), t.onRead = (r, n, s, i, o) => {
    (e(n) ? n[t.symbol] : n[t.symbol] = []).push({ no: s, wireType: i, data: o });
  }, t.onWrite = (r, n, s) => {
    for (let { no: i, wireType: o, data: a } of t.list(n))
      s.tag(i, o).raw(a);
  }, t.list = (r, n) => {
    if (e(r)) {
      let s = r[t.symbol];
      return n ? s.filter((i) => i.no == n) : s;
    }
    return [];
  }, t.last = (r, n) => t.list(r, n).slice(-1)[0];
  const e = (r) => r && Array.isArray(r[t.symbol]);
})(Nt || (Nt = {}));
var Oe;
(function(t) {
  t[t.Varint = 0] = "Varint", t[t.Bit64 = 1] = "Bit64", t[t.LengthDelimited = 2] = "LengthDelimited", t[t.StartGroup = 3] = "StartGroup", t[t.EndGroup = 4] = "EndGroup", t[t.Bit32 = 5] = "Bit32";
})(Oe || (Oe = {}));
function LT() {
  let t = 0, e = 0;
  for (let n = 0; n < 28; n += 7) {
    let s = this.buf[this.pos++];
    if (t |= (s & 127) << n, (s & 128) == 0)
      return this.assertBounds(), [t, e];
  }
  let r = this.buf[this.pos++];
  if (t |= (r & 15) << 28, e = (r & 112) >> 4, (r & 128) == 0)
    return this.assertBounds(), [t, e];
  for (let n = 3; n <= 31; n += 7) {
    let s = this.buf[this.pos++];
    if (e |= (s & 127) << n, (s & 128) == 0)
      return this.assertBounds(), [t, e];
  }
  throw new Error("invalid varint");
}
function Uc(t, e, r) {
  for (let i = 0; i < 28; i = i + 7) {
    const o = t >>> i, a = !(!(o >>> 7) && e == 0), A = (a ? o | 128 : o) & 255;
    if (r.push(A), !a)
      return;
  }
  const n = t >>> 28 & 15 | (e & 7) << 4, s = e >> 3 != 0;
  if (r.push((s ? n | 128 : n) & 255), !!s) {
    for (let i = 3; i < 31; i = i + 7) {
      const o = e >>> i, a = !!(o >>> 7), A = (a ? o | 128 : o) & 255;
      if (r.push(A), !a)
        return;
    }
    r.push(e >>> 31 & 1);
  }
}
const Fi = 65536 * 65536;
function RI(t) {
  let e = t[0] == "-";
  e && (t = t.slice(1));
  const r = 1e6;
  let n = 0, s = 0;
  function i(o, a) {
    const A = Number(t.slice(o, a));
    s *= r, n = n * r + A, n >= Fi && (s = s + (n / Fi | 0), n = n % Fi);
  }
  return i(-24, -18), i(-18, -12), i(-12, -6), i(-6), [e, n, s];
}
function ol(t, e) {
  if (e >>> 0 <= 2097151)
    return "" + (Fi * e + (t >>> 0));
  let r = t & 16777215, n = (t >>> 24 | e << 8) >>> 0 & 16777215, s = e >> 16 & 65535, i = r + n * 6777216 + s * 6710656, o = n + s * 8147497, a = s * 2, A = 1e7;
  i >= A && (o += Math.floor(i / A), i %= A), o >= A && (a += Math.floor(o / A), o %= A);
  function c(l, d) {
    let u = l ? String(l) : "";
    return d ? "0000000".slice(u.length) + u : u;
  }
  return c(
    a,
    /*needLeadingZeros=*/
    0
  ) + c(
    o,
    /*needLeadingZeros=*/
    a
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  c(
    i,
    /*needLeadingZeros=*/
    1
  );
}
function Ug(t, e) {
  if (t >= 0) {
    for (; t > 127; )
      e.push(t & 127 | 128), t = t >>> 7;
    e.push(t);
  } else {
    for (let r = 0; r < 9; r++)
      e.push(t & 127 | 128), t = t >> 7;
    e.push(1);
  }
}
function UT() {
  let t = this.buf[this.pos++], e = t & 127;
  if ((t & 128) == 0)
    return this.assertBounds(), e;
  if (t = this.buf[this.pos++], e |= (t & 127) << 7, (t & 128) == 0)
    return this.assertBounds(), e;
  if (t = this.buf[this.pos++], e |= (t & 127) << 14, (t & 128) == 0)
    return this.assertBounds(), e;
  if (t = this.buf[this.pos++], e |= (t & 127) << 21, (t & 128) == 0)
    return this.assertBounds(), e;
  t = this.buf[this.pos++], e |= (t & 15) << 28;
  for (let r = 5; (t & 128) !== 0 && r < 10; r++)
    t = this.buf[this.pos++];
  if ((t & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), e >>> 0;
}
let ct;
function PT() {
  const t = new DataView(new ArrayBuffer(8));
  ct = globalThis.BigInt !== void 0 && typeof t.getBigInt64 == "function" && typeof t.getBigUint64 == "function" && typeof t.setBigInt64 == "function" && typeof t.setBigUint64 == "function" ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: t
  } : void 0;
}
PT();
function SI(t) {
  if (!t)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
const DI = /^-?[0-9]+$/, Vi = 4294967296, Ri = 2147483648;
class kI {
  /**
   * Create a new instance with the given bits.
   */
  constructor(e, r) {
    this.lo = e | 0, this.hi = r | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let e = this.hi * Vi + (this.lo >>> 0);
    if (!Number.isSafeInteger(e))
      throw new Error("cannot convert to safe number");
    return e;
  }
}
class Ot extends kI {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(e) {
    if (ct)
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e == "")
            throw new Error("string is no integer");
          e = ct.C(e);
        case "number":
          if (e === 0)
            return this.ZERO;
          e = ct.C(e);
        case "bigint":
          if (!e)
            return this.ZERO;
          if (e < ct.UMIN)
            throw new Error("signed value for ulong");
          if (e > ct.UMAX)
            throw new Error("ulong too large");
          return ct.V.setBigUint64(0, e, !0), new Ot(ct.V.getInt32(0, !0), ct.V.getInt32(4, !0));
      }
    else
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e = e.trim(), !DI.test(e))
            throw new Error("string is no integer");
          let [r, n, s] = RI(e);
          if (r)
            throw new Error("signed value for ulong");
          return new Ot(n, s);
        case "number":
          if (e == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(e))
            throw new Error("number is no integer");
          if (e < 0)
            throw new Error("signed value for ulong");
          return new Ot(e, e / Vi);
      }
    throw new Error("unknown value " + typeof e);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return ct ? this.toBigInt().toString() : ol(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    return SI(ct), ct.V.setInt32(0, this.lo, !0), ct.V.setInt32(4, this.hi, !0), ct.V.getBigUint64(0, !0);
  }
}
Ot.ZERO = new Ot(0, 0);
class Ct extends kI {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(e) {
    if (ct)
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e == "")
            throw new Error("string is no integer");
          e = ct.C(e);
        case "number":
          if (e === 0)
            return this.ZERO;
          e = ct.C(e);
        case "bigint":
          if (!e)
            return this.ZERO;
          if (e < ct.MIN)
            throw new Error("signed long too small");
          if (e > ct.MAX)
            throw new Error("signed long too large");
          return ct.V.setBigInt64(0, e, !0), new Ct(ct.V.getInt32(0, !0), ct.V.getInt32(4, !0));
      }
    else
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e = e.trim(), !DI.test(e))
            throw new Error("string is no integer");
          let [r, n, s] = RI(e);
          if (r) {
            if (s > Ri || s == Ri && n != 0)
              throw new Error("signed long too small");
          } else if (s >= Ri)
            throw new Error("signed long too large");
          let i = new Ct(n, s);
          return r ? i.negate() : i;
        case "number":
          if (e == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(e))
            throw new Error("number is no integer");
          return e > 0 ? new Ct(e, e / Vi) : new Ct(-e, -e / Vi).negate();
      }
    throw new Error("unknown value " + typeof e);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & Ri) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let e = ~this.hi, r = this.lo;
    return r ? r = ~r + 1 : e += 1, new Ct(r, e);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (ct)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let e = this.negate();
      return "-" + ol(e.lo, e.hi);
    }
    return ol(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    return SI(ct), ct.V.setInt32(0, this.lo, !0), ct.V.setInt32(4, this.hi, !0), ct.V.getBigInt64(0, !0);
  }
}
Ct.ZERO = new Ct(0, 0);
const Pg = {
  readUnknownField: !0,
  readerFactory: (t) => new OT(t)
};
function HT(t) {
  return t ? Object.assign(Object.assign({}, Pg), t) : Pg;
}
class OT {
  constructor(e, r) {
    this.varint64 = LT, this.uint32 = UT, this.buf = e, this.len = e.length, this.pos = 0, this.view = new DataView(e.buffer, e.byteOffset, e.byteLength), this.textDecoder = r ?? new TextDecoder("utf-8", {
      fatal: !0,
      ignoreBOM: !0
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let e = this.uint32(), r = e >>> 3, n = e & 7;
    if (r <= 0 || n < 0 || n > 5)
      throw new Error("illegal tag: field no " + r + " wire type " + n);
    return [r, n];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(e) {
    let r = this.pos;
    switch (e) {
      case Oe.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case Oe.Bit64:
        this.pos += 4;
      case Oe.Bit32:
        this.pos += 4;
        break;
      case Oe.LengthDelimited:
        let n = this.uint32();
        this.pos += n;
        break;
      case Oe.StartGroup:
        let s;
        for (; (s = this.tag()[1]) !== Oe.EndGroup; )
          this.skip(s);
        break;
      default:
        throw new Error("cant skip wire type " + e);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let e = this.uint32();
    return e >>> 1 ^ -(e & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new Ct(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new Ot(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [e, r] = this.varint64(), n = -(e & 1);
    return e = (e >>> 1 | (r & 1) << 31) ^ n, r = r >>> 1 ^ n, new Ct(e, r);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [e, r] = this.varint64();
    return e !== 0 || r !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new Ot(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new Ct(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let e = this.uint32(), r = this.pos;
    return this.pos += e, this.assertBounds(), this.buf.subarray(r, r + e);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function nt(t, e) {
  if (!t)
    throw new Error(e);
}
const zT = 34028234663852886e22, qT = -34028234663852886e22, GT = 4294967295, YT = 2147483647, JT = -2147483648;
function Ls(t) {
  if (typeof t != "number")
    throw new Error("invalid int 32: " + typeof t);
  if (!Number.isInteger(t) || t > YT || t < JT)
    throw new Error("invalid int 32: " + t);
}
function _i(t) {
  if (typeof t != "number")
    throw new Error("invalid uint 32: " + typeof t);
  if (!Number.isInteger(t) || t > GT || t < 0)
    throw new Error("invalid uint 32: " + t);
}
function fd(t) {
  if (typeof t != "number")
    throw new Error("invalid float 32: " + typeof t);
  if (Number.isFinite(t) && (t > zT || t < qT))
    throw new Error("invalid float 32: " + t);
}
const Hg = {
  writeUnknownFields: !0,
  writerFactory: () => new _T()
};
function VT(t) {
  return t ? Object.assign(Object.assign({}, Hg), t) : Hg;
}
class _T {
  constructor(e) {
    this.stack = [], this.textEncoder = e ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let e = 0;
    for (let s = 0; s < this.chunks.length; s++)
      e += this.chunks[s].length;
    let r = new Uint8Array(e), n = 0;
    for (let s = 0; s < this.chunks.length; s++)
      r.set(this.chunks[s], n), n += this.chunks[s].length;
    return this.chunks = [], r;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let e = this.finish(), r = this.stack.pop();
    if (!r)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = r.chunks, this.buf = r.buf, this.uint32(e.byteLength), this.raw(e);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(e, r) {
    return this.uint32((e << 3 | r) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(e) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(e), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(e) {
    for (_i(e); e > 127; )
      this.buf.push(e & 127 | 128), e = e >>> 7;
    return this.buf.push(e), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(e) {
    return Ls(e), Ug(e, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(e) {
    return this.buf.push(e ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(e) {
    return this.uint32(e.byteLength), this.raw(e);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(e) {
    let r = this.textEncoder.encode(e);
    return this.uint32(r.byteLength), this.raw(r);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(e) {
    fd(e);
    let r = new Uint8Array(4);
    return new DataView(r.buffer).setFloat32(0, e, !0), this.raw(r);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(e) {
    let r = new Uint8Array(8);
    return new DataView(r.buffer).setFloat64(0, e, !0), this.raw(r);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(e) {
    _i(e);
    let r = new Uint8Array(4);
    return new DataView(r.buffer).setUint32(0, e, !0), this.raw(r);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(e) {
    Ls(e);
    let r = new Uint8Array(4);
    return new DataView(r.buffer).setInt32(0, e, !0), this.raw(r);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(e) {
    return Ls(e), e = (e << 1 ^ e >> 31) >>> 0, Ug(e, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(e) {
    let r = new Uint8Array(8), n = new DataView(r.buffer), s = Ct.from(e);
    return n.setInt32(0, s.lo, !0), n.setInt32(4, s.hi, !0), this.raw(r);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(e) {
    let r = new Uint8Array(8), n = new DataView(r.buffer), s = Ot.from(e);
    return n.setInt32(0, s.lo, !0), n.setInt32(4, s.hi, !0), this.raw(r);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(e) {
    let r = Ct.from(e);
    return Uc(r.lo, r.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(e) {
    let r = Ct.from(e), n = r.hi >> 31, s = r.lo << 1 ^ n, i = (r.hi << 1 | r.lo >>> 31) ^ n;
    return Uc(s, i, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(e) {
    let r = Ot.from(e);
    return Uc(r.lo, r.hi, this.buf), this;
  }
}
const Og = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
}, zg = {
  ignoreUnknownFields: !1
};
function WT(t) {
  return t ? Object.assign(Object.assign({}, zg), t) : zg;
}
function $T(t) {
  return t ? Object.assign(Object.assign({}, Og), t) : Og;
}
const Tr = /* @__PURE__ */ Symbol.for("protobuf-ts/message-type");
function al(t) {
  let e = !1;
  const r = [];
  for (let n = 0; n < t.length; n++) {
    let s = t.charAt(n);
    s == "_" ? e = !0 : /\d/.test(s) ? (r.push(s), e = !0) : e ? (r.push(s.toUpperCase()), e = !1) : n == 0 ? r.push(s.toLowerCase()) : r.push(s);
  }
  return r.join("");
}
var ae;
(function(t) {
  t[t.DOUBLE = 1] = "DOUBLE", t[t.FLOAT = 2] = "FLOAT", t[t.INT64 = 3] = "INT64", t[t.UINT64 = 4] = "UINT64", t[t.INT32 = 5] = "INT32", t[t.FIXED64 = 6] = "FIXED64", t[t.FIXED32 = 7] = "FIXED32", t[t.BOOL = 8] = "BOOL", t[t.STRING = 9] = "STRING", t[t.BYTES = 12] = "BYTES", t[t.UINT32 = 13] = "UINT32", t[t.SFIXED32 = 15] = "SFIXED32", t[t.SFIXED64 = 16] = "SFIXED64", t[t.SINT32 = 17] = "SINT32", t[t.SINT64 = 18] = "SINT64";
})(ae || (ae = {}));
var xr;
(function(t) {
  t[t.BIGINT = 0] = "BIGINT", t[t.STRING = 1] = "STRING", t[t.NUMBER = 2] = "NUMBER";
})(xr || (xr = {}));
var Wi;
(function(t) {
  t[t.NO = 0] = "NO", t[t.PACKED = 1] = "PACKED", t[t.UNPACKED = 2] = "UNPACKED";
})(Wi || (Wi = {}));
function XT(t) {
  var e, r, n, s;
  return t.localName = (e = t.localName) !== null && e !== void 0 ? e : al(t.name), t.jsonName = (r = t.jsonName) !== null && r !== void 0 ? r : al(t.name), t.repeat = (n = t.repeat) !== null && n !== void 0 ? n : Wi.NO, t.opt = (s = t.opt) !== null && s !== void 0 ? s : t.repeat || t.oneof ? !1 : t.kind == "message", t;
}
function ZT(t) {
  if (typeof t != "object" || t === null || !t.hasOwnProperty("oneofKind"))
    return !1;
  switch (typeof t.oneofKind) {
    case "string":
      return t[t.oneofKind] === void 0 ? !1 : Object.keys(t).length == 2;
    case "undefined":
      return Object.keys(t).length == 1;
    default:
      return !1;
  }
}
class KT {
  constructor(e) {
    var r;
    this.fields = (r = e.fields) !== null && r !== void 0 ? r : [];
  }
  prepare() {
    if (this.data)
      return;
    const e = [], r = [], n = [];
    for (let s of this.fields)
      if (s.oneof)
        n.includes(s.oneof) || (n.push(s.oneof), e.push(s.oneof), r.push(s.oneof));
      else
        switch (r.push(s.localName), s.kind) {
          case "scalar":
          case "enum":
            (!s.opt || s.repeat) && e.push(s.localName);
            break;
          case "message":
            s.repeat && e.push(s.localName);
            break;
          case "map":
            e.push(s.localName);
            break;
        }
    this.data = { req: e, known: r, oneofs: Object.values(n) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(e, r, n = !1) {
    if (r < 0)
      return !0;
    if (e == null || typeof e != "object")
      return !1;
    this.prepare();
    let s = Object.keys(e), i = this.data;
    if (s.length < i.req.length || i.req.some((o) => !s.includes(o)) || !n && s.some((o) => !i.known.includes(o)))
      return !1;
    if (r < 1)
      return !0;
    for (const o of i.oneofs) {
      const a = e[o];
      if (!ZT(a))
        return !1;
      if (a.oneofKind === void 0)
        continue;
      const A = this.fields.find((c) => c.localName === a.oneofKind);
      if (!A || !this.field(a[a.oneofKind], A, n, r))
        return !1;
    }
    for (const o of this.fields)
      if (o.oneof === void 0 && !this.field(e[o.localName], o, n, r))
        return !1;
    return !0;
  }
  field(e, r, n, s) {
    let i = r.repeat;
    switch (r.kind) {
      case "scalar":
        return e === void 0 ? r.opt : i ? this.scalars(e, r.T, s, r.L) : this.scalar(e, r.T, r.L);
      case "enum":
        return e === void 0 ? r.opt : i ? this.scalars(e, ae.INT32, s) : this.scalar(e, ae.INT32);
      case "message":
        return e === void 0 ? !0 : i ? this.messages(e, r.T(), n, s) : this.message(e, r.T(), n, s);
      case "map":
        if (typeof e != "object" || e === null)
          return !1;
        if (s < 2)
          return !0;
        if (!this.mapKeys(e, r.K, s))
          return !1;
        switch (r.V.kind) {
          case "scalar":
            return this.scalars(Object.values(e), r.V.T, s, r.V.L);
          case "enum":
            return this.scalars(Object.values(e), ae.INT32, s);
          case "message":
            return this.messages(Object.values(e), r.V.T(), n, s);
        }
        break;
    }
    return !0;
  }
  message(e, r, n, s) {
    return n ? r.isAssignable(e, s) : r.is(e, s);
  }
  messages(e, r, n, s) {
    if (!Array.isArray(e))
      return !1;
    if (s < 2)
      return !0;
    if (n) {
      for (let i = 0; i < e.length && i < s; i++)
        if (!r.isAssignable(e[i], s - 1))
          return !1;
    } else
      for (let i = 0; i < e.length && i < s; i++)
        if (!r.is(e[i], s - 1))
          return !1;
    return !0;
  }
  scalar(e, r, n) {
    let s = typeof e;
    switch (r) {
      case ae.UINT64:
      case ae.FIXED64:
      case ae.INT64:
      case ae.SFIXED64:
      case ae.SINT64:
        switch (n) {
          case xr.BIGINT:
            return s == "bigint";
          case xr.NUMBER:
            return s == "number" && !isNaN(e);
          default:
            return s == "string";
        }
      case ae.BOOL:
        return s == "boolean";
      case ae.STRING:
        return s == "string";
      case ae.BYTES:
        return e instanceof Uint8Array;
      case ae.DOUBLE:
      case ae.FLOAT:
        return s == "number" && !isNaN(e);
      default:
        return s == "number" && Number.isInteger(e);
    }
  }
  scalars(e, r, n, s) {
    if (!Array.isArray(e))
      return !1;
    if (n < 2)
      return !0;
    if (Array.isArray(e)) {
      for (let i = 0; i < e.length && i < n; i++)
        if (!this.scalar(e[i], r, s))
          return !1;
    }
    return !0;
  }
  mapKeys(e, r, n) {
    let s = Object.keys(e);
    switch (r) {
      case ae.INT32:
      case ae.FIXED32:
      case ae.SFIXED32:
      case ae.SINT32:
      case ae.UINT32:
        return this.scalars(s.slice(0, n).map((i) => parseInt(i)), r, n);
      case ae.BOOL:
        return this.scalars(s.slice(0, n).map((i) => i == "true" ? !0 : i == "false" ? !1 : i), r, n);
      default:
        return this.scalars(s, r, n, xr.STRING);
    }
  }
}
function fr(t, e) {
  switch (e) {
    case xr.BIGINT:
      return t.toBigInt();
    case xr.NUMBER:
      return t.toNumber();
    default:
      return t.toString();
  }
}
class jT {
  constructor(e) {
    this.info = e;
  }
  prepare() {
    var e;
    if (this.fMap === void 0) {
      this.fMap = {};
      const r = (e = this.info.fields) !== null && e !== void 0 ? e : [];
      for (const n of r)
        this.fMap[n.name] = n, this.fMap[n.jsonName] = n, this.fMap[n.localName] = n;
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(e, r, n) {
    if (!e) {
      let s = xI(n);
      throw (s == "number" || s == "boolean") && (s = n.toString()), new Error(`Cannot parse JSON ${s} for ${this.info.typeName}#${r}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(e, r, n) {
    this.prepare();
    const s = [];
    for (const [i, o] of Object.entries(e)) {
      const a = this.fMap[i];
      if (!a) {
        if (!n.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${i}`);
        continue;
      }
      const A = a.localName;
      let c;
      if (a.oneof) {
        if (o === null && (a.kind !== "enum" || a.T()[0] !== "google.protobuf.NullValue"))
          continue;
        if (s.includes(a.oneof))
          throw new Error(`Multiple members of the oneof group "${a.oneof}" of ${this.info.typeName} are present in JSON.`);
        s.push(a.oneof), c = r[a.oneof] = {
          oneofKind: A
        };
      } else
        c = r;
      if (a.kind == "map") {
        if (o === null)
          continue;
        this.assert(TT(o), a.name, o);
        const l = c[A];
        for (const [d, u] of Object.entries(o)) {
          this.assert(u !== null, a.name + " map value", null);
          let m;
          switch (a.V.kind) {
            case "message":
              m = a.V.T().internalJsonRead(u, n);
              break;
            case "enum":
              if (m = this.enum(a.V.T(), u, a.name, n.ignoreUnknownFields), m === !1)
                continue;
              break;
            case "scalar":
              m = this.scalar(u, a.V.T, a.V.L, a.name);
              break;
          }
          this.assert(m !== void 0, a.name + " map value", u);
          let h = d;
          a.K == ae.BOOL && (h = h == "true" ? !0 : h == "false" ? !1 : h), h = this.scalar(h, a.K, xr.STRING, a.name).toString(), l[h] = m;
        }
      } else if (a.repeat) {
        if (o === null)
          continue;
        this.assert(Array.isArray(o), a.name, o);
        const l = c[A];
        for (const d of o) {
          this.assert(d !== null, a.name, null);
          let u;
          switch (a.kind) {
            case "message":
              u = a.T().internalJsonRead(d, n);
              break;
            case "enum":
              if (u = this.enum(a.T(), d, a.name, n.ignoreUnknownFields), u === !1)
                continue;
              break;
            case "scalar":
              u = this.scalar(d, a.T, a.L, a.name);
              break;
          }
          this.assert(u !== void 0, a.name, o), l.push(u);
        }
      } else
        switch (a.kind) {
          case "message":
            if (o === null && a.T().typeName != "google.protobuf.Value") {
              this.assert(a.oneof === void 0, a.name + " (oneof member)", null);
              continue;
            }
            c[A] = a.T().internalJsonRead(o, n, c[A]);
            break;
          case "enum":
            if (o === null)
              continue;
            let l = this.enum(a.T(), o, a.name, n.ignoreUnknownFields);
            if (l === !1)
              continue;
            c[A] = l;
            break;
          case "scalar":
            if (o === null)
              continue;
            c[A] = this.scalar(o, a.T, a.L, a.name);
            break;
        }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(e, r, n, s) {
    if (e[0] == "google.protobuf.NullValue" && nt(r === null || r === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${n}, enum ${e[0]} only accepts null.`), r === null)
      return 0;
    switch (typeof r) {
      case "number":
        return nt(Number.isInteger(r), `Unable to parse field ${this.info.typeName}#${n}, enum can only be integral number, got ${r}.`), r;
      case "string":
        let i = r;
        e[2] && r.substring(0, e[2].length) === e[2] && (i = r.substring(e[2].length));
        let o = e[1][i];
        return typeof o > "u" && s ? !1 : (nt(typeof o == "number", `Unable to parse field ${this.info.typeName}#${n}, enum ${e[0]} has no value for "${r}".`), o);
    }
    nt(!1, `Unable to parse field ${this.info.typeName}#${n}, cannot parse enum value from ${typeof r}".`);
  }
  scalar(e, r, n, s) {
    let i;
    try {
      switch (r) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ae.DOUBLE:
        case ae.FLOAT:
          if (e === null)
            return 0;
          if (e === "NaN")
            return Number.NaN;
          if (e === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (e === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (e === "") {
            i = "empty string";
            break;
          }
          if (typeof e == "string" && e.trim().length !== e.length) {
            i = "extra whitespace";
            break;
          }
          if (typeof e != "string" && typeof e != "number")
            break;
          let o = Number(e);
          if (Number.isNaN(o)) {
            i = "not a number";
            break;
          }
          if (!Number.isFinite(o)) {
            i = "too large or small";
            break;
          }
          return r == ae.FLOAT && fd(o), o;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ae.INT32:
        case ae.FIXED32:
        case ae.SFIXED32:
        case ae.SINT32:
        case ae.UINT32:
          if (e === null)
            return 0;
          let a;
          if (typeof e == "number" ? a = e : e === "" ? i = "empty string" : typeof e == "string" && (e.trim().length !== e.length ? i = "extra whitespace" : a = Number(e)), a === void 0)
            break;
          return r == ae.UINT32 ? _i(a) : Ls(a), a;
        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
        case ae.INT64:
        case ae.SFIXED64:
        case ae.SINT64:
          if (e === null)
            return fr(Ct.ZERO, n);
          if (typeof e != "number" && typeof e != "string")
            break;
          return fr(Ct.from(e), n);
        case ae.FIXED64:
        case ae.UINT64:
          if (e === null)
            return fr(Ot.ZERO, n);
          if (typeof e != "number" && typeof e != "string")
            break;
          return fr(Ot.from(e), n);
        // bool:
        case ae.BOOL:
          if (e === null)
            return !1;
          if (typeof e != "boolean")
            break;
          return e;
        // string:
        case ae.STRING:
          if (e === null)
            return "";
          if (typeof e != "string") {
            i = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(e);
          } catch (A) {
            A = "invalid UTF8";
            break;
          }
          return e;
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ae.BYTES:
          if (e === null || e === "")
            return new Uint8Array(0);
          if (typeof e != "string")
            break;
          return FT(e);
      }
    } catch (o) {
      i = o.message;
    }
    this.assert(!1, s + (i ? " - " + i : ""), e);
  }
}
class eF {
  constructor(e) {
    var r;
    this.fields = (r = e.fields) !== null && r !== void 0 ? r : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(e, r) {
    const n = {}, s = e;
    for (const i of this.fields) {
      if (!i.oneof) {
        let c = this.field(i, s[i.localName], r);
        c !== void 0 && (n[r.useProtoFieldName ? i.name : i.jsonName] = c);
        continue;
      }
      const o = s[i.oneof];
      if (o.oneofKind !== i.localName)
        continue;
      const a = i.kind == "scalar" || i.kind == "enum" ? Object.assign(Object.assign({}, r), { emitDefaultValues: !0 }) : r;
      let A = this.field(i, o[i.localName], a);
      nt(A !== void 0), n[r.useProtoFieldName ? i.name : i.jsonName] = A;
    }
    return n;
  }
  field(e, r, n) {
    let s;
    if (e.kind == "map") {
      nt(typeof r == "object" && r !== null);
      const i = {};
      switch (e.V.kind) {
        case "scalar":
          for (const [A, c] of Object.entries(r)) {
            const l = this.scalar(e.V.T, c, e.name, !1, !0);
            nt(l !== void 0), i[A.toString()] = l;
          }
          break;
        case "message":
          const o = e.V.T();
          for (const [A, c] of Object.entries(r)) {
            const l = this.message(o, c, e.name, n);
            nt(l !== void 0), i[A.toString()] = l;
          }
          break;
        case "enum":
          const a = e.V.T();
          for (const [A, c] of Object.entries(r)) {
            nt(c === void 0 || typeof c == "number");
            const l = this.enum(a, c, e.name, !1, !0, n.enumAsInteger);
            nt(l !== void 0), i[A.toString()] = l;
          }
          break;
      }
      (n.emitDefaultValues || Object.keys(i).length > 0) && (s = i);
    } else if (e.repeat) {
      nt(Array.isArray(r));
      const i = [];
      switch (e.kind) {
        case "scalar":
          for (let A = 0; A < r.length; A++) {
            const c = this.scalar(e.T, r[A], e.name, e.opt, !0);
            nt(c !== void 0), i.push(c);
          }
          break;
        case "enum":
          const o = e.T();
          for (let A = 0; A < r.length; A++) {
            nt(r[A] === void 0 || typeof r[A] == "number");
            const c = this.enum(o, r[A], e.name, e.opt, !0, n.enumAsInteger);
            nt(c !== void 0), i.push(c);
          }
          break;
        case "message":
          const a = e.T();
          for (let A = 0; A < r.length; A++) {
            const c = this.message(a, r[A], e.name, n);
            nt(c !== void 0), i.push(c);
          }
          break;
      }
      (n.emitDefaultValues || i.length > 0 || n.emitDefaultValues) && (s = i);
    } else
      switch (e.kind) {
        case "scalar":
          s = this.scalar(e.T, r, e.name, e.opt, n.emitDefaultValues);
          break;
        case "enum":
          s = this.enum(e.T(), r, e.name, e.opt, n.emitDefaultValues, n.enumAsInteger);
          break;
        case "message":
          s = this.message(e.T(), r, e.name, n);
          break;
      }
    return s;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(e, r, n, s, i, o) {
    if (e[0] == "google.protobuf.NullValue")
      return !i && !s ? void 0 : null;
    if (r === void 0) {
      nt(s);
      return;
    }
    if (!(r === 0 && !i && !s))
      return nt(typeof r == "number"), nt(Number.isInteger(r)), o || !e[1].hasOwnProperty(r) ? r : e[2] ? e[2] + e[1][r] : e[1][r];
  }
  message(e, r, n, s) {
    return r === void 0 ? s.emitDefaultValues ? null : void 0 : e.internalJsonWrite(r, s);
  }
  scalar(e, r, n, s, i) {
    if (r === void 0) {
      nt(s);
      return;
    }
    const o = i || s;
    switch (e) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ae.INT32:
      case ae.SFIXED32:
      case ae.SINT32:
        return r === 0 ? o ? 0 : void 0 : (Ls(r), r);
      case ae.FIXED32:
      case ae.UINT32:
        return r === 0 ? o ? 0 : void 0 : (_i(r), r);
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ae.FLOAT:
        fd(r);
      case ae.DOUBLE:
        return r === 0 ? o ? 0 : void 0 : (nt(typeof r == "number"), Number.isNaN(r) ? "NaN" : r === Number.POSITIVE_INFINITY ? "Infinity" : r === Number.NEGATIVE_INFINITY ? "-Infinity" : r);
      // string:
      case ae.STRING:
        return r === "" ? o ? "" : void 0 : (nt(typeof r == "string"), r);
      // bool:
      case ae.BOOL:
        return r === !1 ? o ? !1 : void 0 : (nt(typeof r == "boolean"), r);
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ae.UINT64:
      case ae.FIXED64:
        nt(typeof r == "number" || typeof r == "string" || typeof r == "bigint");
        let a = Ot.from(r);
        return a.isZero() && !o ? void 0 : a.toString();
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ae.INT64:
      case ae.SFIXED64:
      case ae.SINT64:
        nt(typeof r == "number" || typeof r == "string" || typeof r == "bigint");
        let A = Ct.from(r);
        return A.isZero() && !o ? void 0 : A.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ae.BYTES:
        return nt(r instanceof Uint8Array), r.byteLength ? vT(r) : o ? "" : void 0;
    }
  }
}
function Al(t, e = xr.STRING) {
  switch (t) {
    case ae.BOOL:
      return !1;
    case ae.UINT64:
    case ae.FIXED64:
      return fr(Ot.ZERO, e);
    case ae.INT64:
    case ae.SFIXED64:
    case ae.SINT64:
      return fr(Ct.ZERO, e);
    case ae.DOUBLE:
    case ae.FLOAT:
      return 0;
    case ae.BYTES:
      return new Uint8Array(0);
    case ae.STRING:
      return "";
    default:
      return 0;
  }
}
class tF {
  constructor(e) {
    this.info = e;
  }
  prepare() {
    var e;
    if (!this.fieldNoToField) {
      const r = (e = this.info.fields) !== null && e !== void 0 ? e : [];
      this.fieldNoToField = new Map(r.map((n) => [n.no, n]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(e, r, n, s) {
    this.prepare();
    const i = s === void 0 ? e.len : e.pos + s;
    for (; e.pos < i; ) {
      const [o, a] = e.tag(), A = this.fieldNoToField.get(o);
      if (!A) {
        let u = n.readUnknownField;
        if (u == "throw")
          throw new Error(`Unknown field ${o} (wire type ${a}) for ${this.info.typeName}`);
        let m = e.skip(a);
        u !== !1 && (u === !0 ? Nt.onRead : u)(this.info.typeName, r, o, a, m);
        continue;
      }
      let c = r, l = A.repeat, d = A.localName;
      switch (A.oneof && (c = c[A.oneof], c.oneofKind !== d && (c = r[A.oneof] = {
        oneofKind: d
      })), A.kind) {
        case "scalar":
        case "enum":
          let u = A.kind == "enum" ? ae.INT32 : A.T, m = A.kind == "scalar" ? A.L : void 0;
          if (l) {
            let p = c[d];
            if (a == Oe.LengthDelimited && u != ae.STRING && u != ae.BYTES) {
              let y = e.uint32() + e.pos;
              for (; e.pos < y; )
                p.push(this.scalar(e, u, m));
            } else
              p.push(this.scalar(e, u, m));
          } else
            c[d] = this.scalar(e, u, m);
          break;
        case "message":
          if (l) {
            let p = c[d], y = A.T().internalBinaryRead(e, e.uint32(), n);
            p.push(y);
          } else
            c[d] = A.T().internalBinaryRead(e, e.uint32(), n, c[d]);
          break;
        case "map":
          let [h, f] = this.mapEntry(A, e, n);
          c[d][h] = f;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(e, r, n) {
    let s = r.uint32(), i = r.pos + s, o, a;
    for (; r.pos < i; ) {
      let [A, c] = r.tag();
      switch (A) {
        case 1:
          e.K == ae.BOOL ? o = r.bool().toString() : o = this.scalar(r, e.K, xr.STRING);
          break;
        case 2:
          switch (e.V.kind) {
            case "scalar":
              a = this.scalar(r, e.V.T, e.V.L);
              break;
            case "enum":
              a = r.int32();
              break;
            case "message":
              a = e.V.T().internalBinaryRead(r, r.uint32(), n);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${A} (wire type ${c}) in map entry for ${this.info.typeName}#${e.name}`);
      }
    }
    if (o === void 0) {
      let A = Al(e.K);
      o = e.K == ae.BOOL ? A.toString() : A;
    }
    if (a === void 0)
      switch (e.V.kind) {
        case "scalar":
          a = Al(e.V.T, e.V.L);
          break;
        case "enum":
          a = 0;
          break;
        case "message":
          a = e.V.T().create();
          break;
      }
    return [o, a];
  }
  scalar(e, r, n) {
    switch (r) {
      case ae.INT32:
        return e.int32();
      case ae.STRING:
        return e.string();
      case ae.BOOL:
        return e.bool();
      case ae.DOUBLE:
        return e.double();
      case ae.FLOAT:
        return e.float();
      case ae.INT64:
        return fr(e.int64(), n);
      case ae.UINT64:
        return fr(e.uint64(), n);
      case ae.FIXED64:
        return fr(e.fixed64(), n);
      case ae.FIXED32:
        return e.fixed32();
      case ae.BYTES:
        return e.bytes();
      case ae.UINT32:
        return e.uint32();
      case ae.SFIXED32:
        return e.sfixed32();
      case ae.SFIXED64:
        return fr(e.sfixed64(), n);
      case ae.SINT32:
        return e.sint32();
      case ae.SINT64:
        return fr(e.sint64(), n);
    }
  }
}
class rF {
  constructor(e) {
    this.info = e;
  }
  prepare() {
    if (!this.fields) {
      const e = this.info.fields ? this.info.fields.concat() : [];
      this.fields = e.sort((r, n) => r.no - n.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(e, r, n) {
    this.prepare();
    for (const i of this.fields) {
      let o, a, A = i.repeat, c = i.localName;
      if (i.oneof) {
        const l = e[i.oneof];
        if (l.oneofKind !== c)
          continue;
        o = l[c], a = !0;
      } else
        o = e[c], a = !1;
      switch (i.kind) {
        case "scalar":
        case "enum":
          let l = i.kind == "enum" ? ae.INT32 : i.T;
          if (A)
            if (nt(Array.isArray(o)), A == Wi.PACKED)
              this.packed(r, l, i.no, o);
            else
              for (const d of o)
                this.scalar(r, l, i.no, d, !0);
          else o === void 0 ? nt(i.opt) : this.scalar(r, l, i.no, o, a || i.opt);
          break;
        case "message":
          if (A) {
            nt(Array.isArray(o));
            for (const d of o)
              this.message(r, n, i.T(), i.no, d);
          } else
            this.message(r, n, i.T(), i.no, o);
          break;
        case "map":
          nt(typeof o == "object" && o !== null);
          for (const [d, u] of Object.entries(o))
            this.mapEntry(r, n, i, d, u);
          break;
      }
    }
    let s = n.writeUnknownFields;
    s !== !1 && (s === !0 ? Nt.onWrite : s)(this.info.typeName, e, r);
  }
  mapEntry(e, r, n, s, i) {
    e.tag(n.no, Oe.LengthDelimited), e.fork();
    let o = s;
    switch (n.K) {
      case ae.INT32:
      case ae.FIXED32:
      case ae.UINT32:
      case ae.SFIXED32:
      case ae.SINT32:
        o = Number.parseInt(s);
        break;
      case ae.BOOL:
        nt(s == "true" || s == "false"), o = s == "true";
        break;
    }
    switch (this.scalar(e, n.K, 1, o, !0), n.V.kind) {
      case "scalar":
        this.scalar(e, n.V.T, 2, i, !0);
        break;
      case "enum":
        this.scalar(e, ae.INT32, 2, i, !0);
        break;
      case "message":
        this.message(e, r, n.V.T(), 2, i);
        break;
    }
    e.join();
  }
  message(e, r, n, s, i) {
    i !== void 0 && (n.internalBinaryWrite(i, e.tag(s, Oe.LengthDelimited).fork(), r), e.join());
  }
  /**
   * Write a single scalar value.
   */
  scalar(e, r, n, s, i) {
    let [o, a, A] = this.scalarInfo(r, s);
    (!A || i) && (e.tag(n, o), e[a](s));
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(e, r, n, s) {
    if (!s.length)
      return;
    nt(r !== ae.BYTES && r !== ae.STRING), e.tag(n, Oe.LengthDelimited), e.fork();
    let [, i] = this.scalarInfo(r);
    for (let o = 0; o < s.length; o++)
      e[i](s[o]);
    e.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(e, r) {
    let n = Oe.Varint, s, i = r === void 0, o = r === 0;
    switch (e) {
      case ae.INT32:
        s = "int32";
        break;
      case ae.STRING:
        o = i || !r.length, n = Oe.LengthDelimited, s = "string";
        break;
      case ae.BOOL:
        o = r === !1, s = "bool";
        break;
      case ae.UINT32:
        s = "uint32";
        break;
      case ae.DOUBLE:
        n = Oe.Bit64, s = "double";
        break;
      case ae.FLOAT:
        n = Oe.Bit32, s = "float";
        break;
      case ae.INT64:
        o = i || Ct.from(r).isZero(), s = "int64";
        break;
      case ae.UINT64:
        o = i || Ot.from(r).isZero(), s = "uint64";
        break;
      case ae.FIXED64:
        o = i || Ot.from(r).isZero(), n = Oe.Bit64, s = "fixed64";
        break;
      case ae.BYTES:
        o = i || !r.byteLength, n = Oe.LengthDelimited, s = "bytes";
        break;
      case ae.FIXED32:
        n = Oe.Bit32, s = "fixed32";
        break;
      case ae.SFIXED32:
        n = Oe.Bit32, s = "sfixed32";
        break;
      case ae.SFIXED64:
        o = i || Ct.from(r).isZero(), n = Oe.Bit64, s = "sfixed64";
        break;
      case ae.SINT32:
        s = "sint32";
        break;
      case ae.SINT64:
        o = i || Ct.from(r).isZero(), s = "sint64";
        break;
    }
    return [n, s, i || o];
  }
}
function nF(t) {
  const e = t.messagePrototype ? Object.create(t.messagePrototype) : Object.defineProperty({}, Tr, { value: t });
  for (let r of t.fields) {
    let n = r.localName;
    if (!r.opt)
      if (r.oneof)
        e[r.oneof] = { oneofKind: void 0 };
      else if (r.repeat)
        e[n] = [];
      else
        switch (r.kind) {
          case "scalar":
            e[n] = Al(r.T, r.L);
            break;
          case "enum":
            e[n] = 0;
            break;
          case "map":
            e[n] = {};
            break;
        }
  }
  return e;
}
function pr(t, e, r) {
  let n, s = r, i;
  for (let o of t.fields) {
    let a = o.localName;
    if (o.oneof) {
      const A = s[o.oneof];
      if (A?.oneofKind == null)
        continue;
      if (n = A[a], i = e[o.oneof], i.oneofKind = A.oneofKind, n == null) {
        delete i[a];
        continue;
      }
    } else if (n = s[a], i = e, n == null)
      continue;
    switch (o.repeat && (i[a].length = n.length), o.kind) {
      case "scalar":
      case "enum":
        if (o.repeat)
          for (let c = 0; c < n.length; c++)
            i[a][c] = n[c];
        else
          i[a] = n;
        break;
      case "message":
        let A = o.T();
        if (o.repeat)
          for (let c = 0; c < n.length; c++)
            i[a][c] = A.create(n[c]);
        else i[a] === void 0 ? i[a] = A.create(n) : A.mergePartial(i[a], n);
        break;
      case "map":
        switch (o.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(i[a], n);
            break;
          case "message":
            let c = o.V.T();
            for (let l of Object.keys(n))
              i[a][l] = c.create(n[l]);
            break;
        }
        break;
    }
  }
}
function sF(t, e, r) {
  if (e === r)
    return !0;
  if (!e || !r)
    return !1;
  for (let n of t.fields) {
    let s = n.localName, i = n.oneof ? e[n.oneof][s] : e[s], o = n.oneof ? r[n.oneof][s] : r[s];
    switch (n.kind) {
      case "enum":
      case "scalar":
        let a = n.kind == "enum" ? ae.INT32 : n.T;
        if (!(n.repeat ? qg(a, i, o) : MI(a, i, o)))
          return !1;
        break;
      case "map":
        if (!(n.V.kind == "message" ? Gg(n.V.T(), Si(i), Si(o)) : qg(n.V.kind == "enum" ? ae.INT32 : n.V.T, Si(i), Si(o))))
          return !1;
        break;
      case "message":
        let A = n.T();
        if (!(n.repeat ? Gg(A, i, o) : A.equals(i, o)))
          return !1;
        break;
    }
  }
  return !0;
}
const Si = Object.values;
function MI(t, e, r) {
  if (e === r)
    return !0;
  if (t !== ae.BYTES)
    return !1;
  let n = e, s = r;
  if (n.length !== s.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (n[i] != s[i])
      return !1;
  return !0;
}
function qg(t, e, r) {
  if (e.length !== r.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!MI(t, e[n], r[n]))
      return !1;
  return !0;
}
function Gg(t, e, r) {
  if (e.length !== r.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!t.equals(e[n], r[n]))
      return !1;
  return !0;
}
const TI = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({})), iF = TI[Tr] = {};
class An {
  constructor(e, r, n) {
    this.defaultCheckDepth = 16, this.typeName = e, this.fields = r.map(XT), this.options = n ?? {}, iF.value = this, this.messagePrototype = Object.create(null, TI), this.refTypeCheck = new KT(this), this.refJsonReader = new jT(this), this.refJsonWriter = new eF(this), this.refBinReader = new tF(this), this.refBinWriter = new rF(this);
  }
  create(e) {
    let r = nF(this);
    return e !== void 0 && pr(this, r, e), r;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(e) {
    let r = this.create();
    return pr(this, r, e), r;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(e, r) {
    return sF(this, e, r);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(e, r = this.defaultCheckDepth) {
    return this.refTypeCheck.is(e, r, !1);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(e, r = this.defaultCheckDepth) {
    return this.refTypeCheck.is(e, r, !0);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(e, r) {
    pr(this, e, r);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(e, r) {
    let n = HT(r);
    return this.internalBinaryRead(n.readerFactory(e), e.byteLength, n);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(e, r) {
    return this.internalJsonRead(e, WT(r));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(e, r) {
    let n = JSON.parse(e);
    return this.fromJson(n, r);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(e, r) {
    return this.internalJsonWrite(e, $T(r));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(e, r) {
    var n;
    let s = this.toJson(e, r);
    return JSON.stringify(s, null, (n = r?.prettySpaces) !== null && n !== void 0 ? n : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(e, r) {
    let n = VT(r);
    return this.internalBinaryWrite(e, n.writerFactory(), n).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(e, r, n) {
    if (e !== null && typeof e == "object" && !Array.isArray(e)) {
      let s = n ?? this.create();
      return this.refJsonReader.read(e, s, r), s;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${xI(e)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(e, r) {
    return this.refJsonWriter.write(e, r);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(e, r, n) {
    return this.refBinWriter.write(e, r, n), r;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create();
    return this.refBinReader.read(e, i, n, r), i;
  }
}
function oF(t, e) {
  var r, n, s;
  let i = t;
  return i.service = e, i.localName = (r = i.localName) !== null && r !== void 0 ? r : al(i.name), i.serverStreaming = !!i.serverStreaming, i.clientStreaming = !!i.clientStreaming, i.options = (n = i.options) !== null && n !== void 0 ? n : {}, i.idempotency = (s = i.idempotency) !== null && s !== void 0 ? s : void 0, i;
}
class aF {
  constructor(e, r, n) {
    this.typeName = e, this.methods = r.map((s) => oF(s, this)), this.options = n ?? {};
  }
}
class AF extends An {
  constructor() {
    super("github.actions.results.entities.v1.CacheScope", [
      {
        no: 1,
        name: "scope",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "permission",
        kind: "scalar",
        T: 3
        /*ScalarType.INT64*/
      }
    ]);
  }
  create(e) {
    const r = { scope: "", permission: "0" };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* string scope */
        1:
          i.scope = e.string();
          break;
        case /* int64 permission */
        2:
          i.permission = e.int64().toString();
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.scope !== "" && r.tag(1, Oe.LengthDelimited).string(e.scope), e.permission !== "0" && r.tag(2, Oe.Varint).int64(e.permission);
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const Pc = new AF();
class cF extends An {
  constructor() {
    super("github.actions.results.entities.v1.CacheMetadata", [
      {
        no: 1,
        name: "repository_id",
        kind: "scalar",
        T: 3
        /*ScalarType.INT64*/
      },
      { no: 2, name: "scope", kind: "message", repeat: 1, T: () => Pc }
    ]);
  }
  create(e) {
    const r = { repositoryId: "0", scope: [] };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* int64 repository_id */
        1:
          i.repositoryId = e.int64().toString();
          break;
        case /* repeated github.actions.results.entities.v1.CacheScope scope */
        2:
          i.scope.push(Pc.internalBinaryRead(e, e.uint32(), n));
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.repositoryId !== "0" && r.tag(1, Oe.Varint).int64(e.repositoryId);
    for (let i = 0; i < e.scope.length; i++)
      Pc.internalBinaryWrite(e.scope[i], r.tag(2, Oe.LengthDelimited).fork(), n).join();
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const Or = new cF();
class lF extends An {
  constructor() {
    super("github.actions.results.api.v1.CreateCacheEntryRequest", [
      { no: 1, name: "metadata", kind: "message", T: () => Or },
      {
        no: 2,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(e) {
    const r = { key: "", version: "" };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* github.actions.results.entities.v1.CacheMetadata metadata */
        1:
          i.metadata = Or.internalBinaryRead(e, e.uint32(), n, i.metadata);
          break;
        case /* string key */
        2:
          i.key = e.string();
          break;
        case /* string version */
        3:
          i.version = e.string();
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.metadata && Or.internalBinaryWrite(e.metadata, r.tag(1, Oe.LengthDelimited).fork(), n).join(), e.key !== "" && r.tag(2, Oe.LengthDelimited).string(e.key), e.version !== "" && r.tag(3, Oe.LengthDelimited).string(e.version);
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const FI = new lF();
class dF extends An {
  constructor() {
    super("github.actions.results.api.v1.CreateCacheEntryResponse", [
      {
        no: 1,
        name: "ok",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "signed_upload_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(e) {
    const r = { ok: !1, signedUploadUrl: "", message: "" };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* bool ok */
        1:
          i.ok = e.bool();
          break;
        case /* string signed_upload_url */
        2:
          i.signedUploadUrl = e.string();
          break;
        case /* string message */
        3:
          i.message = e.string();
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.ok !== !1 && r.tag(1, Oe.Varint).bool(e.ok), e.signedUploadUrl !== "" && r.tag(2, Oe.LengthDelimited).string(e.signedUploadUrl), e.message !== "" && r.tag(3, Oe.LengthDelimited).string(e.message);
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const vI = new dF();
class uF extends An {
  constructor() {
    super("github.actions.results.api.v1.FinalizeCacheEntryUploadRequest", [
      { no: 1, name: "metadata", kind: "message", T: () => Or },
      {
        no: 2,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "size_bytes",
        kind: "scalar",
        T: 3
        /*ScalarType.INT64*/
      },
      {
        no: 4,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(e) {
    const r = { key: "", sizeBytes: "0", version: "" };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* github.actions.results.entities.v1.CacheMetadata metadata */
        1:
          i.metadata = Or.internalBinaryRead(e, e.uint32(), n, i.metadata);
          break;
        case /* string key */
        2:
          i.key = e.string();
          break;
        case /* int64 size_bytes */
        3:
          i.sizeBytes = e.int64().toString();
          break;
        case /* string version */
        4:
          i.version = e.string();
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.metadata && Or.internalBinaryWrite(e.metadata, r.tag(1, Oe.LengthDelimited).fork(), n).join(), e.key !== "" && r.tag(2, Oe.LengthDelimited).string(e.key), e.sizeBytes !== "0" && r.tag(3, Oe.Varint).int64(e.sizeBytes), e.version !== "" && r.tag(4, Oe.LengthDelimited).string(e.version);
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const LI = new uF();
class mF extends An {
  constructor() {
    super("github.actions.results.api.v1.FinalizeCacheEntryUploadResponse", [
      {
        no: 1,
        name: "ok",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "entry_id",
        kind: "scalar",
        T: 3
        /*ScalarType.INT64*/
      },
      {
        no: 3,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(e) {
    const r = { ok: !1, entryId: "0", message: "" };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* bool ok */
        1:
          i.ok = e.bool();
          break;
        case /* int64 entry_id */
        2:
          i.entryId = e.int64().toString();
          break;
        case /* string message */
        3:
          i.message = e.string();
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.ok !== !1 && r.tag(1, Oe.Varint).bool(e.ok), e.entryId !== "0" && r.tag(2, Oe.Varint).int64(e.entryId), e.message !== "" && r.tag(3, Oe.LengthDelimited).string(e.message);
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const UI = new mF();
class hF extends An {
  constructor() {
    super("github.actions.results.api.v1.GetCacheEntryDownloadURLRequest", [
      { no: 1, name: "metadata", kind: "message", T: () => Or },
      {
        no: 2,
        name: "key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "restore_keys",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(e) {
    const r = { key: "", restoreKeys: [], version: "" };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* github.actions.results.entities.v1.CacheMetadata metadata */
        1:
          i.metadata = Or.internalBinaryRead(e, e.uint32(), n, i.metadata);
          break;
        case /* string key */
        2:
          i.key = e.string();
          break;
        case /* repeated string restore_keys */
        3:
          i.restoreKeys.push(e.string());
          break;
        case /* string version */
        4:
          i.version = e.string();
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.metadata && Or.internalBinaryWrite(e.metadata, r.tag(1, Oe.LengthDelimited).fork(), n).join(), e.key !== "" && r.tag(2, Oe.LengthDelimited).string(e.key);
    for (let i = 0; i < e.restoreKeys.length; i++)
      r.tag(3, Oe.LengthDelimited).string(e.restoreKeys[i]);
    e.version !== "" && r.tag(4, Oe.LengthDelimited).string(e.version);
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const PI = new hF();
class gF extends An {
  constructor() {
    super("github.actions.results.api.v1.GetCacheEntryDownloadURLResponse", [
      {
        no: 1,
        name: "ok",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "signed_download_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "matched_key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(e) {
    const r = { ok: !1, signedDownloadUrl: "", matchedKey: "" };
    return globalThis.Object.defineProperty(r, Tr, { enumerable: !1, value: this }), e !== void 0 && pr(this, r, e), r;
  }
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create(), o = e.pos + r;
    for (; e.pos < o; ) {
      let [a, A] = e.tag();
      switch (a) {
        case /* bool ok */
        1:
          i.ok = e.bool();
          break;
        case /* string signed_download_url */
        2:
          i.signedDownloadUrl = e.string();
          break;
        case /* string matched_key */
        3:
          i.matchedKey = e.string();
          break;
        default:
          let c = n.readUnknownField;
          if (c === "throw")
            throw new globalThis.Error(`Unknown field ${a} (wire type ${A}) for ${this.typeName}`);
          let l = e.skip(A);
          c !== !1 && (c === !0 ? Nt.onRead : c)(this.typeName, i, a, A, l);
      }
    }
    return i;
  }
  internalBinaryWrite(e, r, n) {
    e.ok !== !1 && r.tag(1, Oe.Varint).bool(e.ok), e.signedDownloadUrl !== "" && r.tag(2, Oe.LengthDelimited).string(e.signedDownloadUrl), e.matchedKey !== "" && r.tag(3, Oe.LengthDelimited).string(e.matchedKey);
    let s = n.writeUnknownFields;
    return s !== !1 && (s == !0 ? Nt.onWrite : s)(this.typeName, e, r), r;
  }
}
const HI = new gF();
new aF("github.actions.results.api.v1.CacheService", [
  { name: "CreateCacheEntry", options: {}, I: FI, O: vI },
  { name: "FinalizeCacheEntryUpload", options: {}, I: LI, O: UI },
  { name: "GetCacheEntryDownloadURL", options: {}, I: PI, O: HI }
]);
class fF {
  constructor(e) {
    this.rpc = e, this.CreateCacheEntry.bind(this), this.FinalizeCacheEntryUpload.bind(this), this.GetCacheEntryDownloadURL.bind(this);
  }
  CreateCacheEntry(e) {
    const r = FI.toJson(e, {
      useProtoFieldName: !0,
      emitDefaultValues: !1
    });
    return this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/json", r).then((s) => vI.fromJson(s, {
      ignoreUnknownFields: !0
    }));
  }
  FinalizeCacheEntryUpload(e) {
    const r = LI.toJson(e, {
      useProtoFieldName: !0,
      emitDefaultValues: !1
    });
    return this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/json", r).then((s) => UI.fromJson(s, {
      ignoreUnknownFields: !0
    }));
  }
  GetCacheEntryDownloadURL(e) {
    const r = PI.toJson(e, {
      useProtoFieldName: !0,
      emitDefaultValues: !1
    });
    return this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/json", r).then((s) => HI.fromJson(s, {
      ignoreUnknownFields: !0
    }));
  }
}
function Yg(t) {
  if (t)
    try {
      const r = new URL(t).searchParams.get("sig");
      r && (Li(r), Li(encodeURIComponent(r)));
    } catch (e) {
      le(`Failed to parse URL: ${t} ${e instanceof Error ? e.message : String(e)}`);
    }
}
function pF(t) {
  if (typeof t != "object" || t === null) {
    le("body is not an object or is null");
    return;
  }
  "signed_upload_url" in t && typeof t.signed_upload_url == "string" && Yg(t.signed_upload_url), "signed_download_url" in t && typeof t.signed_download_url == "string" && Yg(t.signed_download_url);
}
var Di = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
class EF {
  constructor(e, r, n, s) {
    this.maxAttempts = 5, this.baseRetryIntervalMilliseconds = 3e3, this.retryMultiplier = 1.5;
    const i = JN();
    this.baseUrl = QI(), r && (this.maxAttempts = r), n && (this.baseRetryIntervalMilliseconds = n), s && (this.retryMultiplier = s), this.httpClient = new Kn(e, [
      new Cf(i)
    ]);
  }
  // This function satisfies the Rpc interface. It is compatible with the JSON
  // JSON generated client.
  request(e, r, n, s) {
    return Di(this, void 0, void 0, function* () {
      const i = new URL(`/twirp/${e}/${r}`, this.baseUrl).href;
      le(`[Request] ${r} ${i}`);
      const o = {
        "Content-Type": n
      };
      try {
        const { body: a } = yield this.retryableRequest(() => Di(this, void 0, void 0, function* () {
          return this.httpClient.post(i, JSON.stringify(s), o);
        }));
        return a;
      } catch (a) {
        throw new Error(`Failed to ${r}: ${a.message}`);
      }
    });
  }
  retryableRequest(e) {
    return Di(this, void 0, void 0, function* () {
      let r = 0, n = "", s = "";
      for (; r < this.maxAttempts; ) {
        let i = !1;
        try {
          const a = yield e(), A = a.message.statusCode;
          s = yield a.readBody(), le(`[Response] - ${a.message.statusCode}`), le(`Headers: ${JSON.stringify(a.message.headers, null, 2)}`);
          const c = JSON.parse(s);
          if (pF(c), le(`Body: ${JSON.stringify(c, null, 2)}`), this.isSuccessStatusCode(A))
            return { response: a, body: c };
          if (i = this.isRetryableHttpStatusCode(A), n = `Failed request: (${A}) ${a.message.statusMessage}`, c.msg) {
            if (Ti.isUsageErrorMessage(c.msg))
              throw new Ti();
            n = `${n}: ${c.msg}`;
          }
          if (A === Qt.TooManyRequests) {
            const l = a.message.headers["retry-after"];
            if (l) {
              const d = parseInt(l, 10);
              !isNaN(d) && d > 0 && Hr(`You've hit a rate limit, your rate limit will reset in ${d} seconds`);
            }
            throw new Fg(`Rate limited: ${n}`);
          }
        } catch (a) {
          if (a instanceof SyntaxError && le(`Raw Body: ${s}`), a instanceof Ti || a instanceof Fg)
            throw a;
          if (sl.isNetworkErrorCode(a?.code))
            throw new sl(a?.code);
          i = !0, n = a.message;
        }
        if (!i)
          throw new Error(`Received non-retryable error: ${n}`);
        if (r + 1 === this.maxAttempts)
          throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${n}`);
        const o = this.getExponentialRetryTimeMilliseconds(r);
        xt(`Attempt ${r + 1} of ${this.maxAttempts} failed with error: ${n}. Retrying request in ${o} ms...`), yield this.sleep(o), r++;
      }
      throw new Error("Request failed");
    });
  }
  isSuccessStatusCode(e) {
    return e ? e >= 200 && e < 300 : !1;
  }
  isRetryableHttpStatusCode(e) {
    return e ? [
      Qt.BadGateway,
      Qt.GatewayTimeout,
      Qt.InternalServerError,
      Qt.ServiceUnavailable
    ].includes(e) : !1;
  }
  sleep(e) {
    return Di(this, void 0, void 0, function* () {
      return new Promise((r) => setTimeout(r, e));
    });
  }
  getExponentialRetryTimeMilliseconds(e) {
    if (e < 0)
      throw new Error("attempt should be a positive integer");
    if (e === 0)
      return this.baseRetryIntervalMilliseconds;
    const r = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, e), n = r * this.retryMultiplier;
    return Math.trunc(Math.random() * (n - r) + r);
  }
}
function OI(t) {
  const e = new EF(NI(), void 0, void 0, void 0);
  return new fF(e);
}
var Yr = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
const Xr = process.platform === "win32";
function CF() {
  return Yr(this, void 0, void 0, function* () {
    switch (process.platform) {
      case "win32": {
        const t = yield YN(), e = zN;
        if (t)
          return { path: t, type: cr.GNU };
        if (sy(e))
          return { path: e, type: cr.BSD };
        break;
      }
      case "darwin": {
        const t = yield br("gtar", !1);
        return t ? { path: t, type: cr.GNU } : {
          path: yield br("tar", !0),
          type: cr.BSD
        };
      }
    }
    return {
      path: yield br("tar", !0),
      type: cr.GNU
    };
  });
}
function BF(t, e, r) {
  return Yr(this, arguments, void 0, function* (n, s, i, o = "") {
    const a = [`"${n.path}"`], A = rs(s), c = "cache.tar", l = zI(), d = n.type === cr.BSD && s !== ir.Gzip && Xr;
    switch (i) {
      case "create":
        a.push("--posix", "-cf", d ? c : A.replace(new RegExp(`\\${De.sep}`, "g"), "/"), "--exclude", d ? c : A.replace(new RegExp(`\\${De.sep}`, "g"), "/"), "-P", "-C", l.replace(new RegExp(`\\${De.sep}`, "g"), "/"), "--files-from", Mf);
        break;
      case "extract":
        a.push("-xf", d ? c : o.replace(new RegExp(`\\${De.sep}`, "g"), "/"), "-P", "-C", l.replace(new RegExp(`\\${De.sep}`, "g"), "/"));
        break;
      case "list":
        a.push("-tf", d ? c : o.replace(new RegExp(`\\${De.sep}`, "g"), "/"), "-P");
        break;
    }
    if (n.type === cr.GNU)
      switch (process.platform) {
        case "win32":
          a.push("--force-local");
          break;
        case "darwin":
          a.push("--delay-directory-restore");
          break;
      }
    return a;
  });
}
function pd(t, e) {
  return Yr(this, arguments, void 0, function* (r, n, s = "") {
    let i;
    const o = yield CF(), a = yield BF(o, r, n, s), A = n !== "create" ? yield IF(o, r, s) : yield yF(o, r), c = o.type === cr.BSD && r !== ir.Gzip && Xr;
    return c && n !== "create" ? i = [[...A].join(" "), [...a].join(" ")] : i = [[...a].join(" "), [...A].join(" ")], c ? i : [i.join(" ")];
  });
}
function zI() {
  var t;
  return (t = process.env.GITHUB_WORKSPACE) !== null && t !== void 0 ? t : process.cwd();
}
function IF(t, e, r) {
  return Yr(this, void 0, void 0, function* () {
    const n = t.type === cr.BSD && e !== ir.Gzip && Xr;
    switch (e) {
      case ir.Zstd:
        return n ? [
          "zstd -d --long=30 --force -o",
          Oi,
          r.replace(new RegExp(`\\${De.sep}`, "g"), "/")
        ] : [
          "--use-compress-program",
          Xr ? '"zstd -d --long=30"' : "unzstd --long=30"
        ];
      case ir.ZstdWithoutLong:
        return n ? [
          "zstd -d --force -o",
          Oi,
          r.replace(new RegExp(`\\${De.sep}`, "g"), "/")
        ] : ["--use-compress-program", Xr ? '"zstd -d"' : "unzstd"];
      default:
        return ["-z"];
    }
  });
}
function yF(t, e) {
  return Yr(this, void 0, void 0, function* () {
    const r = rs(e), n = t.type === cr.BSD && e !== ir.Gzip && Xr;
    switch (e) {
      case ir.Zstd:
        return n ? [
          "zstd -T0 --long=30 --force -o",
          r.replace(new RegExp(`\\${De.sep}`, "g"), "/"),
          Oi
        ] : [
          "--use-compress-program",
          Xr ? '"zstd -T0 --long=30"' : "zstdmt --long=30"
        ];
      case ir.ZstdWithoutLong:
        return n ? [
          "zstd -T0 --force -o",
          r.replace(new RegExp(`\\${De.sep}`, "g"), "/"),
          Oi
        ] : ["--use-compress-program", Xr ? '"zstd -T0"' : "zstdmt"];
      default:
        return ["-z"];
    }
  });
}
function Ed(t, e) {
  return Yr(this, void 0, void 0, function* () {
    for (const r of t)
      try {
        yield Rr(r, void 0, {
          cwd: e,
          env: Object.assign(Object.assign({}, process.env), { MSYS: "winsymlinks:nativestrict" })
        });
      } catch (n) {
        throw new Error(`${r.split(" ")[0]} failed with error: ${n?.message}`);
      }
  });
}
function Po(t, e) {
  return Yr(this, void 0, void 0, function* () {
    const r = yield pd(e, "list", t);
    yield Ed(r);
  });
}
function qI(t, e) {
  return Yr(this, void 0, void 0, function* () {
    const r = zI();
    yield jn(r);
    const n = yield pd(e, "extract", t);
    yield Ed(n);
  });
}
function GI(t, e, r) {
  return Yr(this, void 0, void 0, function* () {
    ny(De.join(t, Mf), e.join(`
`));
    const n = yield pd(r, "create");
    yield Ed(n, t);
  });
}
var Qs = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function A(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, A);
    }
    c((n = n.apply(t, e || [])).next());
  });
};
class Cr extends Error {
  constructor(e) {
    super(e), this.name = "ValidationError", Object.setPrototypeOf(this, Cr.prototype);
  }
}
class bn extends Error {
  constructor(e) {
    super(e), this.name = "ReserveCacheError", Object.setPrototypeOf(this, bn.prototype);
  }
}
class $i extends Error {
  constructor(e) {
    super(e), this.name = "FinalizeCacheError", Object.setPrototypeOf(this, $i.prototype);
  }
}
function YI(t) {
  if (!t || t.length === 0)
    throw new Cr("Path Validation Error: At least one directory or file path is required");
}
function Cd(t) {
  if (t.length > 512)
    throw new Cr(`Key Validation Error: ${t} cannot be larger than 512 characters.`);
  if (!/^[^,]*$/.test(t))
    throw new Cr(`Key Validation Error: ${t} cannot contain commas.`);
}
function QF(t, e, r, n) {
  return Qs(this, arguments, void 0, function* (s, i, o, a, A = !1) {
    const c = hd();
    return le(`Cache service version: ${c}`), YI(s), c === "v2" ? yield wF(s, i, o, a, A) : yield NF(s, i, o, a, A);
  });
}
function NF(t, e, r, n) {
  return Qs(this, arguments, void 0, function* (s, i, o, a, A = !1) {
    o = o || [];
    const c = [i, ...o];
    if (le("Resolved Keys:"), le(JSON.stringify(c)), c.length > 10)
      throw new Cr("Key Validation Error: Keys are limited to a maximum of 10.");
    for (const u of c)
      Cd(u);
    const l = yield fo();
    let d = "";
    try {
      const u = yield xT(c, s, {
        compressionMethod: l,
        enableCrossOsArchive: A
      });
      if (!u?.archiveLocation)
        return;
      if (a?.lookupOnly)
        return xt("Lookup only - skipping download"), u.cacheKey;
      d = De.join(yield ho(), rs(l)), le(`Archive Path: ${d}`), yield wI(u.archiveLocation, d, a), Sn() && (yield Po(d, l));
      const m = Dn(d);
      return xt(`Cache Size: ~${Math.round(m / (1024 * 1024))} MB (${m} B)`), yield qI(d, l), xt("Cache restored successfully"), u.cacheKey;
    } catch (u) {
      const m = u;
      if (m.name === Cr.name)
        throw u;
      m instanceof en && typeof m.statusCode == "number" && m.statusCode >= 500 ? ni(`Failed to restore: ${u.message}`) : Hr(`Failed to restore: ${u.message}`);
    } finally {
      try {
        yield go(d);
      } catch (u) {
        le(`Failed to delete archive: ${u}`);
      }
    }
  });
}
function wF(t, e, r, n) {
  return Qs(this, arguments, void 0, function* (s, i, o, a, A = !1) {
    a = Object.assign(Object.assign({}, a), { useAzureSdk: !0 }), o = o || [];
    const c = [i, ...o];
    if (le("Resolved Keys:"), le(JSON.stringify(c)), c.length > 10)
      throw new Cr("Key Validation Error: Keys are limited to a maximum of 10.");
    for (const d of c)
      Cd(d);
    let l = "";
    try {
      const d = OI(), u = yield fo(), m = {
        key: i,
        restoreKeys: o,
        version: po(s, u, A)
      }, h = yield d.GetCacheEntryDownloadURL(m);
      if (!h.ok) {
        le(`Cache not found for version ${m.version} of keys: ${c.join(", ")}`);
        return;
      }
      const f = m.key !== h.matchedKey;
      if (xt(f ? `Cache hit for restore-key: ${h.matchedKey}` : `Cache hit for: ${h.matchedKey}`), a?.lookupOnly)
        return xt("Lookup only - skipping download"), h.matchedKey;
      l = De.join(yield ho(), rs(u)), le(`Archive path: ${l}`), le(`Starting download of archive to: ${l}`), yield wI(h.signedDownloadUrl, l, a);
      const p = Dn(l);
      return xt(`Cache Size: ~${Math.round(p / (1024 * 1024))} MB (${p} B)`), Sn() && (yield Po(l, u)), yield qI(l, u), xt("Cache restored successfully"), h.matchedKey;
    } catch (d) {
      const u = d;
      if (u.name === Cr.name)
        throw d;
      u instanceof en && typeof u.statusCode == "number" && u.statusCode >= 500 ? ni(`Failed to restore: ${d.message}`) : Hr(`Failed to restore: ${d.message}`);
    } finally {
      try {
        l && (yield go(l));
      } catch (d) {
        le(`Failed to delete archive: ${d}`);
      }
    }
  });
}
function bF(t, e, r) {
  return Qs(this, arguments, void 0, function* (n, s, i, o = !1) {
    const a = hd();
    return le(`Cache service version: ${a}`), YI(n), Cd(s), a === "v2" ? yield RF(n, s, i, o) : yield xF(n, s, i, o);
  });
}
function xF(t, e, r) {
  return Qs(this, arguments, void 0, function* (n, s, i, o = !1) {
    var a, A, c, l, d;
    const u = yield fo();
    let m = -1;
    const h = yield Tf(n);
    if (le("Cache Paths:"), le(`${JSON.stringify(h)}`), h.length === 0)
      throw new Error("Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.");
    const f = yield ho(), p = De.join(f, rs(u));
    le(`Archive Path: ${p}`);
    try {
      yield GI(f, h, u), Sn() && (yield Po(p, u));
      const y = 10 * 1024 * 1024 * 1024, w = Dn(p);
      if (le(`File Size: ${w}`), w > y && !yI())
        throw new Error(`Cache size of ~${Math.round(w / (1024 * 1024))} MB (${w} B) is over the 10GB limit, not saving cache.`);
      le("Reserving Cache");
      const R = yield ST(s, n, {
        compressionMethod: u,
        enableCrossOsArchive: o,
        cacheSize: w
      });
      if (!((a = R?.result) === null || a === void 0) && a.cacheId)
        m = (A = R?.result) === null || A === void 0 ? void 0 : A.cacheId;
      else throw R?.statusCode === 400 ? new Error((l = (c = R?.error) === null || c === void 0 ? void 0 : c.message) !== null && l !== void 0 ? l : `Cache size of ~${Math.round(w / (1024 * 1024))} MB (${w} B) is over the data cap limit, not saving cache.`) : new bn(`Unable to reserve cache with key ${s}, another job may be creating this cache. More details: ${(d = R?.error) === null || d === void 0 ? void 0 : d.message}`);
      le(`Saving Cache (ID: ${m})`), yield bI(m, p, "", i);
    } catch (y) {
      const w = y;
      if (w.name === Cr.name)
        throw y;
      w.name === bn.name ? xt(`Failed to save: ${w.message}`) : w instanceof en && typeof w.statusCode == "number" && w.statusCode >= 500 ? ni(`Failed to save: ${w.message}`) : Hr(`Failed to save: ${w.message}`);
    } finally {
      try {
        yield go(p);
      } catch (y) {
        le(`Failed to delete archive: ${y}`);
      }
    }
    return m;
  });
}
function RF(t, e, r) {
  return Qs(this, arguments, void 0, function* (n, s, i, o = !1) {
    i = Object.assign(Object.assign({}, i), { uploadChunkSize: 64 * 1024 * 1024, uploadConcurrency: 8, useAzureSdk: !0 });
    const a = yield fo(), A = OI();
    let c = -1;
    const l = yield Tf(n);
    if (le("Cache Paths:"), le(`${JSON.stringify(l)}`), l.length === 0)
      throw new Error("Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.");
    const d = yield ho(), u = De.join(d, rs(a));
    le(`Archive Path: ${u}`);
    try {
      yield GI(d, l, a), Sn() && (yield Po(u, a));
      const m = Dn(u);
      le(`File Size: ${m}`), i.archiveSizeBytes = m, le("Reserving Cache");
      const h = po(n, a, o), f = {
        key: s,
        version: h
      };
      let p;
      try {
        const R = yield A.CreateCacheEntry(f);
        if (!R.ok)
          throw R.message && Hr(`Cache reservation failed: ${R.message}`), new Error(R.message || "Response was not ok");
        p = R.signedUploadUrl;
      } catch (R) {
        throw le(`Failed to reserve cache: ${R}`), new bn(`Unable to reserve cache with key ${s}, another job may be creating this cache.`);
      }
      le(`Attempting to upload cache located at: ${u}`), yield bI(c, u, p, i);
      const y = {
        key: s,
        version: h,
        sizeBytes: `${m}`
      }, w = yield A.FinalizeCacheEntryUpload(y);
      if (le(`FinalizeCacheEntryUploadResponse: ${w.ok}`), !w.ok)
        throw w.message ? new $i(w.message) : new Error(`Unable to finalize cache with key ${s}, another job may be finalizing this cache.`);
      c = parseInt(w.entryId);
    } catch (m) {
      const h = m;
      if (h.name === Cr.name)
        throw m;
      h.name === bn.name ? xt(`Failed to save: ${h.message}`) : h.name === $i.name ? Hr(h.message) : h instanceof en && typeof h.statusCode == "number" && h.statusCode >= 500 ? ni(`Failed to save: ${h.message}`) : Hr(`Failed to save: ${h.message}`);
    } finally {
      try {
        yield go(u);
      } catch (m) {
        le(`Failed to delete archive: ${m}`);
      }
    }
    return c;
  });
}
const SF = "version", DF = "edition", kF = "architecture", MF = "platform", TF = "email", FF = "token", vF = "i-agree-to-the-eula", LF = "version", UF = "path", Us = "flyway", PF = "setup-flyway-action", HF = "setup-flyway", JI = "https://download.red-gate.com/maven/release/com/redgate/flyway/flyway-commandline", OF = `${JI}/maven-metadata.xml`, VI = (t, e, r) => `${HF}-${e}-${r}-${t}`, _I = (t) => {
  const e = process.env.RUNNER_TOOL_CACHE ?? "";
  return De.join(e, Us, t);
}, zF = async (t, e, r) => {
  const n = VI(t, e, r), s = _I(t);
  try {
    return await QF([s], n) ? (le(`Restored Flyway ${t} from GitHub Actions cache`), !0) : (le("GitHub Actions cache miss"), !1);
  } catch (i) {
    const o = i instanceof Error ? i.message : String(i);
    return le(`Failed to restore from cache: ${o}`), !1;
  }
}, qF = async (t, e, r) => {
  const n = VI(t, e, r), s = _I(t);
  try {
    await bF([s], n), le(`Saved Flyway ${t} to GitHub Actions cache`);
  } catch (i) {
    if (i instanceof bn)
      le(`Cache entry already exists for key: ${n}`);
    else {
      const o = i instanceof Error ? i.message : String(i);
      le(`Failed to save to cache: ${o}`);
    }
  }
};
var Bd = /* @__PURE__ */ ((t) => (t.X64 = "x64", t.ARM64 = "arm64", t.JAVA = "java", t))(Bd || {}), WI = /* @__PURE__ */ ((t) => (t.COMMUNITY = "community", t.TEAMS = "teams", t.ENTERPRISE = "enterprise", t))(WI || {}), $I = /* @__PURE__ */ ((t) => (t.WINDOWS = "windows", t.MACOSX = "macosx", t.LINUX = "linux", t.LINUX_ALPINE = "linux-alpine", t))($I || {});
const GF = () => {
  const t = Gn(SF, { required: !0 }), e = YF(DF, WI), r = Jg(kF, Bd, VF), n = Jg(MF, $I, JF);
  le(`Inputs: version: ${t}, architecture: ${r}, platform: ${n}`);
  const s = Gn(TF), i = s?.trim() ? s.trim() : void 0, o = Gn(FF), a = o?.trim() ? o.trim() : void 0, c = Gn(vF, { required: !0 }).trim().toLowerCase() === "true";
  if (!_F(n, r))
    throw Error(`Unsupported platform: ${n}-${r}`);
  return {
    versionSpec: t,
    edition: e,
    architecture: r,
    platform: n,
    email: i,
    token: a,
    agreeToEula: c
  };
}, YF = (t, e) => {
  const r = Gn(t, { required: !0 }), n = e[r.toUpperCase()];
  if (!n) {
    const s = Object.values(e).join(", ");
    throw Error(`Invalid value '${r}' for input '${t}'. Allowed values: ${s}`);
  }
  return n;
}, Jg = (t, e, r) => {
  const n = Gn(t);
  if (n == null || n.trim().length === 0)
    return r();
  const s = e[n.toUpperCase()];
  if (!s)
    throw Error(`Unrecognized input value: ${n}`);
  return s;
}, JF = () => {
  const t = process.platform;
  switch (t) {
    case "darwin":
      return "macosx";
    case "win32":
      return "windows";
    case "linux":
      return "linux";
    default:
      throw Error(`Unsupported platform: ${t}`);
  }
}, VF = () => {
  const t = cl.arch();
  switch (t) {
    case "x64":
      return "x64";
    case "ia32":
      return "x64";
    case "arm64":
      return "arm64";
    default:
      throw Error(`Unsupported architecture: ${t}`);
  }
}, _F = (t, e) => {
  const r = `${t}-${e}`;
  return e == "java" || ["windows-x64", "linux-x64", "macosx-arm64", "macosx-x64", "linux-alpine-x64"].includes(r);
}, WF = async () => {
  const t = await XF();
  return $F(t);
}, $F = async (t) => {
  const n = new kp().parse(t).metadata.versioning, s = n.release, i = n.versions.version;
  return { latest: s, availableVersions: i };
}, XF = async () => {
  const t = OF;
  return le(`Using metadata endpoint: ${t}`), await ZF(t);
}, ZF = async (t) => {
  const r = await new Kn(PF).get(t);
  if (r.message.statusCode !== 200)
    throw new Error(`Failed to fetch versions from URL. Status code: ${r.message.statusCode}`);
  const n = r.message.headers["content-type"];
  if (!KF(n))
    throw new Error(`Unexpected content type: ${n}`);
  return await r.readBody();
}, KF = (t) => {
  const e = t?.split(";")[0];
  return e === "application/xml" || e === "text/plain";
}, jF = async (t, e, r) => {
  const n = nv(t, e, r), s = await hN(n);
  return { downloadUrl: n, pathToArchive: s };
}, ev = (t) => t === "windows" ? "zip" : "tar.gz", tv = (t, e, r) => t == "latest" ? r : Sr.maxSatisfying(e, t), rv = async (t, e) => {
  switch (e) {
    case "tar.gz":
    case "tar":
      return await pN(t);
    case "zip":
      return await EN(t);
    default:
      return await fN(t);
  }
}, nv = (t, e, r) => {
  const n = ev(e), s = JI;
  return r == Bd.JAVA ? `${s}/${t}/flyway-commandline-${t}.${n}` : `${s}/${t}/flyway-commandline-${t}-${e}-${r}.${n}`;
}, sv = async (t) => {
  let e = "";
  const r = await Rr("flyway", ["--version"], {
    silent: !0,
    ignoreReturnCode: !0,
    listeners: {
      stdout: (i) => e += i.toString(),
      stderr: (i) => e += i.toString()
    }
  }), n = e.match(/Flyway\s+(Community|Teams|Enterprise)\s+Edition/);
  if (r !== 0 && !n) {
    xt(e), Hr(`flyway --version exited with code ${r}. Skipping edition check.`);
    return;
  }
  const s = n ? n[1].toLowerCase() : "community";
  if (s !== t)
    throw new Error(`Edition mismatch: expected '${t}' but Flyway reported '${s}'`);
}, iv = async (t, e, r) => {
  Li(e);
  const n = ["auth", `-email=${t}`, `-token=${e}`];
  r && n.push("-IAgreeToTheEula"), await Rr("flyway", n);
}, ov = async (t, e, r) => {
  let n = ph(Us, t, r);
  if (n || await zF(t, e, r) && (n = ph(Us, t, r)), !n) {
    const s = await jF(t, e, r), i = s.downloadUrl.endsWith(".zip") ? "zip" : "tar.gz", o = await rv(s.pathToArchive, i), a = De.join(o, `flyway-${t}`);
    n = await IN(a, Us, t, r), await qF(t, e, r);
  }
  return n;
}, av = async () => {
  try {
    const t = GF(), { versionSpec: e, architecture: r, platform: n } = t;
    RA(`Installing ${Us}`);
    const s = await WF();
    xt(`Latest version: ${s.latest}`), le(`Available versions: ${s.availableVersions.join(", ")}`);
    const i = tv(e, s.availableVersions, s.latest);
    if (i == null) {
      Nm(`Version specification ${e} is not available`);
      return;
    }
    le(`Resolved ${e} to version: ${i}`);
    const o = await ov(i, n, r);
    Qm(LF, i), Qm(UF, o), HQ(`FLYWAY_HOME_${i}`, o), OQ(o), SA(), t.email && t.token && (RA("Authenticating Flyway"), await iv(t.email, t.token, t.agreeToEula), SA()), RA("Verifying Flyway edition"), await sv(t.edition), SA();
  } catch (t) {
    const e = t instanceof Error ? t.message : String(t);
    Nm(e);
  }
};
process.argv[1].endsWith("index.js") && await av();
